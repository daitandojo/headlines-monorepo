# 📁 PROJECT DIRECTORY STRUCTURE

Total: 4 files, 3 directories

```
headlines/
├── 📁 src/
│   ├── 📁 middleware/
│   │   └── 📄 auth.js
│   ├── 📁 routes/
│   │   └── 📄 scrapeTest.js
│   └── 📄 index.js
└── 📄 package.json
```

# 📋 PROJECT METADATA

**Generated**: 2025-10-05T19:41:33.268Z
**Repository Path**: /home/mark/Repos/projects/headlines/apps/server
**Total Files**: 4
**Package**: @headlines/server@1.0.0




---


## 📄 package.json
*Lines: 21, Size: 528 Bytes*

```json
{
  "name": "@headlines/server",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "start": "node src/index.js",
    "dev": "node --watch src/index.js"
  },
  "dependencies": {
    "@headlines/config": "workspace:*",
    "@headlines/data-access": "workspace:*",
    "@headlines/models": "workspace:*",
    "@headlines/scraper-logic": "workspace:*",
    "@headlines/utils-server": "workspace:*",
    "cors": "^2.8.5",
    "express": "^4.19.2",
    "jose": "^5.6.3",
    "playwright": "^1.45.1"
  }
}
```

## 📄 src/index.js
*Lines: 47, Size: 1.32 KB*

```javascript
// apps/server/src/index.js
import express from 'express'
import cors from 'cors'
import pino from 'pino'
import { createRequire } from 'module'
import { env } from '@headlines/config/node'
import { setLogger } from '@headlines/utils-shared'
import dbConnect from '@headlines/data-access/dbConnect/node'
import { scrapeTestRoute } from './routes/scrapeTest.js'

const require = createRequire(import.meta.url)
const pinoPrettyPath = require.resolve('pino-pretty')
const consoleTransport = pino.transport({
  target: pinoPrettyPath,
  options: { colorize: true, translateTime: 'HH:MM:ss', ignore: 'pid,hostname' },
})
const logger = pino({ level: 'info' }, consoleTransport)
setLogger(logger) // Inject logger instance

async function startServer() {
  logger.info('🚀 Starting API Server...')

  try {
    await dbConnect()
  } catch (error) {
    logger.fatal({ err: error }, 'Failed to connect to database. Halting server.')
    process.exit(1)
  }

  const app = express()
  const PORT = process.env.PORT || 3002

  app.use(cors())
  app.use(express.json())

  app.use('/api/scrape-test', scrapeTestRoute)
  app.get('/health', (req, res) => {
    res.status(200).json({ status: 'ok', timestamp: new Date().toISOString() })
  })

  app.listen(PORT, () => {
    logger.info(`✅ Server listening on http://localhost:${PORT}`)
  })
}

startServer()

```

## 📄 src/middleware/auth.js
*Lines: 35, Size: 1.21 KB*

```javascript
// apps/server/src/middleware/auth.js (version 1.0.0)
import { env } from '@headlines/config/node'
import * as jose from 'jose'
import { logger } from '@headlines/utils-shared'

// This middleware verifies a simple JWT sent from the Next.js admin panel
// to ensure only authorized users can trigger resource-intensive scrapes.
export async function verifyAdmin(req, res, next) {
  const authHeader = req.headers.authorization
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Authorization header is missing or invalid.' })
  }

  const token = authHeader.split(' ')[1]
  if (!token) {
    return res.status(401).json({ error: 'Token is missing.' })
  }

  try {
    const secret = new TextEncoder().encode(env.JWT_SECRET)
    const { payload } = await jose.jwtVerify(token, secret)

    if (payload.role !== 'admin') {
      return res.status(403).json({ error: 'Forbidden: Administrator access required.' })
    }

    // Attach user payload to the request for potential use in routes
    req.user = payload
    next()
  } catch (e) {
    logger.warn({ err: e }, 'Admin verification failed for scrape-test API.')
    return res.status(401).json({ error: 'Invalid or expired token.' })
  }
}

```

## 📄 src/routes/scrapeTest.js
*Lines: 38, Size: 1.16 KB*

```javascript
// apps/server/src/routes/scrapeTest.js (version 1.0.0)
import { Router } from 'express'
import { verifyAdmin } from '../middleware/auth.js'
import { testScraperRecipe } from '@headlines/scraper-logic/node'
import { Source } from '@headlines/models/node'
import { logger } from '@headlines/utils-shared'

const router = Router()

// All routes in this file are protected by the admin verification middleware.
router.use(verifyAdmin)

router.post('/', async (req, res) => {
  const { sourceId, articleUrl } = req.body

  if (!sourceId) {
    return res.status(400).json({ error: 'sourceId is required.' })
  }

  try {
    const source = await Source.findById(sourceId).lean()
    if (!source) {
      return res.status(404).json({ error: 'Source not found.' })
    }

    // Delegate the complex scraping logic to the shared test-orchestrator.
    const result = await testScraperRecipe(source, articleUrl)
    return res.status(200).json(result)
  } catch (error) {
    logger.error({ err: error }, 'Error in /scrape-test endpoint.')
    return res
      .status(500)
      .json({ error: `An internal server error occurred: ${error.message}` })
  }
})

export { router as scrapeTestRoute }

```
