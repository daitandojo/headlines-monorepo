// apps/pipeline/scripts/seed/lib/pipeline-injector.js
import { runAssessAndEnrich } from '../../../src/pipeline/3_assessAndEnrich.js'
import { runClusterAndSynthesize } from '../../../src/pipeline/4_clusterAndSynthesize.js'
import { judgeAndFilterOutput } from '../../../src/pipeline/submodules/commit/1_judgeOutput.js'
import { saveResultsToDb } from '../../../src/pipeline/submodules/commit/2_saveResults.js'
import { tokenTracker, apiCallTracker, logger } from '@headlines/utils/server'
import { settings } from '@headlines/config/server'

const FATAL_JUDGEMENT_QUALITIES = ['Irrelevant', 'Poor']

/**
 * Injects a synthetic article into the pipeline from Stage 3 onwards.
 * @param {object} syntheticArticle - The article object to process.
 * @returns {Promise<{savedEvents: Array, savedOpportunities: Array}>} The final saved data.
 */
export async function runInjectedPipeline(syntheticArticle) {
  tokenTracker.reset()
  apiCallTracker.reset()

  tokenTracker.initializeModels([
    settings.LLM_MODEL_HEADLINE_ASSESSMENT,
    settings.LLM_MODEL_ARTICLE_ASSESSMENT,
    settings.LLM_MODEL_SYNTHESIS,
    settings.LLM_MODEL_UTILITY,
  ])

  let payload = {
    articlesForPipeline: [syntheticArticle],
    runStats: {
      errors: [],
      synthesizedEventsForReport: [],
      enrichmentOutcomes: [],
      headlinesScraped: 0,
      scraperHealth: [],
      validatedHeadlines: 0,
      freshHeadlinesFound: 1,
      headlinesAssessed: 0,
      relevantHeadlines: 0,
      articlesEnriched: 0,
      relevantArticles: 0,
      eventsClustered: 0,
      eventsSynthesized: 0,
      judgeVerdict: null,
      eventsEmailed: 0,
      tokenUsage: {},
      apiCalls: {},
    },
  }

  logger.info('  -> Injecting into Stage 3: Assess & Enrich...')
  payload = (await runAssessAndEnrich(payload)).payload

  if (payload.enrichedArticles?.length > 0) {
    logger.info('  -> Injecting into Stage 4: Cluster & Synthesize...')
    payload = (await runClusterAndSynthesize(payload)).payload
  } else {
    logger.warn('  -> Skipping Stage 4: No articles were successfully enriched.')
  }

  logger.info('  -> Injecting into Stage 5 (Commit): Judging output...')
  const { finalEvents, finalOpportunities } = await judgeAndFilterOutput(
    payload,
    FATAL_JUDGEMENT_QUALITIES
  )

  logger.info('  -> Injecting into Stage 5 (Commit): Saving results to database...')
  // DEFINITIVE FIX: saveResultsToDb already returns the fully populated, saved documents.
  // The bug was in the calling script, which has since been fixed. This function is already correct.
  const { savedEvents, savedOpportunities } = await saveResultsToDb(
    payload,
    finalEvents,
    finalOpportunities
  )

  return { savedEvents, savedOpportunities }
}
