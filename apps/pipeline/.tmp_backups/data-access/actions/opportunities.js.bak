// packages/data-access/src/actions/opportunities.js (version 2.1.0)
'use server'

import dbConnect from '../dbConnect.js'
import { Opportunity, Subscriber } from '@headlines/models'
import { revalidatePath } from '../revalidate.js'
import { buildQuery } from '../queryBuilder.js'
import { getUserIdFromSession } from '@headlines/auth/src/verifySession.js'
import mongoose from 'mongoose'

const OPPORTUNITIES_PER_PAGE = 10

export async function getOpportunities({ page = 1, filters = {}, sort = 'date_desc' }) {
  const userId = await getUserIdFromSession()
  await dbConnect()
  const { queryFilter, sortOptions } = await buildQuery(Opportunity, {
    filters,
    sort,
    userId,
  })
  const skipAmount = (page - 1) * OPPORTUNITIES_PER_PAGE

  const opportunities = await Opportunity.find(queryFilter)
    .populate({
      path: 'events',
      select:
        'synthesized_headline synthesized_summary source_articles highest_relevance_score',
      options: { limit: 1, sort: { createdAt: -1 } },
    })
    .sort(sortOptions)
    .skip(skipAmount)
    .limit(OPPORTUNITIES_PER_PAGE)
    .lean()

  const processed = opportunities.map((opp) => ({
    ...opp,
    sourceEventId: opp.events?.[0] || null,
  }))
  return JSON.parse(JSON.stringify(processed))
}

export async function getTotalOpportunitiesCount({ filters = {} } = {}) {
  const userId = await getUserIdFromSession()
  await dbConnect()
  const { queryFilter } = await buildQuery(Opportunity, { filters, userId })
  return await Opportunity.countDocuments(queryFilter)
}

export async function deleteOpportunity({ opportunityId, userId }) {
  if (!opportunityId) return { success: false, message: 'ID is required.' }
  try {
    await dbConnect()
    if (userId) {
      await Subscriber.updateOne(
        { _id: userId },
        { $addToSet: { 'discardedItems.opportunities': opportunityId } }
      )
    }
    await revalidatePath('/opportunities')
    return { success: true, message: 'Opportunity discarded.' }
  } catch (error) {
    return { success: false, message: 'Failed to discard opportunity.' }
  }
}

// NEW FUNCTION for Project Drill Down
export async function getOpportunityDetails(opportunityId) {
  if (!mongoose.Types.ObjectId.isValid(opportunityId)) {
    return { success: false, error: 'Invalid ID format.' }
  }
  try {
    await dbConnect()
    const opportunity = await Opportunity.findById(opportunityId)
      .populate({
        path: 'events',
        options: { sort: { createdAt: -1 } }, // Sort events by most recent
      })
      .lean()

    if (!opportunity) {
      return { success: false, error: 'Opportunity not found.' }
    }

    return { success: true, data: JSON.parse(JSON.stringify(opportunity)) }
  } catch (error) {
    return { success: false, error: 'Database error while fetching opportunity details.' }
  }
}

export async function getUniqueOpportunityCountries() {
  const userId = await getUserIdFromSession();
  await dbConnect();
  const { queryFilter } = await buildQuery(Opportunity, { userId });
  // Use distinct to get a list of unique 'basedIn' values that are not null/empty
  const countries = await Opportunity.distinct('basedIn', { ...queryFilter, basedIn: { $ne: null, $ne: '' } });
  return JSON.parse(JSON.stringify(countries.sort()));
}
