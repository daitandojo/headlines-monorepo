# ðŸ“ PROJECT DIRECTORY STRUCTURE

Total: 15 files, 1 directories

```
headlines/
â”œâ”€â”€ ðŸ“ src/
â”‚   â”œâ”€â”€ ðŸ“„ Article.js
â”‚   â”œâ”€â”€ ðŸ“„ constants.js
â”‚   â”œâ”€â”€ ðŸ“„ Country.js
â”‚   â”œâ”€â”€ ðŸ“„ index.js
â”‚   â”œâ”€â”€ ðŸ“„ Opportunity.js
â”‚   â”œâ”€â”€ ðŸ“„ PushSubscription.js
â”‚   â”œâ”€â”€ ðŸ“„ RunVerdict.js
â”‚   â”œâ”€â”€ ðŸ“„ Setting.js
â”‚   â”œâ”€â”€ ðŸ“„ Source.js
â”‚   â”œâ”€â”€ ðŸ“„ SourceSuggestion.js
â”‚   â”œâ”€â”€ ðŸ“„ Subscriber.js
â”‚   â”œâ”€â”€ ðŸ“„ SynthesizedEvent.js
â”‚   â”œâ”€â”€ ðŸ“„ WatchlistEntity.js
â”‚   â””â”€â”€ ðŸ“„ WatchlistSuggestion.js
â””â”€â”€ ðŸ“„ package.json
```

# ðŸ“‹ PROJECT METADATA

**Generated**: 2025-09-17T10:46:26.446Z
**Repository Path**: /home/mark/Repos/projects/headlines/packages/models
**Total Files**: 15
**Package**: @headlines/models@1.0.0
**Description**: Shared Mongoose models for the Headlines monorepo.



---


## ðŸ“„ package.json
*Lines: 13, Size: 267 Bytes*

```json
{
  "name": "@headlines/models",
  "version": "1.0.0",
  "description": "Shared Mongoose models for the Headlines monorepo.",
  "main": "src/index.js",
  "type": "module",
  "license": "ISC",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "mongoose": "^8.4.1"
  }
}

```

## ðŸ“„ src/Article.js
*Lines: 13, Size: 2.69 KB*

```javascript
// packages/models/src/Article.js (version 5.0.0 - Self-Contained)
import mongoose from 'mongoose';
import { ARTICLE_STATUSES } from './constants.js';
const { Schema, model, models } = mongoose;
const LifecycleEventSchema = new Schema({ stage: { type: String, required: true }, status: { type: String, required: true }, reason: { type: String }, timestamp: { type: Date, default: Date.now }, }, { _id: false });
const ArticleSchema = new Schema({ headline: { type: String, required: true, trim: true, minlength: 5, maxlength: 500 }, headline_en: { type: String, trim: true }, link: { type: String, required: true, unique: true, trim: true }, newspaper: { type: String, required: true, trim: true }, source: { type: String, required: true, trim: true }, country: { type: String, trim: true, index: true }, imageUrl: { type: String, trim: true }, headline_selector: { type: String, trim: true }, relevance_headline: { type: Number, required: true, min: 0, max: 100 }, assessment_headline: { type: String, required: true, trim: true }, classification: { type: String, trim: true }, topic: { type: String, trim: true }, relevance_article: { type: Number, min: 0, max: 100 }, assessment_article: { type: String, trim: true }, amount: { type: Number }, key_individuals: [{ _id: false, name: { type: String, trim: true }, role_in_event: { type: String, trim: true }, company: { type: String, trim: true }, email_suggestion: { type: String, trim: true }, }], enrichment_error: { type: String, trim: true }, emailed: { type: Boolean, default: false }, embedding: { type: [Number] }, synthesizedEventId: { type: Schema.Types.ObjectId, ref: 'SynthesizedEvent', index: true, required: false, }, status: { type: String, enum: ARTICLE_STATUSES, default: 'scraped', index: true }, pipeline_lifecycle: { type: [LifecycleEventSchema], default: [] }, }, { timestamps: true, collection: 'articles', methods: { toRealtimePayload() { return { _id: this._id, headline: this.headline, headline_en: this.headline_en, link: this.link, newspaper: this.newspaper, country: this.country, topic: this.topic, relevance_article: this.relevance_article, assessment_article: this.assessment_article, key_individuals: (this.key_individuals || []).map((p) => ({ name: p.name, role_in_event: p.role_in_event, company: p.company, })), createdAt: this.createdAt, updatedAt: this.updatedAt, }; }, }, });
ArticleSchema.index({ headline: 'text', headline_en: 'text', assessment_article: 'text' });
ArticleSchema.index({ newspaper: 1, createdAt: -1 });
ArticleSchema.index({ relevance_article: -1, createdAt: -1 });
ArticleSchema.index({ relevance_headline: -1, createdAt: -1 });
ArticleSchema.index({ country: 1, createdAt: -1 });
export default models.Article || model('Article', ArticleSchema);

```

## ðŸ“„ src/Country.js
*Lines: 6, Size: 584 Bytes*

```javascript
// packages/models/src/Country.js (version 4.0.0 - Self-Contained)
import mongoose from 'mongoose';
const { Schema, model, models } = mongoose;
const CountrySchema = new Schema({ name: { type: String, required: true, unique: true, trim: true, }, isoCode: { type: String, required: true, unique: true, trim: true, uppercase: true, minlength: 2, maxlength: 2, }, status: { type: String, enum: ['active', 'inactive'], default: 'active', required: true, index: true, }, }, { timestamps: true, collection: 'countries', });
export default models.Country || model('Country', CountrySchema);

```

## ðŸ“„ src/Opportunity.js
*Lines: 7, Size: 1.01 KB*

```javascript
// packages/models/src/Opportunity.js (version 8.0.0 - Self-Contained)
import mongoose from 'mongoose';
const { Schema, model, models } = mongoose;
const ContactDetailsSchema = new Schema({ email: { type: String, trim: true }, role: { type: String, trim: true }, company: { type: String, trim: true }, }, { _id: false });
const OpportunitySchema = new Schema({ reachOutTo: { type: String, required: true, trim: true, unique: true, index: true }, contactDetails: { type: ContactDetailsSchema }, basedIn: { type: String, trim: true, index: true }, city: { type: String, trim: true, required: false }, whyContact: { type: [String], required: true }, likelyMMDollarWealth: { type: Number, required: true, default: 0 }, embedding: { type: [Number] }, events: [{ type: Schema.Types.ObjectId, ref: 'SynthesizedEvent', index: true, }], relatedOpportunities: [{ type: Schema.Types.ObjectId, ref: 'Opportunity' }], }, { timestamps: true, collection: 'opportunities', });
export default models.Opportunity || model('Opportunity', OpportunitySchema);

```

## ðŸ“„ src/PushSubscription.js
*Lines: 6, Size: 598 Bytes*

```javascript
// packages/models/src/PushSubscription.js (version 4.0.0 - Self-Contained)
import mongoose from 'mongoose';
const { Schema, model, models } = mongoose;
const PushSubscriptionSchema = new Schema({ subscriberId: { type: Schema.Types.ObjectId, ref: 'Subscriber', required: true, index: true, }, endpoint: { type: String, required: true, unique: true }, keys: { p256dh: { type: String, required: true }, auth: { type: String, required: true }, }, }, { timestamps: true, collection: 'push_subscriptions', });
export default models.PushSubscription || model('PushSubscription', PushSubscriptionSchema);

```

## ðŸ“„ src/RunVerdict.js
*Lines: 7, Size: 763 Bytes*

```javascript
// packages/models/src/RunVerdict.js (version 4.0.0 - Self-Contained)
import mongoose from 'mongoose';
const { Schema, model, models } = mongoose;
const RunVerdictSchema = new Schema({ runStats: { type: Schema.Types.Mixed, required: true, }, judgeVerdict: { type: Schema.Types.Mixed, required: false, default: {}, }, generatedEvents: [{ type: Schema.Types.ObjectId, ref: 'SynthesizedEvent', }], generatedOpportunities: [{ type: Schema.Types.ObjectId, ref: 'Opportunity', }], duration_seconds: { type: Number, required: true, }, cost_summary: { type: Schema.Types.Mixed, required: false, }, }, { timestamps: true, collection: 'run_verdicts', });
RunVerdictSchema.index({ createdAt: -1 });
export default models.RunVerdict || model('RunVerdict', RunVerdictSchema);

```

## ðŸ“„ src/Setting.js
*Lines: 6, Size: 1.04 KB*

```javascript
// packages/models/src/Setting.js (version 4.0.0 - Self-Contained)
import mongoose from 'mongoose';
const { Schema, model, models } = mongoose;
const SettingSchema = new Schema({ key: { type: String, required: true, unique: true, index: true, enum: [ 'HEADLINES_RELEVANCE_THRESHOLD', 'ARTICLES_RELEVANCE_THRESHOLD', 'EVENT_RELEVANCE_THRESHOLD', 'MINIMUM_EVENT_AMOUNT_USD_MILLIONS', 'HIGH_SIGNAL_HEADLINE_THRESHOLD', 'AGENT_DISAGREEMENT_THRESHOLD', 'SINGLETON_RELEVANCE_THRESHOLD', 'HIGH_VALUE_DEAL_USD_MM', 'SIGNIFICANT_PRIVATE_BENEFICIARY_USD_MM', 'WATCHLIST_SCORE_BOOST', 'SUGGESTION_GENERATION_THRESHOLD', 'MIN_ARTICLE_CHARS', 'LLM_MODEL_HEADLINE_ASSESSMENT', 'LLM_MODEL_ARTICLE_ASSESSMENT', 'LLM_MODEL_SYNTHESIS', 'LLM_MODEL_UTILITY', ], }, value: { type: Schema.Types.Mixed, required: true, }, description: { type: String, required: false, }, type: { type: String, required: true, enum: ['number', 'boolean', 'string'], default: 'number', }, }, { timestamps: true, collection: 'settings', });
export default models.Setting || model('Setting', SettingSchema);

```

## ðŸ“„ src/Source.js
*Lines: 10, Size: 2.06 KB*

```javascript
// packages/models/src/Source.js (version 6.0.0 - Self-Contained)
import mongoose from 'mongoose';
import { SOURCE_STATUSES, SOURCE_FREQUENCIES, EXTRACTION_METHODS } from './constants.js';
const { Schema, model, models } = mongoose;
const SourceAnalyticsSchema = new Schema({ totalRuns: { type: Number, default: 0 }, totalSuccesses: { type: Number, default: 0 }, totalFailures: { type: Number, default: 0 }, totalScraped: { type: Number, default: 0 }, totalRelevant: { type: Number, default: 0 }, lastRunHeadlineCount: { type: Number, default: 0 }, lastRunRelevantCount: { type: Number, default: 0 }, lastRunContentSuccess: { type: Boolean, default: false }, }, { _id: false });
const SourceSchema = new Schema({ name: { type: String, required: true, unique: true, trim: true }, baseUrl: { type: String, required: true, trim: true }, sectionUrl: { type: String, required: true, trim: true }, rssUrl: { type: String, required: false, trim: true }, country: { type: String, required: true, trim: true, index: true }, language: { type: String, required: true, trim: true, default: 'en' }, status: { type: String, enum: SOURCE_STATUSES, default: 'active', required: true, index: true, }, scrapeFrequency: { type: String, enum: SOURCE_FREQUENCIES, default: 'high', required: true, }, extractionMethod: { type: String, enum: EXTRACTION_METHODS, required: true, default: 'declarative', }, headlineSelector: { type: [String], required: false }, linkSelector: { type: String, required: false, trim: true }, headlineTextSelector: { type: String, required: false, trim: true }, articleSelector: { type: [String], required: false }, lastScrapedAt: { type: Date, required: false, index: true }, lastSuccessAt: { type: Date, required: false }, notes: { type: String, required: false, trim: true }, analytics: { type: SourceAnalyticsSchema, default: () => ({}) }, }, { timestamps: true, collection: 'sources', });
SourceSchema.index({ status: 1, scrapeFrequency: 1, lastScrapedAt: 1 });
SourceSchema.index({ 'analytics.lastRunHeadlineCount': 1, status: 1 });
export default models.Source || model('Source', SourceSchema);

```

## ðŸ“„ src/SourceSuggestion.js
*Lines: 7, Size: 955 Bytes*

```javascript
// packages/models/src/SourceSuggestion.js (version 4.0.0 - Self-Contained)
import mongoose from 'mongoose';
import { SUGGESTION_STATUSES } from './constants.js';
const { Schema, model, models } = mongoose;
const SourceSuggestionSchema = new Schema({ sourceId: { type: Schema.Types.ObjectId, ref: 'Source', required: true, index: true }, sourceName: { type: String, required: true }, failedSelector: { type: String, required: true }, sourceHtmlPath: { type: String, required: false }, suggestedSelectors: { headlineSelector: { type: String }, linkSelector: { type: String }, headlineTextSelector: { type: String }, articleSelector: { type: String }, }, reasoning: { type: String, required: true }, status: { type: String, enum: SUGGESTION_STATUSES, default: 'pending', required: true, index: true, }, }, { timestamps: true, collection: 'source_suggestions', });
export default models.SourceSuggestion || model('SourceSuggestion', SourceSuggestionSchema);

```

## ðŸ“„ src/Subscriber.js
*Lines: 54, Size: 2.77 KB*

```javascript
// packages/models/src/Subscriber.js (version 12.0.0)
import mongoose from 'mongoose';
import bcrypt from 'bcrypt';
import { SUBSCRIBER_ROLES, SUBSCRIPTION_TIERS } from './constants.js';
const { Schema, model, models } = mongoose;
const SALT_WORK_FACTOR = 10;

const CountrySubscriptionSchema = new Schema({ name: { type: String, required: true }, active: { type: Boolean, default: true, required: true }, }, { _id: false });
const InteractionSchema = new Schema({ articles: { type: [String], default: [] }, events: { type: [String], default: [] }, opportunities: { type: [String], default: [] }, }, { _id: false });
// DEFINITIVE FIX: Add a schema to store user's filter preferences.
const FilterPreferencesSchema = new Schema({ globalCountryFilter: { type: [String], default: [] } }, { _id: false });

const SubscriberSchema = new Schema({
    email: { type: String, required: true, unique: true, trim: true, lowercase: true, index: true },
    password: { type: String, required: true, select: false },
    firstName: { type: String, required: true, trim: true },
    lastName: { type: String, required: false, trim: true },
    language: { type: String, required: true, default: 'English' },
    countries: { type: [CountrySubscriptionSchema], required: true, default: [] },
    role: { type: String, enum: SUBSCRIBER_ROLES, default: 'user', required: true },
    emailNotificationsEnabled: { type: Boolean, default: true },
    pushNotificationsEnabled: { type: Boolean, default: true },
    subscriptionTier: { type: String, enum: SUBSCRIPTION_TIERS, default: 'free' },
    subscriptionExpiresAt: { type: Date, default: null },
    isLifetimeFree: { type: Boolean, default: false },
    isActive: { type: Boolean, default: true, index: true },
    lastLoginAt: { type: Date, default: null },
    discardedItems: { type: InteractionSchema, default: () => ({}) },
    favoritedItems: { type: InteractionSchema, default: () => ({}) },
    // DEFINITIVE FIX: Add the new field to the main schema.
    filterPreferences: { type: FilterPreferencesSchema, default: () => ({ globalCountryFilter: [] }) },
    emailSentCount: { type: Number, default: 0 },
    eventsReceivedCount: { type: Number, default: 0 },
}, { timestamps: true, collection: 'subscribers' });

SubscriberSchema.pre('save', function (next) {
  const user = this;
  if (!user.isModified('password')) return next();
  bcrypt.genSalt(SALT_WORK_FACTOR, function (err, salt) {
    if (err) return next(err);
    bcrypt.hash(user.password, salt, function (err, hash) {
      if (err) return next(err);
      user.password = hash;
      next();
    });
  });
});

SubscriberSchema.methods.comparePassword = function (candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

export default models.Subscriber || model('Subscriber', SubscriberSchema);

```

## ðŸ“„ src/SynthesizedEvent.js
*Lines: 10, Size: 2.35 KB*

```javascript
// packages/models/src/SynthesizedEvent.js (version 7.0.0 - Self-Contained)
import mongoose from 'mongoose';
const { Schema, model, models } = mongoose;
const SourceArticleSchema = new Schema({ headline: { type: String, required: true, trim: true }, link: { type: String, required: true, trim: true }, newspaper: { type: String, required: true, trim: true }, imageUrl: { type: String, trim: true }, }, { _id: false });
const KeyIndividualSchema = new Schema({ name: { type: String, trim: true }, role_in_event: { type: String, trim: true }, company: { type: String, trim: true }, email_suggestion: { type: String, trim: true }, }, { _id: false });
const SynthesizedEventSchema = new Schema({ event_key: { type: String, required: true, unique: true, trim: true, index: true }, synthesized_headline: { type: String, required: true, trim: true }, synthesized_summary: { type: String, required: true, trim: true }, advisorSummary: { type: String, trim: true }, ai_assessment_reason: { type: String, trim: true }, eventClassification: { type: String, trim: true }, country: { type: String, required: true, index: true }, source_articles: { type: [SourceArticleSchema], required: true }, highest_relevance_score: { type: Number, required: true, min: 0, max: 100 }, key_individuals: { type: [KeyIndividualSchema], default: [] }, relatedOpportunities: [{ type: Schema.Types.ObjectId, ref: 'Opportunity', index: true },], enrichmentSources: { type: [String], enum: ['rag_db', 'wikipedia', 'news_api'], default: [], }, event_date: { type: Date, default: Date.now, index: true }, emailed: { type: Boolean, default: false }, email_sent_at: { type: Date }, }, { timestamps: true, collection: 'synthesized_events', methods: { toRealtimePayload() { return { _id: this._id, synthesized_headline: this.synthesized_headline, synthesized_summary: this.synthesized_summary, country: this.country, highest_relevance_score: this.highest_relevance_score, key_individuals: (this.key_individuals || []).map((p) => p.name), opportunity_count: (this.relatedOpportunities || []).length, source_article_count: (this.source_articles || []).length, createdAt: this.createdAt, }; }, }, });
SynthesizedEventSchema.index({ synthesized_headline: 'text', synthesized_summary: 'text', });
SynthesizedEventSchema.index({ country: 1, createdAt: -1 });
export default models.SynthesizedEvent || model('SynthesizedEvent', SynthesizedEventSchema);

```

## ðŸ“„ src/WatchlistEntity.js
*Lines: 33, Size: 1.12 KB*

```javascript
// packages/models/src/WatchlistEntity.js (version 2.1.0)
import mongoose from 'mongoose'
import { ENTITY_TYPES, ENTITY_STATUSES } from './constants.js'

const { Schema, model, models } = mongoose

const WatchlistEntitySchema = new Schema(
  {
    name: { type: String, required: true, unique: true, trim: true, index: true },
    type: { type: String, enum: ENTITY_TYPES, required: true, index: true },
    status: {
      type: String,
      enum: ENTITY_STATUSES,
      default: 'candidate',
      required: true,
      index: true,
    },
    context: { type: String, trim: true, required: false },
    searchTerms: { type: [String], default: [], index: true },
    country: { type: String, trim: true, required: false, index: true },
    hitCount: { type: Number, default: 0, index: true },
    estimatedNetWorthUSD_MM: { type: Number, required: false },
    primaryCompany: { type: String, trim: true, required: false },
    notes: { type: String, trim: true, required: false },
  },
  {
    timestamps: true,
    collection: 'watchlist_entities',
  }
)

export default models.WatchlistEntity || model('WatchlistEntity', WatchlistEntitySchema)

```

## ðŸ“„ src/WatchlistSuggestion.js
*Lines: 29, Size: 1014 Bytes*

```javascript
// packages/models/src/WatchlistSuggestion.js (version 3.0.0 - With Search Terms)
import mongoose from 'mongoose'
import { WATCHLIST_SUGGESTION_STATUSES, ENTITY_TYPES } from './constants.js'
const { Schema, model, models } = mongoose;

const WatchlistSuggestionSchema = new Schema(
  {
    name: { type: String, required: true, unique: true, trim: true, index: true },
    type: { type: String, enum: ENTITY_TYPES, required: true, index: true },
    rationale: { type: String, trim: true, required: true },
    sourceEvent: { type: String, required: true },
    country: { type: String, trim: true, required: false },
    searchTerms: { type: [String], default: [] }, // NEW FIELD
    status: {
      type: String,
      enum: WATCHLIST_SUGGESTION_STATUSES,
      default: 'candidate',
      required: true,
      index: true,
    },
  },
  {
    timestamps: true,
    collection: 'watchlist_suggestions',
  }
)

export default models.WatchlistSuggestion || model('WatchlistSuggestion', WatchlistSuggestionSchema)

```

## ðŸ“„ src/constants.js
*Lines: 16, Size: 732 Bytes*

```javascript
// packages/models/src/constants.js (version 1.0)
export const ENTITY_TYPES = ['person', 'family', 'company']
export const ENTITY_STATUSES = ['active', 'inactive', 'candidate']

export const SOURCE_STATUSES = ['active', 'paused', 'under_review']
export const SOURCE_FREQUENCIES = ['high', 'low']
export const EXTRACTION_METHODS = ['custom', 'declarative', 'json-ld']

export const ARTICLE_STATUSES = ['scraped', 'assessed', 'enriched', 'failed_enrichment']

export const SUGGESTION_STATUSES = ['pending', 'approved', 'rejected']
export const WATCHLIST_SUGGESTION_STATUSES = ['candidate', 'approved', 'dismissed']

export const SUBSCRIBER_ROLES = ['user', 'admin']
export const SUBSCRIPTION_TIERS = ['free', 'premium', 'enterprise']

```

## ðŸ“„ src/index.js
*Lines: 29, Size: 778 Bytes*

```javascript
// packages/models/src/index.js (version 1.0)
import Article from './Article.js'
import Country from './Country.js'
import Opportunity from './Opportunity.js'
import PushSubscription from './PushSubscription.js'
import RunVerdict from './RunVerdict.js'
import Setting from './Setting.js'
import Source from './Source.js'
import SourceSuggestion from './SourceSuggestion.js'
import Subscriber from './Subscriber.js'
import SynthesizedEvent from './SynthesizedEvent.js'
import WatchlistEntity from './WatchlistEntity.js'
import WatchlistSuggestion from './WatchlistSuggestion.js'

export {
  Article,
  Country,
  Opportunity,
  PushSubscription,
  RunVerdict,
  Setting,
  Source,
  SourceSuggestion,
  Subscriber,
  SynthesizedEvent,
  WatchlistEntity,
  WatchlistSuggestion,
}

```
