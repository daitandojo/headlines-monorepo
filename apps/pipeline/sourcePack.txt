# 📁 PROJECT DIRECTORY STRUCTURE

Total: 221 files, 98 directories

```
headlines/
├── 📁 .github/
│   └── 📁 workflows/
│       ├── 📄 fly-deploy.yml
│       └── 📄 run-pipeline.yml
├── 📁 .tmp_backups/
│   ├── 📁 admin/
│   │   ├── 📁 app/
│   │   │   ├── 📁 articles/
│   │   │   │   ├── 📄 columns.jsx.bak
│   │   │   │   └── 📄 page.jsx.bak
│   │   │   ├── 📁 events/
│   │   │   │   ├── 📄 columns.jsx.bak
│   │   │   │   └── 📄 page.jsx.bak
│   │   │   └── 📁 opportunities/
│   │   │       ├── 📄 columns.jsx.bak
│   │   │       └── 📄 page.jsx.bak
│   │   ├── 📁 hooks/
│   │   │   └── 📄 use-admin-manager.js.bak
│   │   ├── 📁 src/
│   │   │   └── 📁 app/
│   │   │       ├── 📁 _components/
│   │   │       │   ├── 📄 main-nav.jsx.bak
│   │   │       │   └── 📄 multi-select.jsx.bak
│   │   │       ├── 📁 api/
│   │   │       │   ├── 📁 events/
│   │   │       │   │   └── 📄 route.js.bak
│   │   │       │   └── 📁 opportunities/
│   │   │       │       └── 📄 route.js.bak
│   │   │       ├── 📁 articles/
│   │   │       │   ├── 📄 columns.jsx.bak
│   │   │       │   └── 📄 page.jsx.bak
│   │   │       ├── 📁 events/
│   │   │       │   ├── 📄 columns.jsx.bak
│   │   │       │   └── 📄 page.jsx.bak
│   │   │       ├── 📁 opportunities/
│   │   │       │   ├── 📄 columns.jsx.bak
│   │   │       │   └── 📄 page.jsx.bak
│   │   │       ├── 📁 scraper-ide/
│   │   │       │   └── 📁 _components/
│   │   │       ├── 📁 sources/
│   │   │       │   └── 📄 page.jsx.bak
│   │   │       └── 📄 layout.js.bak
│   │   └── 📄 eslint.config.mjs.bak
│   ├── 📁 ai-services/
│   │   └── 📁 src/
│   │       ├── 📁 chains/
│   │       │   └── 📄 index.js.bak
│   │       ├── 📁 index.js/
│   │       ├── 📁 schemas/
│   │       │   ├── 📄 articleAssessmentSchema.js.bak
│   │       │   ├── 📄 index.js.bak
│   │       │   ├── 📄 opportunitySchema.js.bak
│   │       │   └── 📄 synthesisSchema.js.bak
│   │       ├── 📄 index.js.bak
│   │       └── 📄 wikipedia.js.bak
│   ├── 📁 client/
│   │   ├── 📁 components/
│   │   │   ├── 📁 events/
│   │   │   │   ├── 📄 EventCardDesktop.jsx.bak
│   │   │   │   └── 📄 EventCardMobile.jsx.bak
│   │   │   ├── 📄 ArticleList.jsx.bak
│   │   │   ├── 📄 DataView.jsx.bak
│   │   │   ├── 📄 EventList.jsx.bak
│   │   │   ├── 📄 OpportunityListWrapper.jsx.bak
│   │   │   ├── 📄 SynthesizedEventCard.jsx.bak
│   │   │   ├── 📄 UploadView.jsx.bak
│   │   │   └── 📄 ViewHeader.jsx.bak
│   │   ├── 📁 src/
│   │   │   ├── 📁 app/
│   │   │   │   └── 📁 main/
│   │   │   │       └── 📁 opportunities/
│   │   │   │           └── 📁 [opportunityId]/
│   │   │   │               └── 📄 page.js.bak
│   │   │   └── 📁 components/
│   │   │       ├── 📁 events/
│   │   │       │   ├── 📄 EventCardDesktop.jsx.bak
│   │   │       │   └── 📄 EventCardMobile.jsx.bak
│   │   │       ├── 📄 OpportunityCard.jsx.bak
│   │   │       ├── 📄 SynthesizedEventCard.jsx.bak
│   │   │       ├── 📄 UploadView.jsx.bak
│   │   │       └── 📄 ViewHeader.jsx.bak
│   │   └── 📄 eslint.config.mjs.bak
│   ├── 📁 data-access/
│   │   ├── 📁 actions/
│   │   │   ├── 📄 articles.js.bak
│   │   │   ├── 📄 events.js.bak
│   │   │   ├── 📄 opportunities.js.bak
│   │   │   ├── 📄 subscriber.js.bak
│   │   │   └── 📄 upload.js.bak
│   │   ├── 📁 src/
│   │   │   ├── 📁 actions/
│   │   │   │   ├── 📄 admin.js.bak
│   │   │   │   ├── 📄 adminArticles.js.bak
│   │   │   │   ├── 📄 adminEvents.js.bak
│   │   │   │   ├── 📄 adminOpportunities.js.bak
│   │   │   │   ├── 📄 adminSources.js.bak
│   │   │   │   ├── 📄 countries.js.bak
│   │   │   │   ├── 📄 export.js.bak
│   │   │   │   ├── 📄 opportunities.js.bak
│   │   │   │   ├── 📄 upload.js.bak
│   │   │   │   └── 📄 watchlist.js.bak
│   │   │   ├── 📄 index.js.bak
│   │   │   └── 📄 queryBuilder.js.bak
│   │   ├── 📄 index.js.bak
│   │   └── 📄 queryBuilder.js.bak
│   ├── 📁 models/
│   │   ├── 📁 src/
│   │   │   ├── 📄 Article.js.bak
│   │   │   ├── 📄 Opportunity.js.bak
│   │   │   ├── 📄 Source.js.bak
│   │   │   └── 📄 SynthesizedEvent.js.bak
│   │   ├── 📄 Opportunity.js.bak
│   │   ├── 📄 Subscriber.js.bak
│   │   └── 📄 SynthesizedEvent.js.bak
│   ├── 📁 pipeline/
│   │   ├── 📁 scripts/
│   │   │   ├── 📁 maintenance/
│   │   │   │   └── 📄 pipeline-correct-countries.js.bak
│   │   │   └── 📁 seed/
│   │   │       ├── 📁 lib/
│   │   │       │   ├── 📄 denmark-richlist-data-loader.js.bak
│   │   │       │   ├── 📄 enrich-thin-profile.js.bak
│   │   │       │   ├── 📄 event-chunker.js.bak
│   │   │       │   ├── 📄 pipeline-injector.js.bak
│   │   │       │   └── 📄 richlist-data-loader.js.bak
│   │   │       ├── 📄 ingest-denmark-richlist.js.bak
│   │   │       └── 📄 ingest-richlist.js.bak
│   │   ├── 📁 src/
│   │   │   ├── 📁 modules/
│   │   │   │   ├── 📁 dataStore/
│   │   │   │   │   └── 📄 index.js.bak
│   │   │   │   └── 📁 notifications/
│   │   │   │       └── 📄 emailDispatcher.js.bak
│   │   │   ├── 📁 pipeline/
│   │   │   │   ├── 📁 submodules/
│   │   │   │   │   ├── 📁 commit/
│   │   │   │   │   │   ├── 📄 1_judgeOutput.js.bak
│   │   │   │   │   │   └── 📄 2_saveResults.js.bak
│   │   │   │   │   └── 📄 processSingleArticle.js.bak
│   │   │   │   ├── 📄 2_scrapeAndFilter.js.bak
│   │   │   │   ├── 📄 3_assessAndEnrich.js.bak
│   │   │   │   ├── 📄 4_clusterAndSynthesize.js.bak
│   │   │   │   └── 📄 6_suggestNewWatchlistEntities.js.bak
│   │   │   ├── 📁 utils/
│   │   │   │   └── 📄 humanLogStream.js.bak
│   │   │   ├── 📄 app.js.bak
│   │   │   ├── 📄 auditLogger.js.bak
│   │   │   └── 📄 orchestrator.js.bak
│   │   └── 📄 run.sh.bak
│   ├── 📁 prompts/
│   │   └── 📁 src/
│   │       ├── 📁 examples/
│   │       │   ├── 📄 shotsInputHeadlines.js.bak
│   │       │   └── 📄 shotsOutputHeadlines.js.bak
│   │       ├── 📄 instructionArticle.js.bak
│   │       ├── 📄 instructionEmailIntro.js.bak
│   │       ├── 📄 instructionHeadlines.js.bak
│   │       ├── 📄 instructionOpportunities.js.bak
│   │       └── 📄 instructionSynthesize.js.bak
│   ├── 📁 scraper-logic/
│   │   ├── 📁 ai/
│   │   │   └── 📁 agents/
│   │   │       ├── 📄 batchArticleAgent.js.bak
│   │   │       ├── 📄 clusteringAgent.js.bak
│   │   │       ├── 📄 emailAgents.js.bak
│   │   │       ├── 📄 executiveSummaryAgent.js.bak
│   │   │       ├── 📄 headlineAgent.js.bak
│   │   │       ├── 📄 judgeAgent.js.bak
│   │   │       ├── 📄 selectorRepairAgent.js.bak
│   │   │       └── 📄 watchlistAgent.js.bak
│   │   └── 📁 src/
│   │       └── 📁 pipeline/
│   │           └── 📁 submodules/
│   │               └── 📄 opportunityUpserter.js.bak
│   ├── 📁 ui/
│   │   └── 📁 src/
│   │       ├── 📄 data-table.jsx.bak
│   │       ├── 📄 EditableCell.jsx.bak
│   │       ├── 📄 ExportButton.jsx.bak
│   │       ├── 📄 index.js.bak
│   │       └── 📄 page-header.jsx.bak
│   └── 📁 utils/
│       └── 📁 src/
│           └── 📄 server.js.bak
├── 📁 scripts/
│   ├── 📁 infrastructure/
│   │   └── 📄 setFlySecrets.sh
│   ├── 📁 maintenance/
│   │   ├── 📄 backfill-event-classifications.js
│   │   ├── 📄 backfill-suggestion-terms.js
│   │   ├── 📄 clean-e24-headlines.js
│   │   ├── 📄 delete-today.js
│   │   ├── 📄 pipeline-correct-countries.js
│   │   ├── 📄 recalculate-analytics.js
│   │   └── 📄 reset-source-analytics.js
│   ├── 📁 migrations/
│   │   ├── 📄 V1_Fix_Scraper_Selectors.js
│   │   ├── 📄 V2_Clean_Opportunity_Reasons.js
│   │   ├── 📄 V3_Fix_E24_Scraper.js
│   │   └── 📄 V4_Fix_E24_Scraper_Definitive.js
│   ├── 📁 push/
│   │   └── 📄 send-test-push.js
│   ├── 📁 results/
│   │   ├── 📄 list-events.js
│   │   └── 📄 send-last-events.js
│   ├── 📁 scripts/
│   │   └── 📄 list.js
│   ├── 📁 seed/
│   │   ├── 📁 data/
│   │   │   └── 📄 denmark.json
│   │   ├── 📁 lib/
│   │   │   ├── 📄 denmark-richlist-data-loader.js
│   │   │   ├── 📄 enrich-thin-profile.js
│   │   │   ├── 📄 event-chunker.js
│   │   │   ├── 📄 pipeline-injector.js
│   │   │   ├── 📄 richlist-data-loader.js
│   │   │   ├── 📄 script-init.js
│   │   │   ├── 📄 synthetic-article-builder.js
│   │   │   └── 📄 user-interact.js
│   │   ├── 📄 ingest-denmark-richlist.js
│   │   ├── 📄 ingest-richlist.js
│   │   ├── 📄 seed-admin-user.js
│   │   ├── 📄 seed-countries.js
│   │   ├── 📄 seed-settings.js
│   │   ├── 📄 seed-test-user.js
│   │   └── 📄 sync-test-user-subscriptions.js
│   ├── 📁 sources/
│   │   ├── 📄 analyze-sources.js
│   │   ├── 📄 browse.js
│   │   ├── 📄 check-danish-sources.js
│   │   ├── 📄 discover.js
│   │   ├── 📄 list-sources.js
│   │   ├── 📄 maintain.js
│   │   ├── 📄 scrape-many.js
│   │   ├── 📄 scrape-one.js
│   │   └── 📄 update.js
│   ├── 📁 subscribers/
│   │   ├── 📄 list.js
│   │   └── 📄 update.js
│   ├── 📁 test-pipeline/
│   │   └── 📄 test-payload.js
│   ├── 📁 tools/
│   │   ├── 📄 calculate-watchlist-hits.js
│   │   └── 📄 get-db-stats.js
│   ├── 📁 watchlist/
│   │   └── 📄 list.js
│   ├── 📄 mongo-backup.sh
│   ├── 📄 mongo-restore.sh
│   ├── 📄 purge-opportunities.js
│   └── 📄 reset-admin-password.js
├── 📁 src/
│   ├── 📁 config/
│   │   ├── 📄 dynamicConfig.js
│   │   ├── 📄 index.js
│   │   └── 📄 PEFirms.json
│   ├── 📁 modules/
│   │   ├── 📁 dataStore/
│   │   │   └── 📄 index.js
│   │   ├── 📁 email/
│   │   │   ├── 📁 components/
│   │   │   │   ├── 📁 supervisor/
│   │   │   │   │   ├── 📄 costSummary.js
│   │   │   │   │   ├── 📄 databaseTables.js
│   │   │   │   │   ├── 📄 enrichmentFunnel.js
│   │   │   │   │   ├── 📄 judgeVerdict.js
│   │   │   │   │   ├── 📄 scraperHealth.js
│   │   │   │   │   └── 📄 supervisorEmailBodyBuilder.js
│   │   │   │   ├── 📄 articleFormatter.js
│   │   │   │   ├── 📄 emailBodyBuilder.js
│   │   │   │   └── 📄 eventFormatter.js
│   │   │   ├── 📁 templates/
│   │   │   │   └── 📄 supervisorWrapper.js
│   │   │   ├── 📄 constants.js
│   │   │   ├── 📄 emailDispatcher.js
│   │   │   ├── 📄 index.js
│   │   │   └── 📄 mailer.js
│   │   ├── 📁 notifications/
│   │   │   ├── 📄 emailDispatcher.js
│   │   │   ├── 📄 index.js
│   │   │   └── 📄 pushService.js
│   │   ├── 📁 realtime/
│   │   │   └── 📄 index.js
│   │   └── 📁 statistics/
│   ├── 📁 pipeline/
│   │   ├── 📁 submodules/
│   │   │   ├── 📁 commit/
│   │   │   │   ├── 📄 1_judgeOutput.js
│   │   │   │   ├── 📄 2_saveResults.js
│   │   │   │   ├── 📄 3_triggerNotifications.js
│   │   │   │   └── 📄 4_updateSourceAnalytics.js
│   │   │   ├── 📄 opportunityUpserter.js
│   │   │   ├── 📄 processSingleArticle.js
│   │   │   └── 📄 triggerSelectorRepair.js
│   │   ├── 📄 1_preflight.js
│   │   ├── 📄 2_scrapeAndFilter.js
│   │   ├── 📄 3_assessAndEnrich.js
│   │   ├── 📄 4_clusterAndSynthesize.js
│   │   ├── 📄 5_commitAndNotify.js
│   │   ├── 📄 6_suggestNewWatchlistEntities.js
│   │   └── 📄 7_selfHealAndOptimize.js
│   ├── 📁 utils/
│   │   ├── 📄 auditLogger.js
│   │   ├── 📄 errorStream.js
│   │   ├── 📄 housekeeping.js
│   │   ├── 📄 humanLogStream.js
│   │   ├── 📄 pipelineLogger.js
│   │   ├── 📄 rag.js
│   │   ├── 📄 redisClient.js
│   │   └── 📄 reportSections.js
│   ├── 📄 app.js
│   └── 📄 orchestrator.js
├── 📄 .gitignore
├── 📄 .npmrc
├── 📄 headlines-monorepo@1.0.0
├── 📄 jest.config.js
├── 📄 norway.mjs
├── 📄 npm
├── 📄 package.json
└── 📄 run.sh
```

# 📋 PROJECT METADATA

**Generated**: 2025-09-17T18:58:29.047Z
**Repository Path**: /home/mark/Repos/projects/headlines/apps/pipeline
**Total Files**: 221
**Package**: headlines-monorepo@1.2.2




---


## 📄 .github/workflows/fly-deploy.yml
*Lines: 28, Size: 845 Bytes*

```yaml
# See https://fly.io/docs/app-guides/continuous-deployment-with-github-actions/

name: Fly Deploy
on:
  push:
    branches:
      - main
jobs:
  deploy:
    name: Deploy app
    runs-on: ubuntu-latest
    concurrency: deploy-group
    steps:
      - uses: actions/checkout@v4
      
      # Step 1: Install flyctl using the official installer.
      - name: Install flyctl
        run: |
          curl -L https://fly.io/install.sh | sh
          # Step 2: Add flyctl to the PATH for subsequent steps.
          # This is the officially recommended and robust method.
          echo "/home/runner/.fly/bin" >> $GITHUB_PATH

      - name: Deploy to Fly.io
        # Now 'flyctl' can be called directly because its location is in the PATH.
        run: flyctl deploy --remote-only
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
```

## 📄 .github/workflows/run-pipeline.yml
*Lines: 39, Size: 1.34 KB*

```yaml
name: Run Pipeline on Schedule

on:
  workflow_dispatch: # Allows you to run this workflow manually from the Actions tab
  schedule:
    # IMPORTANT: GitHub schedules run on UTC time.
    # 10:00 Copenhagen (CEST, UTC+2) is 08:00 UTC
    # 16:30 Copenhagen (CEST, UTC+2) is 14:30 UTC
    - cron: '25 11 * * *'
    - cron: '25 12 * * *'
    - cron: '25 13 * * *'
    - cron: '25 16 * * *'

jobs:
  run-on-fly:
    name: Start a Fly Machine to Run the Pipeline
    runs-on: ubuntu-latest

    steps:
      # Step 1: Check out your repository's code
      - uses: actions/checkout@v4
      
      # Step 2: Install flyctl and add it to the PATH.
      - name: Install flyctl
        run: |
          curl -L https://fly.io/install.sh | sh
          echo "/home/runner/.fly/bin" >> $GITHUB_PATH
        
      # Step 3: Run the machine command.
      - name: Start a temporary machine and wait for completion
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          # 'flyctl' can now be called directly.
          # MODIFIED: Replaced --autodestroy with --rm, the original and more compatible flag.
          # This ensures the machine is automatically destroyed server-side upon completion.
          flyctl machine run . --region lhr --memory 2048 --rm
          
          echo "The machine has completed its run and has been destroyed."
```

## 📄 .gitignore
*Lines: 31, Size: 360 Bytes*

```
# Monorepo-level ignores
node_modules
future
logs
script.sh
.DS_Store
norway.json
norway.backup
debug_html
papers.json
workbox-*
*.pem
*.log*
.env*
!/.env.template

# Apps
apps/admin/.next
apps/admin/out
apps/admin/build
apps/admin/.vercel

# Pipeline
apps/pipeline/debug_html
apps/pipeline/logs

# Packages
packages/**/node_modules
packages/**/*.tsbuildinfo


```

## 📄 .npmrc
*Lines: 2, Size: 22 Bytes*

```
legacy-peer-deps=true

```

## 📄 .tmp_backups/admin/app/articles/columns.jsx.bak
*Lines: 74, Size: 3.5 KB*

```
// apps/admin/src/app/articles/columns.jsx (version 1.1.0)
'use client'

import React, { useState, useEffect, useRef } from 'react';
import { Button, Badge, Input } from '@headlines/ui';
import { ArrowUpDown, Trash2, ExternalLink, Edit } from 'lucide-react';
import { format } from 'date-fns';

const EditableCell = ({ initialValue, onSave }) => {
    const [isEditing, setIsEditing] = useState(false);
    const [value, setValue] = useState(initialValue);
    const inputRef = useRef(null);

    useEffect(() => {
        if (isEditing) inputRef.current?.focus();
    }, [isEditing]);

    const handleSave = () => {
        if (value.trim() && value.trim() !== initialValue) {
            onSave(value.trim());
        }
        setIsEditing(false);
    };

    if (isEditing) {
        return <Input ref={inputRef} value={value} onChange={(e) => setValue(e.target.value)} onBlur={handleSave} onKeyDown={(e) => e.key === 'Enter' && handleSave()} className="h-8"/>;
    }

    return <div className="group flex items-center cursor-pointer" onClick={() => setIsEditing(true)}><span className="truncate">{initialValue}</span><Edit className="h-3 w-3 ml-2 text-muted-foreground opacity-0 group-hover:opacity-100"/></div>;
}


export const columns = (onUpdate, onDelete) => [
    {
        accessorKey: 'relevance_headline',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>HL Score <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => <Badge variant="outline">{row.original.relevance_headline}</Badge>
    },
    {
        accessorKey: 'relevance_article',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Article Score <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => <Badge variant={row.original.relevance_article > 50 ? 'default' : 'secondary'}>{row.original.relevance_article || 'N/A'}</Badge>
    },
    {
        accessorKey: 'headline',
        header: 'Headline',
        cell: ({ row }) => <EditableCell initialValue={row.original.headline} onSave={(newValue) => onUpdate(row.original, { headline: newValue })} />
    },
    {
        accessorKey: 'newspaper',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Source <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
    },
    {
        accessorKey: 'country',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Country <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
    },
    {
        accessorKey: 'createdAt',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Discovered <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => format(new Date(row.original.createdAt), 'dd MMM yyyy, HH:mm'),
    },
    {
        id: 'actions',
        cell: ({ row }) => (
            <div className="flex items-center justify-end gap-2">
                <a href={row.original.link} target="_blank" rel="noopener noreferrer">
                    <Button variant="ghost" size="icon" className="h-8 w-8"><ExternalLink className="h-4 w-4" /></Button>
                </a>
                <Button variant="ghost" size="icon" className="h-8 w-8 text-muted-foreground" onClick={() => onDelete(row.original._id)}><Trash2 className="h-4 w-4" /></Button>
            </div>
        ),
    }
];

```

## 📄 .tmp_backups/admin/app/articles/page.jsx.bak
*Lines: 72, Size: 3.15 KB*

```
// apps/admin/src/app/articles/page.jsx (version 1.1.0)
'use client'

import { PageHeader, DataTable, ConfirmationDialog } from '@headlines/ui';
import { columns } from './columns';
import { useAdminManager } from '@/hooks/use-admin-manager';
import { deleteAdminArticle, updateAdminArticle } from '@headlines/data-access';
import { toast } from 'sonner';
import { useState, useCallback } from 'react';

export default function ArticlesPage() {
    const { data, total, isLoading, searchTerm, setSearchTerm, sort, setSort, refetch, handleUpdate, handleRemove } = useAdminManager('/api/articles', 'createdAt_desc');
    const [confirmState, setConfirmState] = useState({ isOpen: false, articleId: null });

    const handleOptimisticUpdate = useCallback(async (article, updateData) => {
        handleUpdate(article._id, updateData); // Optimistic update
        const result = await updateAdminArticle(article._id, updateData);
        if (!result.success) {
            toast.error(`Update failed: ${result.error}`);
            refetch(); // Revert
        }
    }, [handleUpdate, refetch]);

    const handleDeleteClick = (articleId) => {
        setConfirmState({ isOpen: true, articleId });
    };

    const confirmDelete = async () => {
        const { articleId } = confirmState;
        handleRemove(articleId); // Optimistic remove
        setConfirmState({ isOpen: false, articleId: null });
        const result = await deleteAdminArticle(articleId);
        if (!result.success) {
            toast.error(`Deletion failed: ${result.error}`);
            refetch(); // Revert
        } else {
            toast.success('Article deleted.');
        }
    };
    
    return (
        <div className="flex flex-col h-full">
            <PageHeader title="Article Management" description={`Review and manage all ${total.toLocaleString()} raw articles scraped by the pipeline.`} />
            <div className="mt-8 flex-grow min-h-0">
                <DataTable
                    columns={columns(handleOptimisticUpdate, handleDeleteClick)}
                    data={data}
                    isLoading={isLoading}
                    filterColumn="headline"
                    filterPlaceholder="Filter by headline, source..."
                    // Pass sort state and setter to DataTable
                    initialSort={[{id: sort.split('_')[0], desc: sort.endsWith('desc')}]}
                    onSortingChange={(updater) => {
                        const newSort = updater([{id: sort.split('_')[0], desc: sort.endsWith('desc')}]);
                        if (newSort && newSort[0]) {
                             setSort(`${newSort[0].id}_${newSort[0].desc ? 'desc' : 'asc'}`);
                        }
                    }}
                />
            </div>
            <ConfirmationDialog
                open={confirmState.isOpen}
                onOpenChange={(isOpen) => setConfirmState({ ...confirmState, isOpen })}
                onConfirm={confirmDelete}
                title="Delete Article"
                description="Are you sure you want to permanently delete this article? This action cannot be undone."
                confirmText="Delete"
             />
        </div>
    );
}

```

## 📄 .tmp_backups/admin/app/events/columns.jsx.bak
*Lines: 156, Size: 8.53 KB*

```
// apps/admin/src/app/events/columns.jsx (version 1.4.1)
'use client'

import React, { useState, useEffect, useRef } from 'react';
import { Button, Badge, Input, Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '@headlines/ui';
import { ArrowUpDown, Trash2, Loader2, Newspaper, Target, ExternalLink, Edit, ChevronsUpDown, User, Building } from 'lucide-react';
import { format } from 'date-fns';

const EditableCell = ({ initialValue, onSave }) => {
    const [isEditing, setIsEditing] = useState(false);
    const [value, setValue] = useState(initialValue);
    const inputRef = useRef(null);

    useEffect(() => {
        if (isEditing) inputRef.current?.focus();
    }, [isEditing]);

    const handleSave = () => {
        if (value.trim() && value.trim() !== initialValue) {
            onSave(value.trim());
        }
        setIsEditing(false);
    };

    if (isEditing) {
        return <Input ref={inputRef} value={value} onChange={(e) => setValue(e.target.value)} onBlur={handleSave} onKeyDown={(e) => e.key === 'Enter' && handleSave()} className="h-8 w-full bg-secondary"/>;
    }

    return <div className="group flex items-center cursor-pointer font-medium text-sm" onClick={() => setIsEditing(true)}><span className="line-clamp-2 whitespace-normal pr-2">{initialValue}</span><Edit className="h-3 w-3 ml-auto text-muted-foreground opacity-0 group-hover:opacity-100 flex-shrink-0"/></div>;
}

const ExpandedRowContent = ({ eventId }) => {
    const [details, setDetails] = useState(null);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        fetch(`/api/events/${eventId}`)
            .then(res => res.json())
            .then(data => {
                setDetails(data);
                setIsLoading(false);
            })
            .catch(() => setIsLoading(false));
    }, [eventId]);

    if (isLoading) return <div className="p-4 flex items-center gap-2 text-muted-foreground"><Loader2 className="h-4 w-4 animate-spin" /> Loading details...</div>;
    if (!details) return <div className="p-4 text-destructive">Failed to load details.</div>;

    return (
        <div className="p-6 bg-black/20 grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div className="lg:col-span-2 space-y-4">
                <div>
                    <h4 className="font-semibold text-sm text-muted-foreground mb-1">Synthesized Summary</h4>
                    <p className="text-sm">{details.synthesized_summary}</p>
                </div>
                 <div>
                    <h4 className="font-semibold text-sm text-muted-foreground mb-1">AI Assessment</h4>
                    <p className="text-sm italic text-muted-foreground">"{details.ai_assessment_reason}"</p>
                </div>
                <div>
                    <h4 className="font-semibold text-sm mb-2">Key Individuals ({details.key_individuals?.length || 0})</h4>
                    <div className="space-y-2 max-h-40 overflow-y-auto">
                        {(details.key_individuals || []).map((p, i) => (
                            <div key={i} className="text-xs p-2 rounded bg-secondary/50">
                                <p className="font-medium flex items-center gap-2"><User className="h-3 w-3"/>{p.name}</p>
                                <p className="pl-5 text-muted-foreground flex items-center gap-2"><Building className="h-3 w-3"/>{p.role_in_event} at {p.company}</p>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
            <div className="space-y-4">
                <div>
                    <h4 className="font-semibold text-sm mb-2">Source Articles ({details.source_articles_full?.length || 0})</h4>
                    <div className="space-y-2 max-h-40 overflow-y-auto">
                        {(details.source_articles_full || []).map(article => (
                            <div key={article._id} className="text-xs p-2 rounded bg-secondary/50 flex justify-between items-center">
                                <span className="truncate pr-4">{article.newspaper}: {article.headline}</span>
                                <a href={article.link} target="_blank" rel="noopener noreferrer"><ExternalLink className="h-3 w-3" /></a>
                            </div>
                        ))}
                    </div>
                </div>
                <div>
                    <h4 className="font-semibold text-sm mb-2">Related Opportunities ({details.relatedOpportunities?.length || 0})</h4>
                    <div className="space-y-2 max-h-40 overflow-y-auto">
                         {(details.relatedOpportunities || []).map(opp => (
                            <div key={opp._id} className="text-xs p-2 rounded bg-secondary/50">
                                {opp.reachOutTo} (~${opp.likelyMMDollarWealth}M)
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};

export const EventListItem = ({ event, onUpdate, onDelete }) => {
    const score = event.highest_relevance_score;
    const scoreColorClass = score >= 80 ? 'bg-green-500/20 text-green-300' : score >= 60 ? 'bg-yellow-500/20 text-yellow-300' : 'bg-muted';
    const articleCount = event.source_articles?.length || 0;
    const opportunityCount = event.relatedOpportunities?.length || 0;
    
    return (
        <AccordionItem value={event._id} className="border-b border-border">
            <div className="flex items-center p-2">
                <AccordionTrigger className="w-10 h-10 flex-shrink-0 flex items-center justify-center p-2 [&[data-state=open]>svg]:rotate-180">
                    <ChevronsUpDown className="h-4 w-4 transition-transform duration-200" />
                </AccordionTrigger>
                <div className="w-20 flex-shrink-0 text-center">
                    <Badge className={scoreColorClass}>{score}</Badge>
                </div>
                <div className="flex-grow min-w-0 pr-4">
                     <EditableCell initialValue={event.synthesized_headline} onSave={(newValue) => onUpdate(event, { synthesized_headline: newValue })} />
                </div>
                <div className="w-36 flex-shrink-0 text-sm">{event.country}</div>
                <div className="w-44 flex-shrink-0 text-sm">{format(new Date(event.createdAt), 'dd MMM yyyy')}</div>
                <div className="w-32 flex-shrink-0 flex items-center gap-4 text-sm text-muted-foreground">
                    {articleCount > 0 && (
                        <span className="flex items-center gap-1.5" title="Source Articles"><Newspaper className="h-4 w-4" /> {articleCount}</span>
                    )}
                    {opportunityCount > 0 && (
                        <span className="flex items-center gap-1.5" title="Related Opportunities"><Target className="h-4 w-4" /> {opportunityCount}</span>
                    )}
                </div>
                <div className="w-16 flex-shrink-0 text-right">
                    <Button variant="ghost" size="icon" className="h-8 w-8 text-muted-foreground" onClick={() => onDelete(event._id)}><Trash2 className="h-4 w-4" /></Button>
                </div>
            </div>
            <AccordionContent>
                <ExpandedRowContent eventId={event._id} />
            </AccordionContent>
        </AccordionItem>
    )
};

const SortableHeader = ({ children, value, sort, setSort }) => {
    const isSorted = sort.startsWith(value);
    const isDesc = isSorted && sort.endsWith('_desc');
    const newSort = isSorted ? (isDesc ? `${value}_asc` : `${value}_desc`) : `${value}_desc`;
    return <Button variant="ghost" size="sm" onClick={() => setSort(newSort)}>{children} {isSorted && <ArrowUpDown className="ml-2 h-4 w-4" />}</Button>
};

export const ListHeader = ({ sort, setSort }) => (
    <div className="flex items-center p-2 border-b font-medium text-muted-foreground text-sm sticky top-0 bg-background z-10">
        <div className="w-10 flex-shrink-0"></div>
        <div className="w-20 flex-shrink-0 text-center"><SortableHeader value="highest_relevance_score" sort={sort} setSort={setSort}>Score</SortableHeader></div>
        <div className="flex-grow min-w-0 pr-4">Headline</div>
        <div className="w-36 flex-shrink-0"><SortableHeader value="country" sort={sort} setSort={setSort}>Country</SortableHeader></div>
        <div className="w-44 flex-shrink-0"><SortableHeader value="createdAt" sort={sort} setSort={setSort}>Discovered</SortableHeader></div>
        <div className="w-32 flex-shrink-0">Relations</div>
        <div className="w-16 flex-shrink-0 text-right">Actions</div>
    </div>
);

```

## 📄 .tmp_backups/admin/app/events/page.jsx.bak
*Lines: 79, Size: 3.64 KB*

```
// apps/admin/src/app/events/page.jsx (version 1.2.1)
'use client'

import { PageHeader, ConfirmationDialog, Input, Button, Accordion, LoadingOverlay } from '@headlines/ui';
import { EventListItem, ListHeader } from './columns';
import { useAdminManager } from '@/hooks/use-admin-manager';
import { deleteAdminEvent, updateAdminEvent } from '@headlines/data-access';
import { toast } from 'sonner';
import { useState, useCallback } from 'react';
import { Search } from 'lucide-react';

export default function EventsPage() {
    const { data, total, isLoading, searchTerm, setSearchTerm, sort, setSort, refetch, handleUpdate, handleRemove } = useAdminManager('/api/events', 'createdAt_desc');
    const [confirmState, setConfirmState] = useState({ isOpen: false, eventId: null });

    const handleOptimisticUpdate = useCallback(async (event, updateData) => {
        handleUpdate(event._id, updateData); // Optimistic update
        const result = await updateAdminEvent(event._id, updateData);
        if (!result.success) {
            toast.error(`Update failed: ${result.error}`);
            refetch(); // Revert
        }
    }, [handleUpdate, refetch]);

    const handleDeleteClick = (eventId) => {
        setConfirmState({ isOpen: true, eventId });
    };

    const confirmDelete = async () => {
        const { eventId } = confirmState;
        handleRemove(eventId); // Optimistic remove
        setConfirmState({ isOpen: false, eventId: null });
        const result = await deleteAdminEvent(eventId);
        if (result.success) {
            toast.success('Event and its relations deleted.');
        } else {
            toast.error(`Deletion failed: ${result.error}`);
            refetch(); // Revert
        }
    };
    
    return (
        <div className="flex flex-col h-full">
            <PageHeader title="Event Management" description={`Review, audit, and manage all ${total.toLocaleString()} synthesized events.`} />
            <div className="mt-8 flex-grow min-h-0 flex flex-col">
                <div className="flex items-center py-4 justify-between">
                     <div className="relative flex-grow max-w-sm">
                        <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-slate-500" />
                        <Input
                            placeholder="Filter by headline, country..."
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                            className="h-10 pl-10"
                        />
                    </div>
                    {/* Pagination can go here in the future */}
                </div>
                <div className="relative rounded-md border flex-grow overflow-y-auto">
                    <LoadingOverlay isLoading={isLoading} />
                    <ListHeader sort={sort} setSort={setSort} />
                    <Accordion type="single" collapsible>
                        {data.map(event => (
                            <EventListItem key={event._id} event={event} onUpdate={handleOptimisticUpdate} onDelete={handleDeleteClick} />
                        ))}
                    </Accordion>
                </div>
            </div>
            <ConfirmationDialog
                open={confirmState.isOpen}
                onOpenChange={(isOpen) => setConfirmState({ ...confirmState, isOpen })}
                onConfirm={confirmDelete}
                title="Delete Event"
                description="Are you sure you want to permanently delete this event and its links to articles/opportunities? This is a significant action."
                confirmText="Delete Event"
             />
        </div>
    );
}

```

## 📄 .tmp_backups/admin/app/opportunities/columns.jsx.bak
*Lines: 79, Size: 4.03 KB*

```
// apps/admin/src/app/opportunities/columns.jsx (version 1.4.0)
'use client'

import React, { useState, useEffect, useRef } from 'react';
import { Button, Input } from '@headlines/ui';
import { ArrowUpDown, Trash2, Edit } from 'lucide-react';
import { format } from 'date-fns';

const EditableCell = ({ initialValue, onSave, placeholder = '', type = 'text' }) => {
    const [isEditing, setIsEditing] = useState(false);
    const [value, setValue] = useState(initialValue || '');
    const inputRef = useRef(null);

    useEffect(() => { if (isEditing) inputRef.current?.focus() }, [isEditing]);

    const handleSave = () => {
        const finalValue = type === 'number' ? (value ? Number(value) : null) : value.trim();
        if (finalValue !== (initialValue || (type === 'number' ? null : ''))) {
            onSave(finalValue);
        }
        setIsEditing(false);
    };

    if (isEditing) {
        return <Input type={type} ref={inputRef} value={value} onChange={(e) => setValue(e.target.value)} onBlur={handleSave} onKeyDown={(e) => { if (e.key === 'Enter') handleSave() }} className="h-8"/>;
    }
    
    let displayValue = initialValue;
    if (type === 'number' && initialValue) displayValue = `$${initialValue}M`;
    if (!initialValue) displayValue = <span className="text-muted-foreground italic">{placeholder}</span>;

    return <div className="group flex items-center cursor-pointer" onClick={() => setIsEditing(true)}><span className="truncate">{displayValue}</span><Edit className="h-3 w-3 ml-2 text-muted-foreground opacity-0 group-hover:opacity-100"/></div>;
}

export const columns = (onUpdate, onDelete) => [
    {
        accessorKey: 'basedIn',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Country <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        size: 150,
    },
    {
        accessorKey: 'reachOutTo',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Contact <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => <EditableCell initialValue={row.original.reachOutTo} onSave={(newValue) => onUpdate(row.original, { reachOutTo: newValue })} />,
        size: 250,
    },
    {
        accessorKey: 'likelyMMDollarWealth',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Wealth ($M) <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => <EditableCell initialValue={row.original.likelyMMDollarWealth} onSave={(newValue) => onUpdate(row.original, { likelyMMDollarWealth: newValue })} type="number" />,
        size: 150,
    },
    {
        accessorKey: 'contactDetails.email',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Email <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => <EditableCell initialValue={row.original.contactDetails?.email} placeholder="Add email..." onSave={(newValue) => onUpdate(row.original, { 'contactDetails.email': newValue })} />,
        size: 250,
    },
    {
        accessorKey: 'whyContact',
        header: 'Reason',
        cell: ({ row }) => {
            const reasons = Array.isArray(row.original.whyContact) ? row.original.whyContact : [row.original.whyContact];
            return <p className="text-sm text-muted-foreground line-clamp-2">{reasons.join(' ')}</p>
        }
    },
    {
        accessorKey: 'createdAt',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Created <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => format(new Date(row.original.createdAt), 'dd MMM yyyy'),
        size: 150,
    },
    {
        id: 'actions',
        cell: ({ row }) => <Button variant="ghost" size="icon" className="h-8 w-8 text-muted-foreground" onClick={() => onDelete(row.original._id)}><Trash2 className="h-4 w-4" /></Button>,
        size: 60,
    }
];

```

## 📄 .tmp_backups/admin/app/opportunities/page.jsx.bak
*Lines: 71, Size: 3.1 KB*

```
// apps/admin/src/app/opportunities/page.jsx (version 1.2.0)
'use client'

import { PageHeader, DataTable, ConfirmationDialog } from '@headlines/ui';
import { columns } from './columns';
import { useAdminManager } from '@/hooks/use-admin-manager';
import { deleteAdminOpportunity, updateAdminOpportunity } from '@headlines/data-access';
import { toast } from 'sonner';
import { useState, useCallback } from 'react';

export default function OpportunitiesPage() {
    const { data, total, isLoading, searchTerm, setSearchTerm, sort, setSort, refetch, handleUpdate, handleRemove } = useAdminManager('/api/opportunities', 'basedIn_asc');
    const [confirmState, setConfirmState] = useState({ isOpen: false, oppId: null });

    const handleOptimisticUpdate = useCallback(async (opp, updateData) => {
        handleUpdate(opp._id, updateData); // Optimistic update
        const result = await updateAdminOpportunity(opp._id, updateData);
        if (!result.success) {
            toast.error(`Update failed: ${result.error}`);
            refetch(); // Revert
        }
    }, [handleUpdate, refetch]);

    const handleDeleteClick = (oppId) => {
        setConfirmState({ isOpen: true, oppId });
    };

    const confirmDelete = async () => {
        const { oppId } = confirmState;
        handleRemove(oppId); // Optimistic remove
        setConfirmState({ isOpen: false, oppId: null });
        const result = await deleteAdminOpportunity(oppId);
        if (!result.success) {
            toast.error(`Deletion failed: ${result.error}`);
            refetch(); // Revert
        } else {
            toast.success('Opportunity deleted.');
        }
    };
    
    return (
        <div className="flex flex-col h-full">
            <PageHeader title="Opportunity Management" description={`Review and manage all ${total.toLocaleString()} actionable opportunities generated by the pipeline.`} />
            <div className="mt-8 flex-grow min-h-0">
                <DataTable
                    columns={columns(handleOptimisticUpdate, handleDeleteClick)}
                    data={data}
                    isLoading={isLoading}
                    filterColumn="reachOutTo"
                    filterPlaceholder="Filter by name, country..."
                    initialSort={[{id: sort.split('_')[0], desc: sort.endsWith('desc')}]}
                    onSortingChange={(updater) => {
                        const newSort = updater([{id: sort.split('_')[0], desc: sort.endsWith('desc')}]);
                        if (newSort && newSort[0]) {
                             setSort(`${newSort[0].id}_${newSort[0].desc ? 'desc' : 'asc'}`);
                        }
                    }}
                />
            </div>
             <ConfirmationDialog
                open={confirmState.isOpen}
                onOpenChange={(isOpen) => setConfirmState({ ...confirmState, isOpen })}
                onConfirm={confirmDelete}
                title="Delete Opportunity"
                description="Are you sure you want to permanently delete this opportunity? This action cannot be undone."
                confirmText="Delete"
             />
        </div>
    );
}

```

## 📄 .tmp_backups/admin/eslint.config.mjs.bak
*Lines: 18, Size: 575 Bytes*

```
// apps/admin/eslint.config.mjs (version 3.0.0)
import eslintConfigNext from 'eslint-config-next'

// This is the modern, correct way to configure ESLint with Next.js
// in a flat config file (`eslint.config.mjs`). This simpler array format
// correctly informs the Next.js build system about the project structure,
// resolving the "Module not found" error for the old '_app' file.
export default [
  eslintConfigNext,
  // You can add your custom rules or overrides here if needed
  // For example:
  // {
  //   rules: {
  //     'no-console': 'warn',
  //   },
  // },
]

```

## 📄 .tmp_backups/admin/hooks/use-admin-manager.js.bak
*Lines: 95, Size: 3.03 KB*

```
// apps/admin/src/hooks/use-admin-manager.js (version 1.1.0)
'use client'

import { useState, useEffect, useCallback } from 'react';
import { useDebounce } from '@headlines/utils';
import { toast } from 'sonner';

// This hook is designed for tables with server-side pagination, sorting, and filtering.
export function useAdminManager(apiPath, initialSort = 'date_desc') {
    const [data, setData] = useState([]);
    const [total, setTotal] = useState(0);
    const [page, setPage] = useState(1);
    const [sort, setSort] = useState(initialSort);
    const [searchTerm, setSearchTerm] = useState('');
    const [filters, setFilters] = useState({}); // DEFINITIVE ADDITION
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);
    
    const debouncedSearchTerm = useDebounce(searchTerm, 500);

    const fetchData = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        try {
            const params = new URLSearchParams({ page, sort, q: debouncedSearchTerm });
            // DEFINITIVE ADDITION: Append filters to the query
            for (const [key, value] of Object.entries(filters)) {
                if(value) params.append(key, value);
            }
            const res = await fetch(`${apiPath}?${params.toString()}`);
            if (!res.ok) {
                const errorData = await res.json();
                throw new Error(errorData.error || 'Failed to fetch data.');
            }
            const result = await res.json();
            setData(result.data);
            setTotal(result.total);
        } catch (e) {
            setError(e.message);
            toast.error(`Failed to load data: ${e.message}`);
        } finally {
            setIsLoading(false);
        }
    }, [apiPath, page, sort, debouncedSearchTerm, filters]); // DEFINITIVE ADDITION: Add filters to dependency array

    useEffect(() => {
        fetchData();
    }, [fetchData]);

    const setSortAndResetPage = (newSort) => {
        setSort(newSort);
        setPage(1);
    }
    
    const setSearchTermAndResetPage = (newSearch) => {
        setSearchTerm(newSearch);
        setPage(1);
    }
    
    const setFilterAndResetPage = (key, value) => {
        setFilters(prev => ({...prev, [key]: value}));
        setPage(1);
    }

    const handleUpdate = useCallback((itemId, updatedData) => {
        setData(currentData =>
            currentData.map(item =>
                item._id === itemId ? { ...item, ...updatedData } : item
            )
        );
    }, []);

    const handleRemove = useCallback((itemId) => {
        setData(currentData => currentData.filter(item => item._id !== itemId));
    }, []);

    return {
        data,
        total,
        page,
        setPage,
        sort,
        setSort: setSortAndResetPage,
        searchTerm,
        setSearchTerm: setSearchTermAndResetPage,
        filters,
        setFilter: setFilterAndResetPage, // DEFINITIVE ADDITION
        isLoading,
        error,
        refetch: fetchData,
        handleUpdate,
        handleRemove,
    };
}

```

## 📄 .tmp_backups/admin/src/app/_components/main-nav.jsx.bak
*Lines: 90, Size: 3.18 KB*

```
// apps/admin/src/app/_components/main-nav.jsx (version 1.8.1)
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import React from 'react'
import { BotMessageSquare, Newspaper, Users, Rss, Gauge, Settings, Globe, Zap, Target, FileText, Code } from 'lucide-react'
import { cn } from '@headlines/utils'
import { Separator } from '@headlines/ui'
import { ThemeToggle } from './theme-toggle'

const navSections = [
    {
        items: [
          { name: 'Dashboard', href: '/dashboard', icon: Gauge },
          { name: 'Sources', href: '/', icon: Newspaper },
          { name: 'Users', href: '/users', icon: Users },
          { name: 'Watchlist', href: '/watchlist', icon: Rss },
        ]
    },
    {
        items: [
          { name: 'Events', href: '/events', icon: Zap },
          { name: 'Articles', href: '/articles', icon: FileText },
          { name: 'Opportunities', href: '/opportunities', icon: Target },
        ]
    },
    {
        items: [
          { name: 'Countries', href: '/countries', icon: Globe },
          { name: 'Scraper IDE', href: '/scraper-ide', icon: Code },
          { name: 'Settings', href: '/settings', icon: Settings },
        ]
    }
];

export default function MainNav() {
  const pathname = usePathname()

  const isCurrent = (href) => {
    if (href === '/') return pathname === '/' || pathname.startsWith('/sources');
    return pathname.startsWith(href)
  }

  return (
    <nav className="w-[280px] bg-card border-r flex flex-col flex-shrink-0">
      {/* Header (fixed) */}
      <div className="p-4 border-b h-[100px] flex items-center gap-3">
        <BotMessageSquare className="w-8 h-8 gemini-text flex-shrink-0" />
        <div>
          <h1 className="text-xl font-bold tracking-tighter">Headlines Admin</h1>
          <p className="text-sm text-muted-foreground">Management Console</p>
        </div>
      </div>
      
      {/* Scrollable Nav Links (takes up all available space) */}
      <div className="flex-1 overflow-y-auto p-4">
        {navSections.map((section, index) => (
            <React.Fragment key={index}>
                <ul className="space-y-2">
                    {section.items.map((item) => (
                        <li key={item.name}>
                        <Link
                            href={item.href}
                            className={cn(
                            'flex items-center gap-3 px-4 py-2.5 text-base font-medium rounded-lg transition-colors',
                            isCurrent(item.href)
                                ? 'bg-primary/10 text-primary'
                                : 'text-muted-foreground hover:bg-accent hover:text-accent-foreground'
                            )}
                        >
                            <item.icon className="w-5 h-5" />
                            {item.name}
                        </Link>
                        </li>
                    ))}
                </ul>
                {index < navSections.length - 1 && <Separator className="my-4" />}
            </React.Fragment>
        ))}
      </div>

      {/* Footer (fixed at the bottom) */}
      <div className="p-4 border-t">
          <ThemeToggle />
      </div>
    </nav>
  )
}

```

## 📄 .tmp_backups/admin/src/app/_components/multi-select.jsx.bak
*Lines: 62, Size: 1.97 KB*

```
// src/app/_components/multi-select.jsx (version 1.2.0)
'use client'

import * as React from 'react'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@headlines/ui'
import { Button } from '@headlines/ui'
import { Checkbox } from '@headlines/ui'
import { ChevronsUpDown } from 'lucide-react'
import { ScrollArea } from '@headlines/ui'

export function MultiSelect({ options, selected, onChange, placeholder = 'Select...' }) {
  const handleSelect = (option) => {
    const newSelected = selected.includes(option)
      ? selected.filter((item) => item !== option)
      : [...selected, option]
    onChange(newSelected)
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant="outline"
          className="w-full justify-between font-normal bg-black/20 border-white/10"
        >
          <span className="truncate">
            {selected.length > 0 ? selected.join(', ') : placeholder}
          </span>
          <ChevronsUpDown className="h-4 w-4 opacity-50" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-[--radix-dropdown-menu-trigger-width] p-0">
        <ScrollArea className="h-72"> {/* CRITICAL FIX: Added ScrollArea with max height */}
          <div className="p-1">
            {options.map((option) => (
              <DropdownMenuItem
                key={option}
                onSelect={(e) => e.preventDefault()}
                className="flex items-center gap-2"
              >
                <Checkbox
                  id={`select-${option}`}
                  checked={selected.includes(option)}
                  onCheckedChange={() => handleSelect(option)}
                />
                <label htmlFor={`select-${option}`} className="w-full">
                  {option}
                </label>
              </DropdownMenuItem>
            ))}
          </div>
        </ScrollArea>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}

```

## 📄 .tmp_backups/admin/src/app/api/events/route.js.bak
*Lines: 39, Size: 1.52 KB*

```
// apps/admin/src/app/api/events/route.js (version 1.0.0)
import { NextResponse } from 'next/server';
import { getAdminEvents, updateAdminEvent, deleteAdminEvent } from '@headlines/data-access';

export const dynamic = 'force-dynamic';

export async function GET(request) {
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1', 10);
    const sort = searchParams.get('sort') || 'date_desc';
    const q = searchParams.get('q') || '';
    // DEFINITIVE FIX: Read the 'country' filter from the search parameters.
    const country = searchParams.get('country') || '';
    
    const result = await getAdminEvents({ page, sort, filters: { q, country } });
    if (!result.success) {
        return NextResponse.json({ error: result.error }, { status: 500 });
    }
    return NextResponse.json(result);
}

export async function PATCH(request) {
    const { eventId, updateData } = await request.json();
    const result = await updateAdminEvent(eventId, updateData);
     if (!result.success) {
        return NextResponse.json({ error: result.error }, { status: result.error.includes('not found') ? 404 : 500 });
    }
    return NextResponse.json(result.data);
}

export async function DELETE(request) {
    const { eventId } = await request.json();
    const result = await deleteAdminEvent(eventId);
    if (!result.success) {
        return NextResponse.json({ error: result.error }, { status: result.error.includes('not found') ? 404 : 500 });
    }
    return NextResponse.json({ success: true });
}

```

## 📄 .tmp_backups/admin/src/app/api/opportunities/route.js.bak
*Lines: 38, Size: 1.48 KB*

```
// apps/admin/src/app/api/opportunities/route.js (version 1.0.0)
import { NextResponse } from 'next/server';
import { getAdminOpportunities, updateAdminOpportunity, deleteAdminOpportunity } from '@headlines/data-access';

export const dynamic = 'force-dynamic';

export async function GET(request) {
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1', 10);
    const sort = searchParams.get('sort') || 'date_desc';
    const q = searchParams.get('q') || '';
    const country = searchParams.get('country') || '';

    const result = await getAdminOpportunities({ page, sort, filters: { q, country } });
    if (!result.success) {
        return NextResponse.json({ error: result.error }, { status: 500 });
    }
    return NextResponse.json(result);
}

export async function PATCH(request) {
    const { oppId, updateData } = await request.json();
    const result = await updateAdminOpportunity(oppId, updateData);
     if (!result.success) {
        return NextResponse.json({ error: result.error }, { status: result.error.includes('not found') ? 404 : 500 });
    }
    return NextResponse.json(result.data);
}

export async function DELETE(request) {
    const { oppId } = await request.json();
    const result = await deleteAdminOpportunity(oppId);
    if (!result.success) {
        return NextResponse.json({ error: result.error }, { status: result.error.includes('not found') ? 404 : 500 });
    }
    return NextResponse.json({ success: true });
}

```

## 📄 .tmp_backups/admin/src/app/articles/columns.jsx.bak
*Lines: 74, Size: 3.5 KB*

```
// apps/admin/src/app/articles/columns.jsx (version 1.1.0)
'use client'

import React, { useState, useEffect, useRef } from 'react';
import { Button, Badge, Input } from '@headlines/ui';
import { ArrowUpDown, Trash2, ExternalLink, Edit } from 'lucide-react';
import { format } from 'date-fns';

const EditableCell = ({ initialValue, onSave }) => {
    const [isEditing, setIsEditing] = useState(false);
    const [value, setValue] = useState(initialValue);
    const inputRef = useRef(null);

    useEffect(() => {
        if (isEditing) inputRef.current?.focus();
    }, [isEditing]);

    const handleSave = () => {
        if (value.trim() && value.trim() !== initialValue) {
            onSave(value.trim());
        }
        setIsEditing(false);
    };

    if (isEditing) {
        return <Input ref={inputRef} value={value} onChange={(e) => setValue(e.target.value)} onBlur={handleSave} onKeyDown={(e) => e.key === 'Enter' && handleSave()} className="h-8"/>;
    }

    return <div className="group flex items-center cursor-pointer" onClick={() => setIsEditing(true)}><span className="truncate">{initialValue}</span><Edit className="h-3 w-3 ml-2 text-muted-foreground opacity-0 group-hover:opacity-100"/></div>;
}


export const columns = (onUpdate, onDelete) => [
    {
        accessorKey: 'relevance_headline',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>HL Score <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => <Badge variant="outline">{row.original.relevance_headline}</Badge>
    },
    {
        accessorKey: 'relevance_article',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Article Score <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => <Badge variant={row.original.relevance_article > 50 ? 'default' : 'secondary'}>{row.original.relevance_article || 'N/A'}</Badge>
    },
    {
        accessorKey: 'headline',
        header: 'Headline',
        cell: ({ row }) => <EditableCell initialValue={row.original.headline} onSave={(newValue) => onUpdate(row.original, { headline: newValue })} />
    },
    {
        accessorKey: 'newspaper',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Source <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
    },
    {
        accessorKey: 'country',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Country <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
    },
    {
        accessorKey: 'createdAt',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Discovered <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => format(new Date(row.original.createdAt), 'dd MMM yyyy, HH:mm'),
    },
    {
        id: 'actions',
        cell: ({ row }) => (
            <div className="flex items-center justify-end gap-2">
                <a href={row.original.link} target="_blank" rel="noopener noreferrer">
                    <Button variant="ghost" size="icon" className="h-8 w-8"><ExternalLink className="h-4 w-4" /></Button>
                </a>
                <Button variant="ghost" size="icon" className="h-8 w-8 text-muted-foreground" onClick={() => onDelete(row.original._id)}><Trash2 className="h-4 w-4" /></Button>
            </div>
        ),
    }
];

```

## 📄 .tmp_backups/admin/src/app/articles/page.jsx.bak
*Lines: 67, Size: 2.95 KB*

```
// apps/admin/src/app/articles/page.jsx (version 1.1.0)
'use client'

import { PageHeader, DataTable } from '@headlines/ui';
import { columns } from './columns';
import { useAdminManager } from '@/hooks/use-admin-manager';
import { deleteAdminArticle, updateAdminArticle } from '@headlines/data-access';
import { toast } from 'sonner';
import { useCallback, useMemo } from 'react';

export default function ArticlesPage() {
    const { data, total, isLoading, searchTerm, setSearchTerm, sort, setSort, refetch, handleUpdate, handleRemove, setFilter } = useAdminManager('/api/articles', 'createdAt_desc');

    const availableCountries = useMemo(() => {
        if (!data) return [];
        const countrySet = new Set(data.map(item => item.country).filter(Boolean));
        return Array.from(countrySet).sort();
    }, [data]);

    const handleOptimisticUpdate = useCallback(async (article, updateData) => {
        handleUpdate(article._id, updateData);
        const result = await updateAdminArticle(article._id, updateData);
        if (!result.success) {
            toast.error(`Update failed: ${result.error}`);
            refetch();
        }
    }, [handleUpdate, refetch]);

    const handleDelete = useCallback(async (articleId) => {
        handleRemove(articleId);
        toast.success('Article deleted.');
        const result = await deleteAdminArticle(articleId);
        if (!result.success) {
            toast.error(`Deletion failed on server: ${result.error}. Reverting.`);
            refetch();
        }
    }, [handleRemove, refetch]);
    
    // DEFINITIVE FIX: Create a dynamic description based on the length of the `data` array.
    const description = `Review and manage all ${data.length.toLocaleString()} visible articles (${total.toLocaleString()} total).`;

    return (
        <div className="flex flex-col h-full">
            <PageHeader title="Article Management" description={description} />
            <div className="mt-8 flex-grow min-h-0 max-w-none">
                <DataTable
                    columns={columns(handleOptimisticUpdate, handleDelete)}
                    data={data}
                    isLoading={isLoading}
                    filterColumn="headline"
                    filterPlaceholder="Filter by headline, source..."
                    secondaryFilterColumn="country"
                    secondaryFilterOptions={availableCountries}
                    onSecondaryFilterChange={(value) => setFilter('country', value === 'all' ? null : value)}
                    initialSort={[{id: sort.split('_')[0], desc: sort.endsWith('desc')}]}
                    onSortingChange={(updater) => {
                        const newSort = updater([{id: sort.split('_')[0], desc: sort.endsWith('desc')}]);
                        if (newSort && newSort[0]) {
                             setSort(`${newSort[0].id}_${newSort[0].desc ? 'desc' : 'asc'}`);
                        }
                    }}
                />
            </div>
        </div>
    );
}

```

## 📄 .tmp_backups/admin/src/app/events/columns.jsx.bak
*Lines: 156, Size: 8.53 KB*

```
// apps/admin/src/app/events/columns.jsx (version 1.4.1)
'use client'

import React, { useState, useEffect, useRef } from 'react';
import { Button, Badge, Input, Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '@headlines/ui';
import { ArrowUpDown, Trash2, Loader2, Newspaper, Target, ExternalLink, Edit, ChevronsUpDown, User, Building } from 'lucide-react';
import { format } from 'date-fns';

const EditableCell = ({ initialValue, onSave }) => {
    const [isEditing, setIsEditing] = useState(false);
    const [value, setValue] = useState(initialValue);
    const inputRef = useRef(null);

    useEffect(() => {
        if (isEditing) inputRef.current?.focus();
    }, [isEditing]);

    const handleSave = () => {
        if (value.trim() && value.trim() !== initialValue) {
            onSave(value.trim());
        }
        setIsEditing(false);
    };

    if (isEditing) {
        return <Input ref={inputRef} value={value} onChange={(e) => setValue(e.target.value)} onBlur={handleSave} onKeyDown={(e) => e.key === 'Enter' && handleSave()} className="h-8 w-full bg-secondary"/>;
    }

    return <div className="group flex items-center cursor-pointer font-medium text-sm" onClick={() => setIsEditing(true)}><span className="line-clamp-2 whitespace-normal pr-2">{initialValue}</span><Edit className="h-3 w-3 ml-auto text-muted-foreground opacity-0 group-hover:opacity-100 flex-shrink-0"/></div>;
}

const ExpandedRowContent = ({ eventId }) => {
    const [details, setDetails] = useState(null);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        fetch(`/api/events/${eventId}`)
            .then(res => res.json())
            .then(data => {
                setDetails(data);
                setIsLoading(false);
            })
            .catch(() => setIsLoading(false));
    }, [eventId]);

    if (isLoading) return <div className="p-4 flex items-center gap-2 text-muted-foreground"><Loader2 className="h-4 w-4 animate-spin" /> Loading details...</div>;
    if (!details) return <div className="p-4 text-destructive">Failed to load details.</div>;

    return (
        <div className="p-6 bg-black/20 grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div className="lg:col-span-2 space-y-4">
                <div>
                    <h4 className="font-semibold text-sm text-muted-foreground mb-1">Synthesized Summary</h4>
                    <p className="text-sm">{details.synthesized_summary}</p>
                </div>
                 <div>
                    <h4 className="font-semibold text-sm text-muted-foreground mb-1">AI Assessment</h4>
                    <p className="text-sm italic text-muted-foreground">"{details.ai_assessment_reason}"</p>
                </div>
                <div>
                    <h4 className="font-semibold text-sm mb-2">Key Individuals ({details.key_individuals?.length || 0})</h4>
                    <div className="space-y-2 max-h-40 overflow-y-auto">
                        {(details.key_individuals || []).map((p, i) => (
                            <div key={i} className="text-xs p-2 rounded bg-secondary/50">
                                <p className="font-medium flex items-center gap-2"><User className="h-3 w-3"/>{p.name}</p>
                                <p className="pl-5 text-muted-foreground flex items-center gap-2"><Building className="h-3 w-3"/>{p.role_in_event} at {p.company}</p>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
            <div className="space-y-4">
                <div>
                    <h4 className="font-semibold text-sm mb-2">Source Articles ({details.source_articles_full?.length || 0})</h4>
                    <div className="space-y-2 max-h-40 overflow-y-auto">
                        {(details.source_articles_full || []).map(article => (
                            <div key={article._id} className="text-xs p-2 rounded bg-secondary/50 flex justify-between items-center">
                                <span className="truncate pr-4">{article.newspaper}: {article.headline}</span>
                                <a href={article.link} target="_blank" rel="noopener noreferrer"><ExternalLink className="h-3 w-3" /></a>
                            </div>
                        ))}
                    </div>
                </div>
                <div>
                    <h4 className="font-semibold text-sm mb-2">Related Opportunities ({details.relatedOpportunities?.length || 0})</h4>
                    <div className="space-y-2 max-h-40 overflow-y-auto">
                         {(details.relatedOpportunities || []).map(opp => (
                            <div key={opp._id} className="text-xs p-2 rounded bg-secondary/50">
                                {opp.reachOutTo} (~${opp.likelyMMDollarWealth}M)
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};

export const EventListItem = ({ event, onUpdate, onDelete }) => {
    const score = event.highest_relevance_score;
    const scoreColorClass = score >= 80 ? 'bg-green-500/20 text-green-300' : score >= 60 ? 'bg-yellow-500/20 text-yellow-300' : 'bg-muted';
    const articleCount = event.source_articles?.length || 0;
    const opportunityCount = event.relatedOpportunities?.length || 0;
    
    return (
        <AccordionItem value={event._id} className="border-b border-border">
            <div className="flex items-center p-2">
                <AccordionTrigger className="w-10 h-10 flex-shrink-0 flex items-center justify-center p-2 [&[data-state=open]>svg]:rotate-180">
                    <ChevronsUpDown className="h-4 w-4 transition-transform duration-200" />
                </AccordionTrigger>
                <div className="w-20 flex-shrink-0 text-center">
                    <Badge className={scoreColorClass}>{score}</Badge>
                </div>
                <div className="flex-grow min-w-0 pr-4">
                     <EditableCell initialValue={event.synthesized_headline} onSave={(newValue) => onUpdate(event, { synthesized_headline: newValue })} />
                </div>
                <div className="w-36 flex-shrink-0 text-sm">{event.country}</div>
                <div className="w-44 flex-shrink-0 text-sm">{format(new Date(event.createdAt), 'dd MMM yyyy')}</div>
                <div className="w-32 flex-shrink-0 flex items-center gap-4 text-sm text-muted-foreground">
                    {articleCount > 0 && (
                        <span className="flex items-center gap-1.5" title="Source Articles"><Newspaper className="h-4 w-4" /> {articleCount}</span>
                    )}
                    {opportunityCount > 0 && (
                        <span className="flex items-center gap-1.5" title="Related Opportunities"><Target className="h-4 w-4" /> {opportunityCount}</span>
                    )}
                </div>
                <div className="w-16 flex-shrink-0 text-right">
                    <Button variant="ghost" size="icon" className="h-8 w-8 text-muted-foreground" onClick={() => onDelete(event._id)}><Trash2 className="h-4 w-4" /></Button>
                </div>
            </div>
            <AccordionContent>
                <ExpandedRowContent eventId={event._id} />
            </AccordionContent>
        </AccordionItem>
    )
};

const SortableHeader = ({ children, value, sort, setSort }) => {
    const isSorted = sort.startsWith(value);
    const isDesc = isSorted && sort.endsWith('_desc');
    const newSort = isSorted ? (isDesc ? `${value}_asc` : `${value}_desc`) : `${value}_desc`;
    return <Button variant="ghost" size="sm" onClick={() => setSort(newSort)}>{children} {isSorted && <ArrowUpDown className="ml-2 h-4 w-4" />}</Button>
};

export const ListHeader = ({ sort, setSort }) => (
    <div className="flex items-center p-2 border-b font-medium text-muted-foreground text-sm sticky top-0 bg-background z-10">
        <div className="w-10 flex-shrink-0"></div>
        <div className="w-20 flex-shrink-0 text-center"><SortableHeader value="highest_relevance_score" sort={sort} setSort={setSort}>Score</SortableHeader></div>
        <div className="flex-grow min-w-0 pr-4">Headline</div>
        <div className="w-36 flex-shrink-0"><SortableHeader value="country" sort={sort} setSort={setSort}>Country</SortableHeader></div>
        <div className="w-44 flex-shrink-0"><SortableHeader value="createdAt" sort={sort} setSort={setSort}>Discovered</SortableHeader></div>
        <div className="w-32 flex-shrink-0">Relations</div>
        <div className="w-16 flex-shrink-0 text-right">Actions</div>
    </div>
);

```

## 📄 .tmp_backups/admin/src/app/events/page.jsx.bak
*Lines: 84, Size: 4.09 KB*

```
// apps/admin/src/app/events/page.jsx (version 1.2.1)
'use client'

import { PageHeader, Input, Accordion, LoadingOverlay, Select, SelectContent, SelectItem, SelectTrigger, SelectValue, ScrollArea } from '@headlines/ui';
import { EventListItem, ListHeader } from './columns';
// DEFINITIVE FIX: Import the new, correct hook
import { useAdminListManager } from '@/hooks/useAdminListManager';
import { deleteAdminEvent, updateAdminEvent } from '@headlines/data-access';
import { toast } from 'sonner';
import { useCallback, useMemo } from 'react';
import { Search } from 'lucide-react';

export default function EventsPage() {
    const { data, total, isLoading, searchTerm, setSearchTerm, sort, setSort, refetch, handleUpdate, handleRemove, setFilter } = useAdminListManager('/api/events', 'createdAt_desc');
    
    const availableCountries = useMemo(() => {
        if (!data) return [];
        const countrySet = new Set(data.map(item => item.country).filter(Boolean));
        return Array.from(countrySet).sort();
    }, [data]);

    const handleOptimisticUpdate = useCallback(async (event, updateData) => {
        handleUpdate(event._id, updateData);
        const result = await updateAdminEvent(event._id, updateData);
        if (!result.success) {
            toast.error(`Update failed: ${result.error}`);
            refetch();
        }
    }, [handleUpdate, refetch]);

    const handleDelete = useCallback(async (eventId) => {
        handleRemove(eventId);
        toast.success('Event and its relations deleted.');
        const result = await deleteAdminEvent(eventId);
        if (!result.success) {
            toast.error(`Deletion failed on server: ${result.error}. Reverting.`);
            refetch();
        }
    }, [handleRemove, refetch]);
    
    const description = `Review, audit, and manage all ${data.length.toLocaleString()} visible events (${total.toLocaleString()} total).`;
    
    return (
        <div className="flex flex-col h-full">
            <PageHeader title="Event Management" description={description} />
            <div className="mt-8 flex-grow min-h-0 flex flex-col">
                <div className="flex items-center py-4 justify-between">
                     <div className="flex items-center gap-4">
                        <div className="relative flex-grow">
                            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-slate-500" />
                            <Input
                                placeholder="Filter by headline, country..."
                                value={searchTerm}
                                onChange={(e) => setSearchTerm(e.target.value)}
                                className="h-10 pl-10 w-80"
                            />
                        </div>
                        <Select onValueChange={(value) => setFilter('country', value === 'all' ? null : value)}>
                            <SelectTrigger className="w-[180px]">
                                <SelectValue placeholder="Filter by country..." />
                            </SelectTrigger>
                            <SelectContent>
                                <ScrollArea className="h-72">
                                    <SelectItem value="all">All Countries</SelectItem>
                                    {availableCountries.map(c => <SelectItem key={c} value={c}>{c}</SelectItem>)}
                                </ScrollArea>
                            </SelectContent>
                        </Select>
                     </div>
                </div>
                <div className="relative rounded-md border flex-grow overflow-y-auto">
                    <LoadingOverlay isLoading={isLoading && data.length === 0} />
                    <ListHeader sort={sort} setSort={setSort} />
                    <Accordion type="single" collapsible>
                        {data.map(event => (
                            <EventListItem key={event._id} event={event} onUpdate={handleOptimisticUpdate} onDelete={handleDelete} />
                        ))}
                    </Accordion>
                </div>
            </div>
        </div>
    );
}

```

## 📄 .tmp_backups/admin/src/app/layout.js.bak
*Lines: 45, Size: 1.37 KB*

```
// apps/admin/src/app/layout.js (version 3.3.0)
import { Inter } from 'next/font/google'
import './globals.css'
import { Toaster } from '@headlines/ui'
import { cn } from '@headlines/utils'
import MainNav from './_components/main-nav'
import { ThemeProvider } from './_components/theme-provider'

const fontSans = Inter({
  subsets: ['latin'],
  variable: '--font-sans',
  display: 'swap',
})

export default function RootLayout({ children }) {  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={cn(
          'min-h-screen bg-background font-sans antialiased',
          fontSans.variable
        )}
      >
        <ThemeProvider
          attribute="class"
          defaultTheme="dark"
          enableSystem
          disableTransitionOnChange
        >
          {/* This is the main flex container for the two-column layout */}
          <div className="flex h-screen w-full overflow-hidden">
            <MainNav />
            {/* The main content area grows to fill remaining space and scrolls internally */}
            <main className="flex-1 flex flex-col overflow-y-auto">
              <div className="w-full max-w-screen-xl mx-auto p-6 lg:p-8">
                {children}
              </div>
            </main>
          </div>
          <Toaster theme="dark" position="bottom-right" />
        </ThemeProvider>
      </body>
    </html>
  )
}

```

## 📄 .tmp_backups/admin/src/app/opportunities/columns.jsx.bak
*Lines: 62, Size: 3.52 KB*

```
// apps/admin/src/app/opportunities/columns.jsx (version 1.4.0)
'use client'

import React, { useState, useEffect, useRef } from 'react';
import { Button, EditableCell } from '@headlines/ui';
import { ArrowUpDown, Trash2 } from 'lucide-react';
import { format } from 'date-fns';

export const columns = (onUpdate, onDelete) => [
    {
        accessorKey: 'basedIn',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Country <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => <EditableCell initialValue={row.original.basedIn} placeholder="Add country..." onSave={(newValue) => onUpdate(row.original, { basedIn: newValue })} />,
        size: 130,
    },
    {
        accessorKey: 'city',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>City <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => <EditableCell initialValue={row.original.city} placeholder="Add city..." onSave={(newValue) => onUpdate(row.original, { city: newValue })} />,
        size: 130,
    },
    {
        accessorKey: 'reachOutTo',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Contact <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => <EditableCell initialValue={row.original.reachOutTo} onSave={(newValue) => onUpdate(row.original, { reachOutTo: newValue })} allowWrap={true} />,
        size: 250,
    },
    {
        accessorKey: 'likelyMMDollarWealth',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Wealth ($M) <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => <EditableCell initialValue={row.original.likelyMMDollarWealth} placeholder="Add wealth..." onSave={(newValue) => onUpdate(row.original, { likelyMMDollarWealth: newValue })} type="number" />,
        size: 120,
    },
    {
        accessorKey: 'contactDetails.email',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Email <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        // DEFINITIVE FIX: The `onSave` handler now passes an object with dot notation
        // to ensure MongoDB updates the nested field correctly.
        cell: ({ row }) => <EditableCell initialValue={row.original.contactDetails?.email} placeholder="Add email..." onSave={(newValue) => onUpdate(row.original, { 'contactDetails.email': newValue })} />,
        size: 200,
    },
    {
        accessorKey: 'whyContact',
        header: 'Reason',
        cell: ({ row }) => {
            const reasons = Array.isArray(row.original.whyContact) ? row.original.whyContact : [row.original.whyContact];
            return <p className="text-sm text-muted-foreground line-clamp-2">{reasons.join(' ')}</p>
        },
    },
    {
        accessorKey: 'createdAt',
        header: ({ column }) => <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}>Created <ArrowUpDown className="ml-2 h-4 w-4" /></Button>,
        cell: ({ row }) => format(new Date(row.original.createdAt), 'dd MMM yyyy'),
        size: 120,
    },
    {
        id: 'actions',
        cell: ({ row }) => <Button variant="ghost" size="icon" className="h-8 w-8 text-muted-foreground" onClick={() => onDelete(row.original._id)}><Trash2 className="h-4 w-4" /></Button>,
        size: 60,
    }
];

```

## 📄 .tmp_backups/admin/src/app/opportunities/page.jsx.bak
*Lines: 83, Size: 3.75 KB*

```
// apps/admin/src/app/opportunities/page.jsx (version 1.2.0)
'use client'

import { PageHeader, DataTable, ExportButton } from '@headlines/ui';
import { columns } from './columns';
import { useAdminManager } from '@/hooks/use-admin-manager';
import { deleteAdminOpportunity, updateAdminOpportunity, exportOpportunitiesToCSV, exportOpportunitiesToXLSX } from '@headlines/data-access';
import { toast } from 'sonner';
import { useCallback, useMemo } from 'react';

export default function OpportunitiesPage() {
    const { data, total, isLoading, searchTerm, setSearchTerm, sort, setSort, refetch, handleUpdate, handleRemove, setFilter, filters } = useAdminManager('/api/opportunities', 'basedIn_asc');
    
    const availableCountries = useMemo(() => {
        if (!data) return [];
        const countrySet = new Set(data.map(item => item.basedIn).filter(Boolean));
        return Array.from(countrySet).sort();
    }, [data]);

    const handleOptimisticUpdate = useCallback(async (opp, updateData) => {
        handleUpdate(opp._id, updateData);
        const result = await updateAdminOpportunity(opp._id, updateData);
        if (!result.success) {
            toast.error(`Update failed: ${result.error}`);
            refetch();
        } else {
            toast.success(`Updated ${Object.keys(updateData)[0]} for ${opp.reachOutTo}`);
        }
    }, [handleUpdate, refetch]);

    const handleDelete = useCallback(async (oppId) => {
        handleRemove(oppId);
        toast.success('Opportunity deleted.');
        const result = await deleteAdminOpportunity(oppId);
        if (!result.success) {
            toast.error(`Deletion failed on server: ${result.error}. Reverting.`);
            refetch();
        }
    }, [handleRemove, refetch]);
    
    const description = `Review and manage all ${data.length.toLocaleString()} visible opportunities (${total.toLocaleString()} total).`;
    const currentFilters = { ...filters, q: searchTerm };

    // DEFINITIVE FIX: Create an object of export actions to pass to the button
    const exportActions = {
        csv: () => exportOpportunitiesToCSV({ filters: currentFilters, sort }),
        xlsx: () => exportOpportunitiesToXLSX({ filters: currentFilters, sort })
    };

    return (
        <div className="flex flex-col h-full">
            <PageHeader title="Opportunity Management" description={description}>
                <ExportButton 
                    hasData={data && data.length > 0} 
                    filename="opportunities_export" 
                    exportActions={exportActions}
                />
            </PageHeader>
            <div className="mt-8 flex-grow min-h-0 max-w-none">
                <DataTable
                    columns={columns(handleOptimisticUpdate, handleDelete)}
                    data={data}
                    isLoading={isLoading}
                    filterColumn="reachOutTo"
                    filterPlaceholder="Filter by name, country, city..."
                    secondaryFilterColumn="basedIn"
                    secondaryFilterOptions={availableCountries}
                    onSecondaryFilterChange={(value) => setFilter('country', value === 'all' ? null : value)}
                    emailFilter={filters?.withEmail}
                    onEmailFilterChange={(value) => setFilter('withEmail', value)}
                    initialSort={[{id: sort.split('_')[0], desc: sort.endsWith('desc')}]}
                    onSortingChange={(updater) => {
                        const newSort = updater([{id: sort.split('_')[0], desc: sort.endsWith('desc')}]);
                        if (newSort && newSort[0]) {
                             setSort(`${newSort[0].id}_${newSort[0].desc ? 'desc' : 'asc'}`);
                        }
                    }}
                />
            </div>
        </div>
    );
}

```

## 📄 .tmp_backups/admin/src/app/sources/page.jsx.bak
*Lines: 165, Size: 6.53 KB*

```
// apps/admin/src/app/sources/page.jsx (version 5.0.0)
'use client'

import { useState, useCallback, useMemo, useEffect, Suspense } from 'react'
import { useSearchParams, useRouter } from 'next/navigation'
import { ServerCrash, PlusCircle, Wrench, Trash2, Pause, Play } from 'lucide-react'
import {
  PageHeader,
  DataTable,
  Button,
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
  ConfirmationDialog,
  LoadingOverlay, 
} from '@headlines/ui'
import { useEntityManager } from '@/hooks/use-entity-manager'
import { columns } from './columns'
import { suggestionColumns } from './suggestion-columns'
import SourceIdeModal from './source-ide-modal'
import { toast } from 'sonner'
import TestResultsViewer from '../_components/test-results-viewer'
import AddSourceModal from './add-source-modal'
import {
  processSourceSuggestion,
  updateSource,
  deleteSource,
  testSourceConfig,
} from '@headlines/data-access'
import SourceList from '../_components/source-list' // Import the SourceList
import { useSourceHealthChecker } from './use-source-health-checker'

function SourcesPageContent() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const statusFilter = searchParams.get('status')
  const action = searchParams.get('action')
  const sourceIdToEdit = searchParams.get('sourceId')

  const {
    entities: sources,
    setEntities,
    isLoading: isLoadingSources,
    error: sourcesError,
    handleSave,
    refetch: refetchSources,
  } = useEntityManager('/api/sources', 'Source', 'name')
  
  const { 
    entities: suggestions, 
    isLoading: isLoadingSuggestions,
    refetch: refetchSuggestions,
    error: suggestionsError,
  } = useEntityManager('/api/suggestions', 'SourceSuggestion', 'createdAt', { dataKey: 'sourceSuggestions' })
  
  const {
    entities: countries,
    isLoading: isLoadingCountries,
    error: countriesError,
  } = useEntityManager('/api/countries', 'Country', 'name')
  
  const [selectedSourceId, setSelectedSourceId] = useState(null);
  const [isIdeOpen, setIsIdeOpen] = useState(false)
  const [testResults, setTestResults] = useState(null)
  const [isAddModalOpen, setIsAddModalOpen] = useState(false)
  const [confirmState, setConfirmState] = useState({ isOpen: false, action: null });
  
  const availableCountries = useMemo(() => {
    if (!countries) return ['all'];
    const countryNames = countries.filter(c => c.status === 'active').map(c => c.name);
    return ['all', ...countryNames.sort()];
  }, [countries]);

  const handleSourceUpdate = useCallback((updatedSource) => {
    setEntities(prev => prev.map(s => s._id === updatedSource._id ? updatedSource : s));
  }, [setEntities]);
  
  const { liveStatuses, isCheckingAll, handleCheckFiltered, handleStopCheck, handleTestComplete } = useSourceHealthChecker(handleSourceUpdate);

  const activeSourceData = useMemo(() => {
    if (selectedSourceId) return sources?.find(s => s._id === selectedSourceId) || null;
    return null;
  }, [selectedSourceId, sources]);
  
  useEffect(() => {
    if (action === 'edit' && sourceIdToEdit) {
      setSelectedSourceId(sourceIdToEdit);
    } else if (action === 'add') {
      const newSourceData = { _id: null, name: searchParams.get('name') || '', country: searchParams.get('country') || '', sectionUrl: searchParams.get('sectionUrl') || '', baseUrl: searchParams.get('baseUrl') || '', status: 'active', scrapeFrequency: 'high', extractionMethod: 'declarative' };
      // This case is now handled by the Scraper IDE page
      router.push(`/scraper-ide?action=add&name=${searchParams.get('name')}&sectionUrl=${searchParams.get('sectionUrl')}`);
    }
  }, [action, sourceIdToEdit, searchParams, router]);

  const handleCloseIde = () => { router.push('/', { scroll: false }); setSelectedSourceId(null); }
  const handleEdit = (id) => setSelectedSourceId(id);

  const handleTest = useCallback(async (source) => {
    const toastId = toast.loading(`Running test scrape for "${source.name}"...`);
    const result = await testSourceConfig(source);
    if (result.success) {
      handleSave(result.data.updatedSource);
      handleTestComplete(source._id, result.data.count, result.data.updatedSource);
      setTestResults(result.data);
      toast.success(`Test complete! Found ${result.data.count} headlines.`, { id: toastId });
    } else {
      toast.error(`Test failed: ${result.details || 'Unknown error'}`, { id: toastId });
    }
  }, [handleSave, handleTestComplete]);
  
  const error = sourcesError || suggestionsError || countriesError;
  const isLoading = isLoadingSources || isLoadingCountries;

  if (error) {
    return ( <div className="flex h-full w-full items-center justify-center text-center p-4"> <div className="p-8 rounded-lg bg-destructive/10 border border-destructive/50 max-w-md"> <ServerCrash className="w-12 h-12 mx-auto text-destructive mb-4" /> <h1 className="text-2xl font-bold">Failed to Load Sources</h1> <p className="text-destructive-foreground/80 mt-2">{error}</p> </div> </div> )
  }

  // CORRECTED LAYOUT: Use a flex container to create two columns.
  return (
    <div className="flex flex-row h-full w-full">
      <SourceList 
        sources={sources}
        isLoading={isLoading}
        selectedSourceId={selectedSourceId}
        onSelectSource={setSelectedSourceId}
        onAddSource={() => router.push('/scraper-ide')}
        onCheckFiltered={handleCheckFiltered}
        onStopCheck={handleStopCheck}
        isCheckingAll={isCheckingAll}
        liveStatuses={liveStatuses}
        countries={availableCountries}
      />
      
      {/* Main content area that fills the remaining space */}
      <div className="flex-grow p-6 flex flex-col">
        {activeSourceData ? (
          <SourceIdeModal 
            source={activeSourceData}
            open={!!activeSourceData}
            onOpenChange={handleCloseIde}
            onSave={(saved) => { handleSave(saved); refetchSources(); handleCloseIde(); }}
            countries={availableCountries.filter(c => c !== 'all')}
          />
        ) : (
          <div className="text-center text-muted-foreground pt-20">
            <p className="text-lg">Select a source from the list to view or edit.</p>
            <p>Or, click "Add New Source" to configure a new one in the Scraper IDE.</p>
          </div>
        )}
      </div>

      <TestResultsViewer results={testResults} open={!!testResults} onOpenChange={() => setTestResults(null)} />
    </div>
  )
}

export default function SourcesPage() {
  return (
    <Suspense fallback={<div className="relative flex items-center justify-center h-96"><LoadingOverlay isLoading={true} /></div>}>
      <SourcesPageContent />
    </Suspense>
  )
}

```

## 📄 .tmp_backups/ai-services/src/chains/index.js.bak
*Lines: 45, Size: 2.88 KB*

```
// packages/ai-services/src/chains/index.js (version 3.1 - Final)
import { articleChain as ac } from './articleChain.js';
import { articlePreAssessmentChain as apac } from './articlePreAssessmentChain.js';
import { clusteringChain as cc } from './clusteringChain.js';
import { contactFinderChain as cfc } from './contactFinderChain.js';
import { contactResolverChain as crc } from './contactResolverChain.js';
import { disambiguationChain as dc } from './disambiguationChain.js';
import { emailIntroChain as eic } from './emailIntroChain.js';
import { emailSubjectChain as esc } from './emailSubjectChain.js';
import { entityCanonicalizerChain as ecc } from './entityCanonicalizerChain.js';
import { entityExtractorChain as eec } from './entityExtractorChain.js';
import { executiveSummaryChain as exsc } from './executiveSummaryChain.js';
import { headlineChain as hc } from './headlineChain.js';
import { judgeChain as jc } from './judgeChain.js';
import { opportunityChain as oc } from './opportunityChain.js';
import { sectionClassifierChain as scc } from './sectionClassifierChain.js';
import { selectorRepairChain as src } from './selectorRepairChain.js';
import { synthesisChain as sc } from './synthesisChain.js';
import { watchlistSuggestionChain as wsc } from './watchlistSuggestionChain.js';
import { batchHeadlineChain as bhc } from './batchHeadlineChain.js';
import { translateChain as tc } from './translateChain.js';

// DEFINITIVE FIX: Export each chain's invoke method as a standalone async function
// to comply with "use server" constraints.
export const articleChain = async (input) => ac.invoke(input);
export const articlePreAssessmentChain = async (input) => apac.invoke(input);
export const clusteringChain = async (input) => cc.invoke(input);
export const contactFinderChain = async (input) => cfc.invoke(input);
export const contactResolverChain = async (input) => crc.invoke(input);
export const disambiguationChain = async (input) => dc.invoke(input);
export const emailIntroChain = async (input) => eic.invoke(input);
export const emailSubjectChain = async (input) => esc.invoke(input);
export const entityCanonicalizerChain = async (input) => ecc.invoke(input);
export const entityExtractorChain = async (input) => eec.invoke(input);
export const executiveSummaryChain = async (input) => exsc.invoke(input);
export const headlineChain = async (input) => hc.invoke(input);
export const judgeChain = async (input) => jc.invoke(input);
export const opportunityChain = async (input) => oc.invoke(input);
export const sectionClassifierChain = async (input) => scc.invoke(input);
export const selectorRepairChain = async (input) => src.invoke(input);
export const synthesisChain = async (input) => sc.invoke(input);
export const watchlistSuggestionChain = async (input) => wsc.invoke(input);
export const batchHeadlineChain = async (input) => bhc.invoke(input);
export const translateChain = async (input) => tc.invoke(input);

```

## 📄 .tmp_backups/ai-services/src/index.js.bak
*Lines: 70, Size: 2.3 KB*

```
// packages/ai-services/src/index.js (version 7.2.0)
'use server'

import { callLanguageModel } from './lib/langchain.js';
import * as chains from './chains/index.js';
import * as search from './search.js';
import * as wikipedia from './wikipedia.js';
import * as embeddings from './embeddings.js';
import * as vectorSearch from './vectorSearch.js';
import { logger } from '@headlines/utils/server';

// This is the primary public API of the package.
// It only exports async functions, making it compatible with Next.js "use server" modules.

export async function performAiSanityCheck(settings) {
  try {
    logger.info('🔬 Performing AI service sanity check (OpenAI)...');
    const answer = await callLanguageModel({
      modelName: settings.LLM_MODEL_UTILITY, // Use the dynamic utility model
      prompt: 'What is in one word the name of the capital of France',
      isJson: false,
    });
    if (answer && typeof answer === 'string' && answer.trim().toLowerCase().includes('paris')) {
      logger.info('✅ AI service sanity check passed.');
      return true;
    } else {
      logger.fatal({ details: { expected: 'paris', received: answer } }, `OpenAI sanity check failed.`);
      return false;
    }
  } catch (error) {
    if (error.status === 401 || error.message?.includes('Incorrect API key')) {
      logger.fatal(`OpenAI sanity check failed due to INVALID API KEY (401).`);
    } else {
      logger.fatal({ err: error }, 'OpenAI sanity check failed with an unexpected API error.');
    }
    return false;
  }
}

// Re-export all functions from submodules.
export { callLanguageModel };
export const {
  articleChain,
  articlePreAssessmentChain,
  clusteringChain,
  contactFinderChain,
  contactResolverChain,
  disambiguationChain,
  emailIntroChain,
  emailSubjectChain,
  entityCanonicalizerChain,
  entityExtractorChain,
  executiveSummaryChain,
  headlineChain,
  batchHeadlineChain,
  judgeChain,
  opportunityChain,
  sectionClassifierChain,
  selectorRepairChain,
  synthesisChain,
  watchlistSuggestionChain,
  translateChain,
  countryCorrectionChain,
} = chains;

export const { findAlternativeSources, performGoogleSearch, findNewsApiArticlesForEvent } = search;
export const { fetchWikipediaSummary } = wikipedia;
export const { generateEmbedding } = embeddings;
export const { findSimilarArticles } = vectorSearch;

```

## 📄 .tmp_backups/ai-services/src/schemas/articleAssessmentSchema.js.bak
*Lines: 24, Size: 753 Bytes*

```
// packages/ai-services/src/schemas/articleAssessmentSchema.js (version 1.1)
import { z } from 'zod'

export const articleAssessmentSchema = z.object({
  reasoning: z.object({
    event_type: z.string(),
    is_liquidity_event: z.boolean(),
    beneficiary: z.string(),
  }),
  // NEW FIELD: Added classification to the schema.
  classification: z.enum(['New wealth', 'Wealth detection', 'Interview', 'IPO', 'Other']),
  relevance_article: z.number().min(0).max(100),
  assessment_article: z.string().min(1),
  amount: z.number().nullable().optional(),
  key_individuals: z.array(
    z.object({
      name: z.string(),
      role_in_event: z.string(),
      company: z.string().nullable(),
      email_suggestion: z.string().nullable(),
    })
  ),
})

```

## 📄 .tmp_backups/ai-services/src/schemas/index.js.bak
*Lines: 23, Size: 954 Bytes*

```
// packages/ai-services/src/schemas/index.js (version 2.1)
export * from './articleAssessmentSchema.js'
export * from './articlePreAssessmentSchema.js'
export * from './batchArticleAssessmentSchema.js'
export * from './canonicalizerSchema.js'
export * from './clusterSchema.js'
export * from './disambiguationSchema.js'
export * from './emailIntroSchema.js'
export * from './emailSubjectSchema.js'
export * from './enrichContactSchema.js'
export * from './entitySchema.js'
export * from './executiveSummarySchema.js'
export * from './findContactSchema.js'
export * from './headlineAssessmentSchema.js'
export * from './judgeSchema.js'
export * from './opportunitySchema.js'
export * from './selectorRepairSchema.js'
export * from './synthesisSchema.js'
export * from './watchlistSuggestionSchema.js'
export * from './sectionClassifierSchema.js' // Added this export
export * from './batchHeadlineAssessmentSchema.js'
export * from './translateSchema.js'

```

## 📄 .tmp_backups/ai-services/src/schemas/opportunitySchema.js.bak
*Lines: 21, Size: 847 Bytes*

```
// packages/ai-services/src/schemas/opportunitySchema.js (version 2.1)
import { z } from 'zod'

export const opportunitySchema = z.object({
  opportunities: z.array(
    z.object({
      reachOutTo: z.string().describe("The full name of the individual or family to contact."),
      contactDetails: z.object({
        email: z.string().email().nullable(),
        role: z.string().nullable(),
        company: z.string().nullable(),
      }),
      basedIn: z.string().nullable(),
      // DEFINITIVE FIX: The Zod schema must expect an array of strings to match the AI prompt.
      whyContact: z.array(z.string()).describe("An array of concise, one-sentence reasons for contact."),
      likelyMMDollarWealth: z.number().nullable(),
      event_key: z.string().describe("The unique key of the source event for this opportunity."),
    })
  ),
})

```

## 📄 .tmp_backups/ai-services/src/schemas/synthesisSchema.js.bak
*Lines: 21, Size: 549 Bytes*

```
// packages/ai-services/src/schemas/synthesisSchema.js (version 1.1)
import { z } from 'zod'

export const synthesisSchema = z.object({
  headline: z.string().min(1),
  summary: z.string().min(1),
  advisor_summary: z
    .string()
    .min(1)
    .describe('The one-sentence actionable summary for wealth advisors.'),
  country: z.string().min(1),
  key_individuals: z.array(
    z.object({
      name: z.string(),
      role_in_event: z.string(),
      company: z.string().nullable(),
      email_suggestion: z.string().nullable(),
    })
  ),
})

```

## 📄 .tmp_backups/ai-services/src/wikipedia.js.bak
*Lines: 92, Size: 3.17 KB*

```
// packages/ai-services/src/wikipedia.js (version 2.4)
import { logger } from '@headlines/utils/server'
import { apiCallTracker } from '@headlines/utils/server'
import { disambiguationChain } from './chains/index.js'

const WIKI_API_ENDPOINT = 'https://en.wikipedia.org/w/api.php'
const WIKI_SUMMARY_LENGTH = 750

// RESILIENCE FIX: Added a retry mechanism for fetch calls to handle transient network errors.
async function fetchWithRetry(url, options, maxRetries = 2) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url, options)
      if (!response.ok) {
        throw new Error(`API returned status ${response.status}`)
      }
      return response
    } catch (error) {
      if (attempt === maxRetries) {
        throw error // Rethrow the final error
      }
      const delay = 1000 * Math.pow(2, attempt - 1)
      logger.warn(
        `[Wikipedia Fetch] Attempt ${attempt} failed for ${url}. Retrying in ${delay}ms...`
      )
      await new Promise((res) => setTimeout(res, delay))
    }
  }
}

export async function fetchWikipediaSummary(query) {
  if (!query) return { success: false, error: 'Query cannot be empty.' }
  try {
    apiCallTracker.recordCall('wikipedia')
    const searchParams = new URLSearchParams({
      action: 'query',
      list: 'search',
      srsearch: query,
      srlimit: '5',
      format: 'json',
    })
    const searchResponse = await fetchWithRetry(
      `${WIKI_API_ENDPOINT}?${searchParams.toString()}`
    )
    const searchData = await searchResponse.json()
    const searchResults = searchData.query.search
    if (!searchResults || searchResults.length === 0)
      throw new Error(`No search results for "${query}".`)

    const userContent = `Original Query: "${query}"\n\nSearch Results:\n${JSON.stringify(searchResults.map((r) => ({ title: r.title, snippet: r.snippet })))}`
    const disambiguationResponse = await disambiguationChain.invoke({
      inputText: userContent,
    })

    if (disambiguationResponse.error || !disambiguationResponse.best_title) {
      throw new Error(
        disambiguationResponse.error ||
          `AI agent could not disambiguate a relevant page for "${query}".`
      )
    }

    const { best_title } = disambiguationResponse

    const summaryParams = new URLSearchParams({
      action: 'query',
      prop: 'extracts',
      exintro: 'true',
      explaintext: 'true',
      titles: best_title,
      format: 'json',
      redirects: '1',
    })
    const summaryResponse = await fetchWithRetry(
      `${WIKI_API_ENDPOINT}?${summaryParams.toString()}`
    )
    const summaryData = await summaryResponse.json()
    const pages = summaryData.query.pages
    const pageId = Object.keys(pages)[0]
    const summary = pages[pageId]?.extract
    if (!summary) throw new Error(`Could not extract summary for page "${best_title}".`)

    const conciseSummary =
      summary.length > WIKI_SUMMARY_LENGTH
        ? summary.substring(0, WIKI_SUMMARY_LENGTH) + '...'
        : summary
    return { success: true, summary: conciseSummary }
  } catch (error) {
    logger.warn(`Wikipedia lookup for "${query}" failed: ${error.message}`)
    return { success: false, error: error.message }
  }
}

```

## 📄 .tmp_backups/client/components/ArticleList.jsx.bak
*Lines: 43, Size: 1.63 KB*

```
// src/components/ArticleList.jsx (version 4.2)
import { Accordion } from '@headlines/ui'
import { ArticleCard } from '@/components/ArticleCard'
import { AnimatePresence, motion } from 'framer-motion'
import { AnimatedList, itemVariants } from './AnimatedList'
import { cn } from '@headlines/utils'

export const ArticleList = ({ articles, onDelete }) => {
  // CORRECTIVE ACTION: Default `articles` to an empty array to prevent the .map error
  // if the prop is undefined during initial render or data fetching states.
  const articleItems = articles || [];

  return (
    <Accordion type="single" collapsible>
      <AnimatedList className="w-full space-y-2">
        <AnimatePresence>
          {articleItems.map((article) => {
            const isHighRelevance =
              (article.relevance_article || article.relevance_headline) > 69
            return (
              <motion.div
                key={article._id}
                variants={itemVariants}
                exit={itemVariants.exit}
                layout
                whileHover={{ y: -2 }}
                whileTap={{ scale: 0.98 }}
                className={cn(
                  'rounded-xl bg-gradient-to-br from-slate-900 to-slate-800/60 shadow-lg shadow-black/40 border border-slate-700',
                  isHighRelevance && 'card-glow impatient-wobble',
                  'min-w-full sm:min-w-[480px]' // <-- ADDED MINIMUM WIDTH
                )}
              >
                <ArticleCard article={article} onDelete={() => onDelete(article._id)} />
              </motion.div>
            )
          })}
        </AnimatePresence>
      </AnimatedList>
    </Accordion>
  )
}

```

## 📄 .tmp_backups/client/components/DataView.jsx.bak
*Lines: 234, Size: 7.07 KB*

```
// apps/client/src/components/DataView.jsx (version 6.5.0)
'use client'

import { useMemo, useRef, Suspense } from 'react'
import { useSearchParams } from 'next/navigation'
import {
  useInfiniteQuery,
  useMutation,
  useQueryClient,
  useQuery,
} from '@tanstack/react-query'
import { ViewHeader } from '@/components/ViewHeader'
import { LoadingOverlay, SkeletonCard } from '@headlines/ui'
import { InfiniteScrollLoader } from '@/components/InfiniteScrollLoader'
import { toast } from 'sonner'
import { useAuth } from '@headlines/auth/src/useAuth.js'
import useAppStore from '@/store/use-app-store'
import { SearchX } from 'lucide-react'
import {
  getArticles,
  getTotalArticleCount,
  deleteArticle,
  getEvents,
  getTotalEventCount,
  deleteEvent,
  getOpportunities,
  getTotalOpportunitiesCount,
  deleteOpportunity,
  updateUserInteraction,
} from '@headlines/data-access'
import { EventList } from './EventList'
import { ArticleList } from './ArticleList'
import { OpportunityListWrapper } from './OpportunityListWrapper'

const componentMap = {
  'event-list': EventList,
  'article-list': ArticleList,
  'opportunity-list': OpportunityListWrapper,
}

const SkeletonLoader = ({ count = 5 }) => (
  <div className="max-w-5xl mx-auto space-y-4 px-4 sm:px-0">
    {Array.from({ length: count }).map((_, i) => (
      <SkeletonCard key={i} />
    ))}
  </div>
)

const fnMap = {
  articles: {
    getFn: getArticles,
    getCountFn: getTotalArticleCount,
    deleteFn: deleteArticle,
  },
  events: { getFn: getEvents, getCountFn: getTotalEventCount, deleteFn: deleteEvent },
  opportunities: {
    getFn: getOpportunities,
    getCountFn: getTotalOpportunitiesCount,
    deleteFn: deleteOpportunity,
  },
}

export function DataView({
  viewTitle,
  baseSubtitle,
  sortOptions,
  queryKeyPrefix,
  listComponentKey,
  initialData,
  filters,
  allCountries,
}) {
  const ListComponent = componentMap[listComponentKey]
  const searchParams = useSearchParams()
  const queryClient = useQueryClient()
  const { user } = useAuth()
  const globalCountryFilter = useAppStore((state) => state.globalCountryFilter)

  const { getFn, getCountFn } = fnMap[queryKeyPrefix]

  const q = searchParams.get('q') || ''
  const sort = searchParams.get('sort') || 'date_desc'
  const favoritesOnly = searchParams.get('favorites') === 'true'

  const memoizedSearchParams = useMemo(
    () => ({ q, sort, favoritesOnly, ...filters }),
    [q, sort, favoritesOnly, filters]
  )
  const listQueryKey = useMemo(
    () => [queryKeyPrefix, memoizedSearchParams, globalCountryFilter],
    [queryKeyPrefix, memoizedSearchParams, globalCountryFilter]
  )

  const { data: count, isLoading: isCountLoading } = useQuery({
    queryKey: [`${queryKeyPrefix}-count`, memoizedSearchParams, globalCountryFilter],
    queryFn: () =>
      getCountFn({ filters: { q, country: globalCountryFilter, ...filters } }),
    enabled: !!user,
  })

  const { data, fetchNextPage, hasNextPage, isFetching, isError } = useInfiniteQuery({
    queryKey: listQueryKey,
    queryFn: ({ pageParam = 1 }) =>
      getFn({
        page: pageParam,
        filters: { q, country: globalCountryFilter, ...filters },
        sort,
      }),
    getNextPageParam: (lastPage, allPages) =>
      lastPage?.length > 0 ? allPages.length + 1 : undefined,
    initialPageParam: 1,
    initialData: { pages: [initialData || []], pageParams: [1] },
    enabled: !!user,
  })

  const { mutate: performInteraction } = useMutation({
    mutationFn: (variables) => updateUserInteraction(variables),
    onMutate: async ({ itemId, action }) => {
      await queryClient.cancelQueries({ queryKey: listQueryKey })
      const previousData = queryClient.getQueryData(listQueryKey)

      queryClient.setQueryData(listQueryKey, (old) => {
        if (!old) return old
        if (action === 'discard') {
          return {
            ...old,
            pages: old.pages.map((p) => p.filter((item) => item._id !== itemId)),
          }
        }
        if (action === 'favorite' || action === 'unfavorite') {
          const isFavorited = action === 'favorite'
          return {
            ...old,
            pages: old.pages.map((page) =>
              page.map((item) => (item._id === itemId ? { ...item, isFavorited } : item))
            ),
          }
        }
        return old
      })
      return { previousData }
    },
    onError: (err, variables, context) => {
      toast.error('Action failed. Restoring data.')
      if (context?.previousData)
        queryClient.setQueryData(listQueryKey, context.previousData)
    },
    onSuccess: (data, { action }) => {
      toast.success(`Item ${action}ed.`)
      queryClient.invalidateQueries({ queryKey: [`${queryKeyPrefix}-count`] })
    },
  })

  const handleDelete = (variables) => {
    if (user) {
      const itemType = queryKeyPrefix.slice(0, -1) // 'articles' -> 'article'
      performInteraction({
        ...variables,
        itemType,
        userId: user.userId,
        action: 'discard',
      })
    }
  }

  const handleFavoriteToggle = (itemId, isFavorited) => {
    if (user)
      performInteraction({
        userId: user.userId,
        itemId,
        itemType: 'event',
        action: isFavorited ? 'favorite' : 'unfavorite',
      })
  }

  const items = useMemo(() => data?.pages.flat() ?? [], [data])
  const showLoadingOverlay = isFetching && !items.length

  const userFavoritedIds = useMemo(
    () => new Set(user?.favoritedItems?.events || []),
    [user]
  )

  return (
    <>
      <ViewHeader
        title={viewTitle}
        baseSubtitle={baseSubtitle}
        count={count}
        isCountLoading={isCountLoading}
        sortOptions={sortOptions}
        allCountries={allCountries}
        filters={filters}
      />
      <Suspense fallback={<SkeletonLoader />}>
        <div className="max-w-5xl mx-auto space-y-6 sm:px-0 -mx-4 px-4">
          <LoadingOverlay
            isLoading={showLoadingOverlay}
            text={`Fetching ${viewTitle}...`}
          />
          {!showLoadingOverlay && items.length > 0 ? (
            <>
              <ListComponent
                items={items}
                onDelete={handleDelete}
                onFavoriteToggle={handleFavoriteToggle}
                userFavoritedIds={userFavoritedIds}
              />
              <InfiniteScrollLoader onLoadMore={fetchNextPage} hasMore={hasNextPage} />
            </>
          ) : (
            !isFetching && (
              <div className="text-center text-gray-500 py-20 px-4 rounded-lg bg-black/20 border border-white/10 flex flex-col items-center justify-center">
                <SearchX className="h-16 w-16 text-slate-700" />
                <p className="mt-4 text-lg font-semibold text-slate-300">
                  No {baseSubtitle} found.
                </p>
                <p className="mt-2 text-sm text-slate-500">
                  Try adjusting your search or filters.
                </p>
              </div>
            )
          )}
          {isError && (
            <div className="text-center text-red-400 py-20">
              <p>Failed to load {baseSubtitle}. Please try again later.</p>
            </div>
          )}
        </div>
      </Suspense>
    </>
  )
}

```

## 📄 .tmp_backups/client/components/EventList.jsx.bak
*Lines: 45, Size: 1.68 KB*

```
// apps/client/src/components/EventList.jsx (version 5.1.0)
import { Accordion } from '@headlines/ui'
import { SynthesizedEventCard } from '@/components/SynthesizedEventCard'
import { AnimatePresence, motion } from 'framer-motion'
import { AnimatedList, itemVariants } from './AnimatedList'
import { cn } from '@headlines/utils'

export const EventList = ({ items, onDelete, onFavoriteToggle, userFavoritedIds }) => {
  return (
    <Accordion type="single" collapsible>
      <AnimatedList className="w-full space-y-4">
        <AnimatePresence>
          {items.map((event) => {
            const isHighRelevance = event.highest_relevance_score > 69
            const isFavorited = userFavoritedIds.has(event._id)
            return (
              <motion.div
                key={event.event_key}
                variants={itemVariants}
                exit={itemVariants.exit}
                layout
                whileHover={{ y: -2 }}
                whileTap={{ scale: 0.98 }}
                className={cn(
                  'rounded-xl bg-gradient-to-br from-slate-900 to-slate-800/60 shadow-lg shadow-black/40 border border-slate-700',
                  isHighRelevance && 'card-glow',
                  isFavorited &&
                    'bg-gradient-to-br from-yellow-900/50 to-slate-800/60 border-yellow-700/50'
                )}
              >
                <SynthesizedEventCard
                  event={event}
                  onDelete={onDelete}
                  onFavoriteToggle={onFavoriteToggle}
                  isFavorited={isFavorited}
                />
              </motion.div>
            )
          })}
        </AnimatePresence>
      </AnimatedList>
    </Accordion>
  )
}

```

## 📄 .tmp_backups/client/components/OpportunityListWrapper.jsx.bak
*Lines: 34, Size: 1.03 KB*

```
// apps/client/src/components/OpportunityListWrapper.jsx
'use client'

import { OpportunityCard } from './OpportunityCard'
import { AnimatedList, itemVariants } from './AnimatedList'
import { AnimatePresence, motion } from 'framer-motion'
import { cn } from '@headlines/utils'

export const OpportunityListWrapper = ({ items, onDelete }) => {
  return (
    <AnimatedList className="w-full space-y-4">
      <AnimatePresence>
        {items.map((opportunity) => {
          const isPremium = opportunity.likelyMMDollarWealth > 49
          return (
            <motion.div
              key={opportunity._id}
              variants={itemVariants}
              exit={itemVariants.exit}
              layout
              className={cn(isPremium && 'impatient-wobble')}
            >
              <OpportunityCard
                opportunity={opportunity}
                onDelete={() => onDelete({ opportunityId: opportunity._id })}
              />
            </motion.div>
          )
        })}
      </AnimatePresence>
    </AnimatedList>
  )
}

```

## 📄 .tmp_backups/client/components/SynthesizedEventCard.jsx.bak
*Lines: 61, Size: 2.46 KB*

```
// apps/client/src/components/SynthesizedEventCard.jsx (version 11.0.0)
'use client'

import { useState, useTransition } from 'react'
import { useRouter } from 'next/navigation'
import { AccordionContent, AccordionItem } from '@headlines/ui'
import { DeletionConfirmationDialog } from './DeletionConfirmationDialog'
import useAppStore from '@/store/use-app-store'
import { SwipeToDelete } from './swipe/SwipeToDelete'
import { EventCardDesktop } from './events/EventCardDesktop'
import { EventCardMobile } from './events/EventCardMobile'
import { EventCardDetails } from './events/EventCardDetails'
import { updateUserInteraction } from '@headlines/data-access'
import { toast } from 'sonner'
import { useAuth } from '@headlines/auth/src/useAuth.js'

export const SynthesizedEventCard = ({ event, onDelete, onFavoriteToggle, isFavorited }) => {
  const [isPending, startTransition] = useTransition()
  const setChatContextPrompt = useAppStore((state) => state.setChatContextPrompt)
  const router = useRouter()
  const { user } = useAuth();
  
  const performDelete = () => {
    startTransition(() => {
      // CORRECTIVE ACTION: Standardized the delete payload to use `itemId`.
      onDelete({ itemId: event._id })
    })
  }
  
  const handleChatAboutEvent = (e) => {
    e.stopPropagation()
    const prompt = `Tell me more about the event: "${event.synthesized_headline}". What are the key implications?`
    setChatContextPrompt(prompt)
    router.push('/chat')
  }

  const handleFavorite = (e) => {
      e.stopPropagation();
      onFavoriteToggle(event._id, !isFavorited);
  }

  return (
    <div className="relative w-full">
      <AccordionItem
        value={event.event_key}
        className={`relative border-none rounded-xl overflow-hidden transition-all duration-300 ${isPending ? 'opacity-50' : ''}`}
      >
        <SwipeToDelete onDelete={performDelete}>
          <div className="p-4 bg-transparent relative z-10">
            <EventCardMobile event={event} onChat={handleChatAboutEvent} onDelete={performDelete} onFavorite={handleFavorite} isFavorited={isFavorited} isPending={isPending} />
            <EventCardDesktop event={event} onChat={handleChatAboutEvent} onDelete={performDelete} onFavorite={handleFavorite} isFavorited={isFavorited} isPending={isPending} />
          </div>
        </SwipeToDelete>
        <AccordionContent className="p-4 pt-4 bg-slate-900/50">
          <EventCardDetails event={event} />
        </AccordionContent>
      </AccordionItem>
    </div>
  )
}

```

## 📄 .tmp_backups/client/components/UploadView.jsx.bak
*Lines: 162, Size: 7.85 KB*

```
// src/components/UploadView.jsx (version 1.1)
"use client";

import { useState } from 'react';
import { toast } from 'sonner';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@headlines/ui';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from '@headlines/ui';
import { Label } from '@headlines/ui';
import { Input } from '@headlines/ui';
import { Button } from '@headlines/ui';
import { Loader2, Wand2, UploadCloud } from 'lucide-react';
import { scrapeAndExtractWithAI } from '@/actions/extract';
import { addKnowledge } from '@/actions/knowledge';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

export function UploadView() {
    const [url, setUrl] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [extractedData, setExtractedData] = useState(null);

    const handleScrape = async () => {
        if (!url || !url.startsWith('http')) {
            toast.error("Please enter a valid, complete URL (e.g., https://...).");
            return;
        }
        setIsLoading(true);
        const result = await scrapeAndExtractWithAI(url);
        setIsLoading(false);

        if (result.success) {
            setExtractedData({
                ...result.data,
                link: url,
            });
            setIsModalOpen(true);
            toast.success("AI Analyst finished extraction!");
        } else {
            toast.error(`Extraction failed: ${result.error}`);
        }
    };

    const handleSave = async () => {
        if (!extractedData.country || !extractedData.publication) {
            toast.error("Please specify both the country and publication before saving.");
            return;
        }

        setIsLoading(true);
        const result = await addKnowledge({
            headline: extractedData.headline,
            business_summary: extractedData.business_summary,
            source: extractedData.publication,
            country: extractedData.country,
            link: extractedData.link,
        });
        setIsLoading(false);
        setIsModalOpen(false);

        if (result.success) {
            toast.success(result.message);
            setUrl('');
            setExtractedData(null);
        } else {
            toast.error(`Failed to save: ${result.message}`);
        }
    };

    return (
        <>
            <div className="max-w-4xl mx-auto">
                <Card className="bg-black/20 backdrop-blur-sm border border-white/10 shadow-2xl shadow-black/30">
                    <CardHeader className="p-8">
                        <CardTitle className="text-2xl">Upload New Knowledge</CardTitle>
                        <CardDescription>
                            Provide an article URL. A specialized AI Analyst will extract the business-critical intelligence for you to review and add to the knowledge base.
                        </CardDescription>
                    </CardHeader>
                    <CardContent className="p-8 pt-0">
                        <div className="space-y-2">
                            <Label htmlFor="url" className="text-lg font-semibold">Article URL</Label>
                            <div className="flex gap-4">
                                <Input
                                    id="url"
                                    placeholder="https://example.com/article"
                                    value={url}
                                    onChange={(e) => setUrl(e.target.value)}
                                    disabled={isLoading}
                                    onKeyDown={(e) => e.key === 'Enter' && handleScrape()}
                                    className="h-12 text-base"
                                />
                                <Button onClick={handleScrape} disabled={isLoading} size="lg" className="h-12">
                                    {isLoading ? <Loader2 className="mr-2 h-5 w-5 animate-spin" /> : <Wand2 className="mr-2 h-5 w-5" />}
                                    Analyze & Extract
                                </Button>
                            </div>
                        </div>
                    </CardContent>
                </Card>
            </div>

            <Dialog open={isModalOpen} onOpenChange={setIsModalOpen}>
                <DialogContent className="sm:max-w-4xl w-[95vw] bg-slate-900 border-slate-700 p-8">
                    <DialogHeader>
                        <DialogTitle className="text-xl">Review AI Analyst's Extraction</DialogTitle>
                        <DialogDescription>
                            The AI has extracted the following intelligence. Please verify the details before adding it to the knowledge base.
                        </DialogDescription>
                    </DialogHeader>
                    <div className="space-y-6 max-h-[70vh] overflow-y-auto p-1 pr-6 custom-scrollbar">
                        <div>
                            <Label className="text-slate-400">Headline</Label>
                            <p className="font-semibold text-lg text-slate-200 mt-1">{extractedData?.headline}</p>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                             <div>
                                <Label htmlFor="modal-publication" className="text-slate-400">Publication *</Label>
                                <Input 
                                    id="modal-publication"
                                    value={extractedData?.publication || ''}
                                    onChange={(e) => setExtractedData(prev => ({...prev, publication: e.target.value}))}
                                    placeholder="e.g., The Financial Times"
                                    className="bg-slate-800 border-slate-600 mt-1 h-10"
                                />
                            </div>
                             <div>
                                <Label htmlFor="modal-country" className="text-slate-400">Country of Origin *</Label>
                                <Input 
                                    id="modal-country"
                                    value={extractedData?.country || ''}
                                    onChange={(e) => setExtractedData(prev => ({...prev, country: e.target.value}))}
                                    placeholder="e.g., Denmark"
                                    className="bg-slate-800 border-slate-600 mt-1 h-10"
                                />
                            </div>
                        </div>
                        <div>
                            <Label className="text-slate-400">Business Summary</Label>
                            <div className="p-4 mt-1 rounded-md bg-slate-800/50 border border-slate-700 text-sm text-slate-300 max-h-72 overflow-y-auto custom-scrollbar">
                                <div className="prose prose-sm prose-invert prose-p:my-2">
                                    <ReactMarkdown remarkPlugins={[remarkGfm]}>
                                        {extractedData?.business_summary}
                                    </ReactMarkdown>
                                </div>
                            </div>
                        </div>
                    </div>
                    <DialogFooter className="pt-6">
                        <Button variant="outline" onClick={() => setIsModalOpen(false)} disabled={isLoading}>Cancel</Button>
                        <Button onClick={handleSave} disabled={isLoading}>
                            {isLoading ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <UploadCloud className="mr-2 h-4 w-4" />}
                            Add to Knowledge Base
                        </Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>
        </>
    );
}

```

## 📄 .tmp_backups/client/components/ViewHeader.jsx.bak
*Lines: 164, Size: 5.51 KB*

```
// apps/client/src/components/ViewHeader.jsx (version 2.6.0)
'use client'

import { useRouter, useSearchParams, usePathname } from 'next/navigation'
import { useState, useEffect } from 'react'
import { useDebounce } from '@headlines/utils'
import {
  Input,
  Button,
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@headlines/ui'
import { Search, Clock, BarChart, ArrowDownUp, Mail } from 'lucide-react'
import { cn } from '@headlines/utils'

const iconMap = {
  clock: Clock,
  relevance: BarChart,
  size: ArrowDownUp,
}

export function ViewHeader({ title, baseSubtitle, count, isCountLoading, sortOptions, allCountries = [], filters = {} }) {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  const currentSort = searchParams.get('sort') || 'date_desc'
  const [searchTerm, setSearchTerm] = useState(searchParams.get('q') || '')
  const debouncedSearchTerm = useDebounce(searchTerm, 500)

  useEffect(() => {
    const params = new URLSearchParams(searchParams.toString())
    if (debouncedSearchTerm) {
      params.set('q', debouncedSearchTerm)
    } else {
      params.delete('q')
    }
    router.replace(`?${params.toString()}`, { scroll: false })
  }, [debouncedSearchTerm, router, searchParams])

  const handleSortChange = (newSort) => {
    const params = new URLSearchParams(searchParams.toString())
    if (newSort === 'date_desc') {
      params.delete('sort')
    } else {
      params.set('sort', newSort)
    }
    router.push(`?${params.toString()}`, { scroll: false })
  }

  const handleFilterChange = (key, value) => {
    const params = new URLSearchParams(searchParams.toString())
    if (value === 'all' || value === false || value === '') {
      params.delete(key)
    } else {
      params.set(key, value)
    }
    params.set('page', '1')
    router.push(`${pathname}?${params.toString()}`, { scroll: false })
  }

  const subtitleText = isCountLoading
    ? 'Calculating...'
    : count != null ? `${count.toLocaleString()} ${baseSubtitle}` : `...`
  
  const currentCountry = filters.country || 'all'
  const withEmailOnly = filters.withEmail === true

  return (
    <div className="flex flex-col items-center justify-center text-center mb-8 space-y-6 max-w-5xl mx-auto">
      <div>
        <h2 className="text-3xl font-bold tracking-tight text-slate-100">{title}</h2>
        <p className="text-slate-400 mt-1 transition-colors">{subtitleText}</p>
      </div>

      <div className="w-full flex flex-col sm:flex-row items-center gap-4">
        {/* Country Filter */}
        <Select
          value={currentCountry}
          onValueChange={(value) => handleFilterChange('country', value)}
        >
          <SelectTrigger className="w-full sm:w-[200px] h-12 bg-slate-900/80 border-slate-700">
            <SelectValue placeholder="Filter by country..." />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Countries</SelectItem>
            {allCountries.map((country) => (
              <SelectItem key={country} value={country}>
                {country}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>

        {/* Search Input */}
        <div className="relative flex-grow w-full">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-slate-500" />
          <Input
            id="search"
            placeholder="Search by name, company, or keyword..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="bg-slate-900/80 border-slate-700 h-12 pl-10"
          />
        </div>

        {/* Action Buttons */}
        <div className="flex items-center gap-2">
          <TooltipProvider>
            {sortOptions.map((option) => {
              const IconComponent = iconMap[option.icon] || Clock
              return (
                <Tooltip key={option.value}>
                  <TooltipTrigger asChild>
                    <Button
                      variant="outline"
                      size="icon"
                      onClick={() => handleSortChange(option.value)}
                      className={cn(
                        'h-12 w-12',
                        currentSort === option.value && 'bg-blue-500/20 text-blue-300'
                      )}
                      aria-label={option.tooltip}
                    >
                      <IconComponent className="h-5 w-5" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>{option.tooltip}</TooltipContent>
                </Tooltip>
              )
            })}
             <Tooltip>
                <TooltipTrigger asChild>
                    <Button
                      variant="outline"
                      size="icon"
                      onClick={() => handleFilterChange('withEmail', !withEmailOnly)}
                      className={cn(
                        'h-12 w-12',
                        withEmailOnly && 'bg-blue-500/20 text-blue-300'
                      )}
                      aria-label="Filter by email"
                    >
                      <Mail className="h-5 w-5" />
                    </Button>
                </TooltipTrigger>
                <TooltipContent>
                    {withEmailOnly ? "Show all opportunities" : "Show only opportunities with email"}
                </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </div>
      </div>
    </div>
  )
}

```

## 📄 .tmp_backups/client/components/events/EventCardDesktop.jsx.bak
*Lines: 167, Size: 6.11 KB*

```
// apps/client/src/components/events/EventCardDesktop.jsx (version 1.4.0)
'use client'

import { Badge } from '@headlines/ui'
import { Button } from '@headlines/ui'
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@headlines/ui'
import {
  Trash2,
  MessageSquarePlus,
  Users,
  Database,
  Globe,
  BookOpen,
  Star,
  Sparkles,
} from 'lucide-react'
import { getCountryFlag } from '@headlines/utils'
import Image from 'next/image'

const getRelevanceBadgeClass = (score) => {
  if (score >= 90)
    return 'bg-red-500/20 text-red-300 border border-red-500/30 shadow-lg shadow-red-500/10'
  if (score >= 75)
    return 'bg-blue-500/20 text-blue-300 border border-blue-500/30 shadow-lg shadow-blue-500/10'
  return 'bg-slate-500/20 text-slate-300 border border-slate-500/30'
}

const EnrichmentSourceIcons = ({ sources = [] }) => {
  const iconMap = {
    rag_db: { icon: Database, tooltip: 'Enriched with Historical Data' },
    wikipedia: { icon: Globe, tooltip: 'Enriched with Wikipedia' },
    news_api: { icon: BookOpen, tooltip: 'Enriched with NewsAPI' },
  }
  return (
    <div className="flex items-center gap-2">
      {sources.map((sourceKey) => {
        const IconComponent = iconMap[sourceKey]?.icon
        if (!IconComponent) return null
        return (
          <Tooltip key={sourceKey}>
            <TooltipTrigger>
              <IconComponent className="h-4 w-4 text-slate-500" />
            </TooltipTrigger>
            <TooltipContent>
              <p>{iconMap[sourceKey].tooltip}</p>
            </TooltipContent>
          </Tooltip>
        )
      })}
    </div>
  )
}

export function EventCardDesktop({
  event,
  onChat,
  onDelete,
  onFavorite,
  isFavorited,
  isPending,
}) {
  if (!event) return null
  const flag = getCountryFlag(event.country)
  const primaryImageUrl = event.source_articles?.find((a) => a.imageUrl)?.imageUrl

  return (
    <div className="hidden sm:block">
      <TooltipProvider delayDuration={100}>
        <div className="flex items-start gap-6">
          <div className="flex flex-col items-center shrink-0">
            <Badge
              className={`text-xl font-bold px-4 py-2 ${getRelevanceBadgeClass(event.highest_relevance_score)}`}
            >
              {event.highest_relevance_score}
            </Badge>
            <span className="text-xs text-slate-500 mt-1">Score</span>
          </div>
          <div className="flex-grow min-w-0 pr-20">
            <h3 className="font-serif font-bold text-xl text-slate-100 mb-2">
              <span className="text-2xl mr-3 align-middle">{flag}</span>
              {event.synthesized_headline}
            </h3>
            <p className="text-slate-300 leading-relaxed">{event.synthesized_summary}</p>
            {event.advisorSummary && (
              <div className="mt-3 flex items-start gap-2 text-sm text-amber-300/90 p-2 bg-amber-500/10 rounded-md border border-amber-500/20">
                <Sparkles className="h-4 w-4 mt-0.5 flex-shrink-0" />
                <p className="italic">"{event.advisorSummary}"</p>
              </div>
            )}
          </div>
          {primaryImageUrl && (
            <div className="relative h-24 w-24 rounded-lg overflow-hidden flex-shrink-0">
              <Image
                src={primaryImageUrl}
                alt={event.synthesized_headline}
                fill
                className="object-cover"
                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
              />
            </div>
          )}
          <div className="absolute top-4 right-4 z-10 flex gap-1">
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={onChat}
                  className="text-slate-400 hover:text-blue-400 bg-black/20 hover:bg-blue-500/20 h-8 w-8"
                >
                  <MessageSquarePlus className="h-4 w-4" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>Ask AI about this event</TooltipContent>
            </Tooltip>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={onFavorite}
                  className={`bg-black/20 h-8 w-8 ${isFavorited ? 'text-yellow-400 hover:text-yellow-300 hover:bg-yellow-500/20' : 'text-slate-400 hover:text-yellow-400 hover:bg-yellow-500/20'}`}
                >
                  <Star className="h-4 w-4" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>{isFavorited ? 'Unfavorite' : 'Favorite'}</TooltipContent>
            </Tooltip>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  disabled={isPending}
                  onClick={onDelete}
                  className="text-slate-400 hover:text-red-400 bg-black/20 hover:bg-red-500/20 h-8 w-8"
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>Delete Event</TooltipContent>
            </Tooltip>
          </div>
        </div>
        <div className="mt-4 pt-4 border-t border-slate-800/50 flex flex-col sm:flex-row justify-between items-start gap-4">
          <div className="flex items-center gap-4">
            {event.key_individuals && event.key_individuals.length > 0 && (
              <div className="flex items-center gap-2 text-slate-400">
                <Users className="h-4 w-4 text-slate-500" />
                <span className="text-sm font-medium text-slate-300">
                  {event.key_individuals.length} Key Individual(s)
                </span>
              </div>
            )}
            <EnrichmentSourceIcons sources={event.enrichmentSources} />
          </div>
          {event.ai_assessment_reason && (
            <p className="text-xs text-slate-500 italic sm:text-right flex-grow">
              {event.ai_assessment_reason}
            </p>
          )}
        </div>
      </TooltipProvider>
    </div>
  )
}

```

## 📄 .tmp_backups/client/components/events/EventCardMobile.jsx.bak
*Lines: 126, Size: 4.51 KB*

```
// apps/client/src/components/events/EventCardMobile.jsx (version 1.3)
'use client'

import { Badge } from '@headlines/ui'
import { Button } from '@headlines/ui'
import { Trash2, MessageSquarePlus, Users, Star, Sparkles } from 'lucide-react'
import { getCountryFlag } from '@headlines/utils'
import { cn } from '@headlines/utils'

const getRelevanceBadgeClass = (score) => {
  if (score >= 90) return 'bg-red-500/20 text-red-300 border border-red-500/30'
  if (score >= 75) return 'bg-blue-500/20 text-blue-300 border border-blue-500/30'
  return 'bg-slate-500/20 text-slate-300 border border-slate-500/30'
}

export function EventCardMobile({
  event,
  onChat,
  onDelete,
  onFavorite,
  isFavorited,
  isPending,
}) {
  if (!event) return null
  const flag = getCountryFlag(event.country)
  const primaryImageUrl = event.source_articles?.find((a) => a.imageUrl)?.imageUrl

  return (
    <div className="sm:hidden">
      <div
        className={cn(
          'relative rounded-lg -m-4 mb-0 p-4',
          primaryImageUrl && 'min-h-[200px] flex flex-col justify-end'
        )}
        style={primaryImageUrl ? { backgroundImage: `url(${primaryImageUrl})` } : {}}
      >
        {primaryImageUrl && (
          <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-black/60 to-transparent z-0 rounded-lg" />
        )}

        <div className="relative z-10">
          <div className="flex justify-between items-start gap-2 mb-2">
            <div className="flex items-center gap-2 min-w-0">
              <Badge
                className={`text-sm font-bold px-2 py-0.5 ${getRelevanceBadgeClass(
                  event.highest_relevance_score
                )}`}
              >
                {event.highest_relevance_score}
              </Badge>
            </div>
            <div className="flex flex-col items-center gap-1">
              <Button
                variant="ghost"
                size="icon"
                onClick={onChat}
                className="text-slate-300 hover:text-blue-400 bg-black/20 hover:bg-blue-500/20 h-8 w-8"
              >
                <MessageSquarePlus className="h-4 w-4" />
              </Button>
              <Button
                variant="ghost"
                size="icon"
                onClick={onFavorite}
                className={`bg-black/20 h-8 w-8 ${isFavorited ? 'text-yellow-400 hover:text-yellow-300' : 'text-slate-300 hover:text-yellow-400'}`}
              >
                <Star className="h-4 w-4" />
              </Button>
              <Button
                variant="ghost"
                size="icon"
                disabled={isPending}
                onClick={onDelete}
                className="text-slate-300 hover:text-red-400 bg-black/20 hover:bg-red-500/20 h-8 w-8"
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </div>
          </div>
          <h3
            className={cn(
              'font-serif font-bold text-lg line-clamp-3',
              primaryImageUrl ? 'text-white drop-shadow-lg' : 'text-slate-100'
            )}
          >
            <span className="text-xl mr-2 align-middle">{flag}</span>
            {event.synthesized_headline}
          </h3>
        </div>
      </div>

      <div
        className={cn(
          'pt-4',
          primaryImageUrl && 'bg-slate-900 -m-4 mt-0 p-4 rounded-b-xl'
        )}
      >
        <p className="text-sm text-slate-300 leading-relaxed">
          {event.synthesized_summary}
        </p>
        {event.advisorSummary && (
          <div className="mt-3 flex items-start gap-2 text-sm text-amber-300/90 p-2 bg-amber-500/10 rounded-md border border-amber-500/20">
            <Sparkles className="h-4 w-4 mt-0.5 flex-shrink-0" />
            <p className="italic">"{event.advisorSummary}"</p>
          </div>
        )}
        <div className="mt-4 pt-4 border-t border-slate-800/50 flex flex-col justify-between items-start gap-4">
          {event.key_individuals && event.key_individuals.length > 0 && (
            <div className="flex items-start gap-3 text-slate-400">
              <Users className="h-5 w-5 mt-0.5 shrink-0 text-slate-500" />
              <p className="text-sm font-medium text-slate-300">
                {event.key_individuals.length} Key Individual(s) Identified
              </p>
            </div>
          )}
          {event.ai_assessment_reason && (
            <p className="text-xs text-slate-500 italic sm:text-right flex-grow">
              {event.ai_assessment_reason}
            </p>
          )}
        </div>
      </div>
    </div>
  )
}

```

## 📄 .tmp_backups/client/eslint.config.mjs.bak
*Lines: 17, Size: 401 Bytes*

```
// apps/client/eslint.config.mjs (version 2.1.0)
import nextPlugin from "@next/eslint-plugin-next";
import eslintConfigNext from "eslint-config-next";

export default [
  {
    ...eslintConfigNext, // The recommended base config from Next.js
  },
  {
    // You can add your custom rules or overrides here if needed
    // For example:
    // rules: {
    //   'no-console': 'warn',
    // },
  },
];

```

## 📄 .tmp_backups/client/src/app/main/opportunities/[opportunityId]/page.js.bak
*Lines: 131, Size: 4.59 KB*

```
// This is a new directory and file.
'use server'

import { getOpportunityDetails } from '@headlines/data-access'
import { notFound } from 'next/navigation'
import Link from 'next/link'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@headlines/ui'
import { Button } from '@headlines/ui'
import { Badge } from '@headlines/ui'
import { ArrowLeft, User, MapPin, Briefcase, Mail, Zap, ExternalLink } from 'lucide-react'
import { format } from 'date-fns'

function TimelineItem({ event, isLast }) {
  return (
    <div className="flex gap-4">
      <div className="flex flex-col items-center">
        <div className="w-3 h-3 bg-blue-500 rounded-full ring-4 ring-slate-800"></div>
        {!isLast && <div className="flex-grow w-px bg-slate-700"></div>}
      </div>
      <div className="flex-grow pb-8">
        <p className="text-xs text-slate-400">
          {format(new Date(event.createdAt), 'MMMM d, yyyy')}
        </p>
        <h3 className="font-semibold text-slate-100 mt-1">
          {event.synthesized_headline}
        </h3>
        <p className="text-sm text-slate-400 mt-1">{event.synthesized_summary}</p>
        <div className="mt-2 flex flex-wrap gap-2">
          {event.source_articles.map((article) => (
            <a
              href={article.link}
              target="_blank"
              rel="noopener noreferrer"
              key={article.link}
            >
              <Badge variant="secondary" className="hover:bg-slate-700">
                {article.newspaper}
                <ExternalLink className="h-3 w-3 ml-1.5" />
              </Badge>
            </a>
          ))}
        </div>
      </div>
    </div>
  )
}

export default async function OpportunityDossierPage({ params }) {
  const { opportunityId } = params
  const { success, data: opportunity, error } = await getOpportunityDetails(opportunityId)

  if (!success || !opportunity) {
    notFound()
  }

  const { contactDetails } = opportunity

  return (
    <div className="max-w-4xl mx-auto">
      <Button asChild variant="ghost" className="mb-4">
        <Link href="/opportunities">
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Opportunities
        </Link>
      </Button>
      <Card className="bg-slate-900/50 border-slate-700/80">
        <CardHeader>
          <div className="flex justify-between items-start">
            <div>
              <CardTitle className="text-3xl font-bold flex items-center gap-3">
                <User className="h-8 w-8 text-slate-400" />
                {opportunity.reachOutTo}
              </CardTitle>
              <CardDescription className="mt-2 text-base">
                {contactDetails?.role && contactDetails?.company && (
                  <span className="flex items-center gap-2">
                    <Briefcase className="h-4 w-4" />
                    {contactDetails.role} at <strong>{contactDetails.company}</strong>
                  </span>
                )}
              </CardDescription>
            </div>
            {opportunity.likelyMMDollarWealth > 0 && (
              <Badge
                variant="outline"
                className="text-lg border-green-500/50 text-green-300"
              >
                Est. ${opportunity.likelyMMDollarWealth}M
              </Badge>
            )}
          </div>
          <div className="flex flex-wrap gap-x-6 gap-y-2 pt-4 text-sm text-slate-300">
            {opportunity.basedIn && (
              <span className="flex items-center gap-2">
                <MapPin className="h-4 w-4 text-slate-500" />
                {opportunity.basedIn}
              </span>
            )}
            {contactDetails?.email && (
              <a
                href={`mailto:${contactDetails.email}`}
                className="flex items-center gap-2 text-blue-400 hover:underline"
              >
                <Mail className="h-4 w-4 text-slate-500" />
                {contactDetails.email}
              </a>
            )}
          </div>
        </CardHeader>
        <CardContent>
          <div className="border-t border-slate-700 pt-6">
            <h3 className="text-lg font-semibold flex items-center gap-2 mb-4">
              <Zap className="h-5 w-5 text-blue-400" />
              Event Timeline
            </h3>
            <div className="relative">
              {(opportunity.events || []).map((event, index) => (
                <TimelineItem
                  key={event._id}
                  event={event}
                  isLast={index === opportunity.events.length - 1}
                />
              ))}
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

```

## 📄 .tmp_backups/client/src/components/OpportunityCard.jsx.bak
*Lines: 188, Size: 7.1 KB*

```
// apps/client/src/components/OpportunityCard.jsx (version 13.1.0)
'use client'

import { useState, useTransition } from 'react'
import { Card, CardContent } from '@headlines/ui'
import { Button } from '@headlines/ui'
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@headlines/ui'
import {
  User,
  Briefcase,
  MapPin,
  Trash2,
  Mail,
  Zap,
  MessageSquare,
  ArrowRight,
  Users,
} from 'lucide-react'
import { Badge } from '@headlines/ui'
import { SwipeToDelete } from './swipe/SwipeToDelete'
import { cn } from '@headlines/utils'
import { EventContextDialog } from './EventContextDialog'
import { DeletionConfirmationDialog } from './DeletionConfirmationDialog'
import useAppStore from '@/store/use-app-store'
import { toast } from 'sonner'
import Link from 'next/link'

export function OpportunityCard({ opportunity, onDelete, isDeleting }) {
  const [isEventDialogOpen, setIsEventDialogOpen] = useState(false)
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false)

  const skipConfirmation = useAppStore(
    (state) => state.deletePreferences.skipOpportunityConfirmation
  )
  const setDeletePreference = useAppStore((state) => state.setDeletePreference)
  const [isPending, startTransition] = useTransition()

  const performDelete = (remember) => {
    startTransition(() => {
      onDelete()
      if (remember) {
        setDeletePreference('skipOpportunityConfirmation', true)
        toast.info("Preference saved. You won't be asked again for opportunities.")
      }
    })
  }

  const handleDeleteClick = (e) => {
    e.stopPropagation()
    if (skipConfirmation) {
      performDelete(false)
    } else {
      setIsDeleteDialogOpen(true)
    }
  }

  const sourceEvent = opportunity.sourceEventId
  const { contactDetails } = opportunity
  const isPremiumOpportunity = opportunity.likelyMMDollarWealth > 49
  const reasonsToContact = Array.isArray(opportunity.whyContact)
    ? opportunity.whyContact
    : [opportunity.whyContact]
  const relatedOpps = opportunity.relatedOpportunities || []

  return (
    <>
      <Link href={`/opportunities/${opportunity._id}`} className="block group">
        <Card
          className={cn(
            'bg-slate-900/50 border border-slate-700/80 transition-all duration-300 ease-out overflow-hidden group-hover:border-blue-500/50 group-hover:bg-slate-900',
            isPending ? 'opacity-50' : 'opacity-100',
            isPremiumOpportunity && 'card-glow impatient-wobble'
          )}
        >
          <SwipeToDelete onDelete={handleDeleteClick}>
            <CardContent className="p-4 space-y-3 bg-slate-900/50 relative z-10">
              <div className="flex justify-between items-start gap-3">
                <div className="flex-1 space-y-1">
                  <p className="font-bold text-base text-slate-100 flex items-center gap-2">
                    <User className="h-4 w-4 text-slate-400" />
                    {opportunity.reachOutTo}
                  </p>
                  {opportunity.basedIn && (
                    <p className="text-xs text-slate-400 flex items-center gap-2 pl-6">
                      <MapPin className="h-3 w-3" /> {opportunity.basedIn}
                    </p>
                  )}
                </div>
                <div className="flex items-center gap-2">
                  {opportunity.likelyMMDollarWealth > 0 && (
                    <Badge
                      variant="outline"
                      className="border-green-500/50 text-green-300"
                    >
                      ${opportunity.likelyMMDollarWealth}M
                    </Badge>
                  )}
                  <div className="opacity-0 group-hover:opacity-100 transition-opacity">
                    <ArrowRight className="h-5 w-5 text-blue-400" />
                  </div>
                </div>
              </div>

              <div className="pl-4 border-l-2 border-slate-700 space-y-3">
                <div className="text-sm text-slate-400 space-y-1">
                  {contactDetails?.role && contactDetails?.company && (
                    <p className="flex items-center gap-2">
                      <Briefcase className="h-4 w-4 text-slate-500 flex-shrink-0" />
                      <span>
                        {contactDetails.role} at <strong>{contactDetails.company}</strong>
                      </span>
                    </p>
                  )}
                  {contactDetails?.email && (
                    <a
                      href={`mailto:${contactDetails.email}`}
                      className="flex items-center gap-2 text-blue-400 hover:underline"
                    >
                      <Mail className="h-4 w-4 text-slate-500 flex-shrink-0" />{' '}
                      {contactDetails.email}
                    </a>
                  )}
                </div>
                <div className="space-y-2">
                  {reasonsToContact.slice(0, 1).map(
                    (
                      reason,
                      index // Show only the first reason
                    ) => (
                      <div
                        key={index}
                        className="flex items-start gap-2 text-sm text-slate-300 italic"
                      >
                        <MessageSquare className="h-4 w-4 mt-0.5 text-slate-500 flex-shrink-0" />
                        <p className="line-clamp-2">“{reason}”</p>
                      </div>
                    )
                  )}
                </div>
              </div>
              
              {(sourceEvent || relatedOpps.length > 0) && (
                <div className="pt-3 mt-3 border-t border-slate-700/50 space-y-2">
                  {sourceEvent && (
                    <Button
                      variant="ghost"
                      className="w-full h-auto text-left justify-start p-2 hover:bg-slate-800/50"
                      onClick={(e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        setIsEventDialogOpen(true)
                      }}
                    >
                      <Zap className="h-4 w-4 mr-3 text-blue-400 flex-shrink-0" />
                      <div className="min-w-0">
                        <p className="text-xs text-slate-400">View Parent Event:</p>
                        <p className="text-sm font-semibold text-slate-200 truncate">
                          {sourceEvent.synthesized_headline}
                        </p>
                      </div>
                    </Button>
                  )}
                </div>
              )}
            </CardContent>
          </SwipeToDelete>
        </Card>
      </Link>
      {sourceEvent && (
        <EventContextDialog
          event={sourceEvent}
          open={isEventDialogOpen}
          onOpenChange={setIsEventDialogOpen}
        />
      )}
      <DeletionConfirmationDialog
        open={isDeleteDialogOpen}
        onOpenChange={setIsDeleteDialogOpen}
        onConfirm={performDelete}
        isPending={isPending}
        itemType="opportunity"
        itemDescription={`for ${opportunity.reachOutTo}`}
        preferenceKey="skipOpportunityConfirmation"
      />
    </>
  )
}

```

## 📄 .tmp_backups/client/src/components/SynthesizedEventCard.jsx.bak
*Lines: 56, Size: 2.23 KB*

```
// apps/client/src/components/SynthesizedEventCard.jsx (version 11.0.0)
'use client'

import { useTransition } from 'react'
import { useRouter } from 'next/navigation'
import { AccordionContent, AccordionItem } from '@headlines/ui'
import useAppStore from '@/store/use-app-store'
import { SwipeToDelete } from './swipe/SwipeToDelete'
import { EventCardDesktop } from './events/EventCardDesktop'
import { EventCardMobile } from './events/EventCardMobile'
import { EventCardDetails } from './events/EventCardDetails'
import { useAuth } from '@headlines/auth/src/useAuth.js'

export const SynthesizedEventCard = ({ event, onDelete, onFavoriteToggle, isFavorited }) => {
  const [isPending, startTransition] = useTransition()
  const setChatContextPrompt = useAppStore((state) => state.setChatContextPrompt)
  const router = useRouter()
  const { user } = useAuth();
  
  const performDelete = () => {
    startTransition(() => {
      onDelete({ itemId: event._id })
    })
  }
  
  const handleChatAboutEvent = (e) => {
    e.stopPropagation()
    const prompt = `Tell me more about the event: "${event.synthesized_headline}". What are the key implications?`
    setChatContextPrompt(prompt)
    router.push('/chat')
  }

  const handleFavorite = (e) => {
      e.stopPropagation();
      onFavoriteToggle(event._id, !isFavorited);
  }

  return (
    <div className="relative w-full">
      <AccordionItem
        value={event.event_key}
        className={`relative border-none rounded-xl overflow-hidden transition-all duration-300 ${isPending ? 'opacity-50' : ''}`}
      >
        <SwipeToDelete onDelete={performDelete}>
            {/* The action buttons are now passed as props to be rendered outside the trigger */}
            <EventCardMobile event={event} onChat={handleChatAboutEvent} onDelete={performDelete} onFavorite={handleFavorite} isFavorited={isFavorited} isPending={isPending} />
            <EventCardDesktop event={event} onChat={handleChatAboutEvent} onDelete={performDelete} onFavorite={handleFavorite} isFavorited={isFavorited} isPending={isPending} />
        </SwipeToDelete>
        <AccordionContent className="p-4 pt-4 bg-slate-900/50">
          <EventCardDetails event={event} />
        </AccordionContent>
      </AccordionItem>
    </div>
  )
}

```

## 📄 .tmp_backups/client/src/components/UploadView.jsx.bak
*Lines: 163, Size: 7.95 KB*

```
// src/components/UploadView.jsx (version 1.1)
"use client";

import { useState } from 'react';
import { toast } from 'sonner';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@headlines/ui';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from '@headlines/ui';
import { Label } from '@headlines/ui';
import { Input } from '@headlines/ui';
import { Button } from '@headlines/ui';
import { Loader2, Wand2, UploadCloud } from 'lucide-react';
// CORRECTED IMPORT PATHS: Server actions now come from the @headlines/data-access package.
import { scrapeAndExtractWithAI } from '@headlines/data-access';
import { addKnowledge } from '@headlines/data-access';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

export function UploadView() {
    const [url, setUrl] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [extractedData, setExtractedData] = useState(null);

    const handleScrape = async () => {
        if (!url || !url.startsWith('http')) {
            toast.error("Please enter a valid, complete URL (e.g., https://...).");
            return;
        }
        setIsLoading(true);
        const result = await scrapeAndExtractWithAI(url);
        setIsLoading(false);

        if (result.success) {
            setExtractedData({
                ...result.data,
                link: url,
            });
            setIsModalOpen(true);
            toast.success("AI Analyst finished extraction!");
        } else {
            toast.error(`Extraction failed: ${result.error}`);
        }
    };

    const handleSave = async () => {
        if (!extractedData.country || !extractedData.publication) {
            toast.error("Please specify both the country and publication before saving.");
            return;
        }

        setIsLoading(true);
        const result = await addKnowledge({
            headline: extractedData.headline,
            business_summary: extractedData.business_summary,
            source: extractedData.publication,
            country: extractedData.country,
            link: extractedData.link,
        });
        setIsLoading(false);
        setIsModalOpen(false);

        if (result.success) {
            toast.success(result.message);
            setUrl('');
            setExtractedData(null);
        } else {
            toast.error(`Failed to save: ${result.message}`);
        }
    };

    return (
        <>
            <div className="max-w-4xl mx-auto">
                <Card className="bg-black/20 backdrop-blur-sm border border-white/10 shadow-2xl shadow-black/30">
                    <CardHeader className="p-8">
                        <CardTitle className="text-2xl">Upload New Knowledge</CardTitle>
                        <CardDescription>
                            Provide an article URL. A specialized AI Analyst will extract the business-critical intelligence for you to review and add to the knowledge base.
                        </CardDescription>
                    </CardHeader>
                    <CardContent className="p-8 pt-0">
                        <div className="space-y-2">
                            <Label htmlFor="url" className="text-lg font-semibold">Article URL</Label>
                            <div className="flex gap-4">
                                <Input
                                    id="url"
                                    placeholder="https://example.com/article"
                                    value={url}
                                    onChange={(e) => setUrl(e.target.value)}
                                    disabled={isLoading}
                                    onKeyDown={(e) => e.key === 'Enter' && handleScrape()}
                                    className="h-12 text-base"
                                />
                                <Button onClick={handleScrape} disabled={isLoading} size="lg" className="h-12">
                                    {isLoading ? <Loader2 className="mr-2 h-5 w-5 animate-spin" /> : <Wand2 className="mr-2 h-5 w-5" />}
                                    Analyze & Extract
                                </Button>
                            </div>
                        </div>
                    </CardContent>
                </Card>
            </div>

            <Dialog open={isModalOpen} onOpenChange={setIsModalOpen}>
                <DialogContent className="sm:max-w-4xl w-[95vw] bg-slate-900 border-slate-700 p-8">
                    <DialogHeader>
                        <DialogTitle className="text-xl">Review AI Analyst's Extraction</DialogTitle>
                        <DialogDescription>
                            The AI has extracted the following intelligence. Please verify the details before adding it to the knowledge base.
                        </DialogDescription>
                    </DialogHeader>
                    <div className="space-y-6 max-h-[70vh] overflow-y-auto p-1 pr-6 custom-scrollbar">
                        <div>
                            <Label className="text-slate-400">Headline</Label>
                            <p className="font-semibold text-lg text-slate-200 mt-1">{extractedData?.headline}</p>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                             <div>
                                <Label htmlFor="modal-publication" className="text-slate-400">Publication *</Label>
                                <Input 
                                    id="modal-publication"
                                    value={extractedData?.publication || ''}
                                    onChange={(e) => setExtractedData(prev => ({...prev, publication: e.target.value}))}
                                    placeholder="e.g., The Financial Times"
                                    className="bg-slate-800 border-slate-600 mt-1 h-10"
                                />
                            </div>
                             <div>
                                <Label htmlFor="modal-country" className="text-slate-400">Country of Origin *</Label>
                                <Input 
                                    id="modal-country"
                                    value={extractedData?.country || ''}
                                    onChange={(e) => setExtractedData(prev => ({...prev, country: e.target.value}))}
                                    placeholder="e.g., Denmark"
                                    className="bg-slate-800 border-slate-600 mt-1 h-10"
                                />
                            </div>
                        </div>
                        <div>
                            <Label className="text-slate-400">Business Summary</Label>
                            <div className="p-4 mt-1 rounded-md bg-slate-800/50 border border-slate-700 text-sm text-slate-300 max-h-72 overflow-y-auto custom-scrollbar">
                                <div className="prose prose-sm prose-invert prose-p:my-2">
                                    <ReactMarkdown remarkPlugins={[remarkGfm]}>
                                        {extractedData?.business_summary}
                                    </ReactMarkdown>
                                </div>
                            </div>
                        </div>
                    </div>
                    <DialogFooter className="pt-6">
                        <Button variant="outline" onClick={() => setIsModalOpen(false)} disabled={isLoading}>Cancel</Button>
                        <Button onClick={handleSave} disabled={isLoading}>
                            {isLoading ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <UploadCloud className="mr-2 h-4 w-4" />}
                            Add to Knowledge Base
                        </Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>
        </>
    );
}

```

## 📄 .tmp_backups/client/src/components/ViewHeader.jsx.bak
*Lines: 177, Size: 6.23 KB*

```
// apps/client/src/components/ViewHeader.jsx (version 2.6.0)
'use client'

import { useRouter, useSearchParams, usePathname } from 'next/navigation'
import { useState, useEffect } from 'react'
import { useDebounce } from '@headlines/utils'
import {
  Input,
  Button,
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
  ScrollArea,
} from '@headlines/ui'
import { Search, Clock, BarChart, ArrowDownUp, Mail, Star } from 'lucide-react'
import { cn } from '@headlines/utils'

const iconMap = {
  clock: Clock,
  relevance: BarChart,
  size: ArrowDownUp,
}

export function ViewHeader({ title, baseSubtitle, count, isCountLoading, sortOptions, allCountries = [], filters = {} }) {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  const currentSort = searchParams.get('sort') || 'date_desc'
  const [searchTerm, setSearchTerm] = useState(searchParams.get('q') || '')
  const debouncedSearchTerm = useDebounce(searchTerm, 500)

  useEffect(() => {
    const params = new URLSearchParams(searchParams.toString())
    if (debouncedSearchTerm) {
      params.set('q', debouncedSearchTerm)
    } else {
      params.delete('q')
    }
    router.replace(`?${params.toString()}`, { scroll: false })
  }, [debouncedSearchTerm, router, searchParams])

  const handleUrlParamChange = (key, value) => {
    const params = new URLSearchParams(searchParams.toString())
    if (!value || value === 'all' || value === false) {
      params.delete(key)
    } else {
      params.set(key, value)
    }
    params.set('page', '1');
    router.push(`${pathname}?${params.toString()}`, { scroll: false })
  }

  const subtitleText = isCountLoading
    ? 'Calculating...'
    : count != null ? `${count.toLocaleString()} ${baseSubtitle}` : `...`
  
  const currentCountry = filters.country || 'all'
  const withEmailOnly = filters.withEmail === true
  const favoritesOnly = searchParams.get('favorites') === 'true'

  return (
    <div className="flex flex-col items-center justify-center text-center mb-8 space-y-6 max-w-5xl mx-auto">
      <div>
        <h2 className="text-3xl font-bold tracking-tight text-slate-100">{title}</h2>
        <p className="text-slate-400 mt-1 transition-colors">{subtitleText}</p>
      </div>

      <div className="w-full flex flex-col sm:flex-row items-center gap-4">
        {/* Country Filter */}
        <Select
          value={currentCountry}
          onValueChange={(value) => handleUrlParamChange('country', value)}
        >
          <SelectTrigger className="w-full sm:w-[200px] h-12 bg-slate-900/80 border-slate-700">
            <SelectValue placeholder="Filter by country..." />
          </SelectTrigger>
          <SelectContent>
            <ScrollArea className="h-[250px]">
              <SelectItem value="all">All Countries</SelectItem>
              {allCountries.map((country) => (
                <SelectItem key={country} value={country}>
                  {country}
                </SelectItem>
              ))}
            </ScrollArea>
          </SelectContent>
        </Select>

        {/* Search Input */}
        <div className="relative flex-grow w-full">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-slate-500" />
          <Input
            id="search"
            placeholder="Search by name, company, or keyword..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="bg-slate-900/80 border-slate-700 h-12 pl-10"
          />
        </div>

        {/* Action Buttons */}
        <div className="flex items-center gap-2">
          <TooltipProvider>
            {sortOptions.map((option) => {
              const IconComponent = iconMap[option.icon] || Clock
              return (
                <Tooltip key={option.value}>
                  <TooltipTrigger asChild>
                    <Button
                      variant="outline"
                      size="icon"
                      onClick={() => handleUrlParamChange('sort', option.value === 'date_desc' ? null : option.value)}
                      className={cn(
                        'h-12 w-12',
                        currentSort === option.value && 'bg-blue-500/20 text-blue-300'
                      )}
                      aria-label={option.tooltip}
                    >
                      <IconComponent className="h-5 w-5" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>{option.tooltip}</TooltipContent>
                </Tooltip>
              )
            })}
             <Tooltip>
                <TooltipTrigger asChild>
                    <Button
                      variant="outline"
                      size="icon"
                      onClick={() => handleUrlParamChange('withEmail', !withEmailOnly)}
                      className={cn(
                        'h-12 w-12',
                        withEmailOnly && 'bg-blue-500/20 text-blue-300'
                      )}
                      aria-label="Filter by email"
                    >
                      <Mail className="h-5 w-5" />
                    </Button>
                </TooltipTrigger>
                <TooltipContent>
                    {withEmailOnly ? "Show all opportunities" : "Show only opportunities with email"}
                </TooltipContent>
            </Tooltip>
             <Tooltip>
                <TooltipTrigger asChild>
                    <Button
                      variant="outline"
                      size="icon"
                      onClick={() => handleUrlParamChange('favorites', !favoritesOnly)}
                      className={cn(
                        'h-12 w-12',
                        favoritesOnly && 'bg-yellow-500/20 text-yellow-300'
                      )}
                      aria-label="Filter by favorites"
                    >
                      <Star className="h-5 w-5" />
                    </Button>
                </TooltipTrigger>
                <TooltipContent>
                    {favoritesOnly ? "Show all items" : "Show only favorited items"}
                </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </div>
      </div>
    </div>
  )
}

```

## 📄 .tmp_backups/client/src/components/events/EventCardDesktop.jsx.bak
*Lines: 151, Size: 6.1 KB*

```
// apps/client/src/components/events/EventCardDesktop.jsx (version 1.4.0)
'use client'

import { Badge, AccordionTrigger, Button, Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@headlines/ui'
import {
  Trash2,
  MessageSquarePlus,
  Users,
  Database,
  Globe,
  BookOpen,
  Star,
  Sparkles,
} from 'lucide-react'
import { getCountryFlag } from '@headlines/utils'
import Image from 'next/image'

const getRelevanceBadgeClass = (score) => {
  if (score >= 90)
    return 'bg-red-500/20 text-red-300 border border-red-500/30 shadow-lg shadow-red-500/10'
  if (score >= 75)
    return 'bg-blue-500/20 text-blue-300 border border-blue-500/30 shadow-lg shadow-blue-500/10'
  return 'bg-slate-500/20 text-slate-300 border border-slate-500/30'
}

const EnrichmentSourceIcons = ({ sources = [] }) => {
  const iconMap = {
    rag_db: { icon: Database, tooltip: 'Enriched with Historical Data' },
    wikipedia: { icon: Globe, tooltip: 'Enriched with Wikipedia' },
    news_api: { icon: BookOpen, tooltip: 'Enriched with NewsAPI' },
  }
  return (
    <div className="flex items-center gap-2">
      {sources.map((sourceKey) => {
        const IconComponent = iconMap[sourceKey]?.icon
        if (!IconComponent) return null
        return (
          <Tooltip key={sourceKey}>
            <TooltipTrigger>
              <IconComponent className="h-4 w-4 text-slate-500" />
            </TooltipTrigger>
            <TooltipContent>
              <p>{iconMap[sourceKey].tooltip}</p>
            </TooltipContent>
          </Tooltip>
        )
      })}
    </div>
  )
}

export function EventCardDesktop({
  event,
  onChat,
  onDelete,
  onFavorite,
  isFavorited,
  isPending,
}) {
  if (!event) return null
  const flag = getCountryFlag(event.country)
  const primaryImageUrl = event.source_articles?.find((a) => a.imageUrl)?.imageUrl

  return (
    <div className="hidden sm:block p-4 relative">
      {/* DEFINITIVE FIX: Action buttons are now absolutely positioned outside the trigger flow */}
      <div className="absolute top-4 right-4 z-20 flex gap-1">
        <TooltipProvider delayDuration={100}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button variant="ghost" size="icon" onClick={onChat} className="text-slate-400 hover:text-blue-400 bg-black/20 hover:bg-blue-500/20 h-8 w-8">
                  <MessageSquarePlus className="h-4 w-4" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>Ask AI about this event</TooltipContent>
            </Tooltip>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button variant="ghost" size="icon" onClick={onFavorite} className={`bg-black/20 h-8 w-8 ${isFavorited ? 'text-yellow-400 hover:text-yellow-300 hover:bg-yellow-500/20' : 'text-slate-400 hover:text-yellow-400 hover:bg-yellow-500/20'}`}>
                  <Star className="h-4 w-4" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>{isFavorited ? 'Unfavorite' : 'Favorite'}</TooltipContent>
            </Tooltip>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button variant="ghost" size="icon" disabled={isPending} onClick={onDelete} className="text-slate-400 hover:text-red-400 bg-black/20 hover:bg-red-500/20 h-8 w-8">
                  <Trash2 className="h-4 w-4" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>Delete Event</TooltipContent>
            </Tooltip>
        </TooltipProvider>
      </div>

      <AccordionTrigger className="p-0 hover:no-underline text-left w-full">
        <div className="flex items-start gap-6">
            <div className="flex flex-col items-center shrink-0">
                <Badge className={`text-xl font-bold px-4 py-2 ${getRelevanceBadgeClass(event.highest_relevance_score)}`}>
                {event.highest_relevance_score}
                </Badge>
                <span className="text-xs text-slate-500 mt-1">Score</span>
            </div>
            <div className="flex-grow min-w-0 pr-20">
                <h3 className="font-serif font-bold text-xl text-slate-100 mb-2">
                <span className="text-2xl mr-3 align-middle">{flag}</span>
                {event.synthesized_headline}
                </h3>
                <p className="text-slate-300 leading-relaxed">{event.synthesized_summary}</p>
                {event.advisorSummary && (
                <div className="mt-3 flex items-start gap-2 text-sm text-amber-300/90 p-2 bg-amber-500/10 rounded-md border border-amber-500/20">
                    <Sparkles className="h-4 w-4 mt-0.5 flex-shrink-0" />
                    <p className="italic">"{event.advisorSummary}"</p>
                </div>
                )}
            </div>
            {primaryImageUrl && (
                <div className="relative h-24 w-24 rounded-lg overflow-hidden flex-shrink-0">
                <Image
                    src={primaryImageUrl}
                    alt={event.synthesized_headline}
                    fill
                    className="object-cover"
                    sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                />
                </div>
            )}
        </div>
        <div className="mt-4 pt-4 border-t border-slate-800/50 flex flex-col sm:flex-row justify-between items-start gap-4">
            <div className="flex items-center gap-4">
                {event.key_individuals && event.key_individuals.length > 0 && (
                <div className="flex items-center gap-2 text-slate-400">
                    <Users className="h-4 w-4 text-slate-500" />
                    <span className="text-sm font-medium text-slate-300">
                    {event.key_individuals.length} Key Individual(s)
                    </span>
                </div>
                )}
                <EnrichmentSourceIcons sources={event.enrichmentSources} />
            </div>
            {event.ai_assessment_reason && (
                <p className="text-xs text-slate-500 italic sm:text-right flex-grow">
                {event.ai_assessment_reason}
                </p>
            )}
        </div>
      </AccordionTrigger>
    </div>
  )
}

```

## 📄 .tmp_backups/client/src/components/events/EventCardMobile.jsx.bak
*Lines: 126, Size: 4.62 KB*

```
// apps/client/src/components/events/EventCardMobile.jsx (version 1.3)
'use client'

import { Badge } from '@headlines/ui'
import { Button } from '@headlines/ui'
import { Trash2, MessageSquarePlus, Users, Star, Sparkles } from 'lucide-react'
import { getCountryFlag } from '@headlines/utils'
import { cn } from '@headlines/utils'

const getRelevanceBadgeClass = (score) => {
  if (score >= 90) return 'bg-red-500/20 text-red-300 border border-red-500/30'
  if (score >= 75) return 'bg-blue-500/20 text-blue-300 border border-blue-500/30'
  return 'bg-slate-500/20 text-slate-300 border border-slate-500/30'
}

export function EventCardMobile({
  event,
  onChat,
  onDelete,
  onFavorite,
  isFavorited,
  isPending,
}) {
  if (!event) return null
  const flag = getCountryFlag(event.country)
  const primaryImageUrl = event.source_articles?.find((a) => a.imageUrl)?.imageUrl

  return (
    <div className="sm:hidden">
      <div
        className={cn(
          'relative rounded-lg -m-4 mb-0 p-4',
          primaryImageUrl && 'min-h-[200px] flex flex-col justify-end'
        )}
        style={primaryImageUrl ? { backgroundImage: `url(${primaryImageUrl})` } : {}}
      >
        {primaryImageUrl && (
          <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-black/60 to-transparent z-0 rounded-lg" />
        )}

        <div className="relative z-10">
          <div className="flex justify-between items-start gap-2 mb-2">
            <div className="flex items-center gap-2 min-w-0">
              <Badge
                className={`text-sm font-bold px-2 py-0.5 ${getRelevanceBadgeClass(
                  event.highest_relevance_score
                )}`}
              >
                {event.highest_relevance_score}
              </Badge>
            </div>
            <div className="flex flex-col items-center gap-1">
              <Button
                variant="ghost"
                size="icon"
                onClick={(e) => { e.stopPropagation(); onChat(e); }}
                className="text-slate-300 hover:text-blue-400 bg-black/20 hover:bg-blue-500/20 h-8 w-8"
              >
                <MessageSquarePlus className="h-4 w-4" />
              </Button>
              <Button
                variant="ghost"
                size="icon"
                onClick={(e) => { e.stopPropagation(); onFavorite(e); }}
                className={`bg-black/20 h-8 w-8 ${isFavorited ? 'text-yellow-400 hover:text-yellow-300' : 'text-slate-300 hover:text-yellow-400'}`}
              >
                <Star className="h-4 w-4" />
              </Button>
              <Button
                variant="ghost"
                size="icon"
                disabled={isPending}
                onClick={(e) => { e.stopPropagation(); onDelete(e); }}
                className="text-slate-300 hover:text-red-400 bg-black/20 hover:bg-red-500/20 h-8 w-8"
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </div>
          </div>
          <h3
            className={cn(
              'font-serif font-bold text-lg line-clamp-3',
              primaryImageUrl ? 'text-white drop-shadow-lg' : 'text-slate-100'
            )}
          >
            <span className="text-xl mr-2 align-middle">{flag}</span>
            {event.synthesized_headline}
          </h3>
        </div>
      </div>

      <div
        className={cn(
          'pt-4',
          primaryImageUrl && 'bg-slate-900 -m-4 mt-0 p-4 rounded-b-xl'
        )}
      >
        <p className="text-sm text-slate-300 leading-relaxed">
          {event.synthesized_summary}
        </p>
        {event.advisorSummary && (
          <div className="mt-3 flex items-start gap-2 text-sm text-amber-300/90 p-2 bg-amber-500/10 rounded-md border border-amber-500/20">
            <Sparkles className="h-4 w-4 mt-0.5 flex-shrink-0" />
            <p className="italic">"{event.advisorSummary}"</p>
          </div>
        )}
        <div className="mt-4 pt-4 border-t border-slate-800/50 flex flex-col justify-between items-start gap-4">
          {event.key_individuals && event.key_individuals.length > 0 && (
            <div className="flex items-start gap-3 text-slate-400">
              <Users className="h-5 w-5 mt-0.5 shrink-0 text-slate-500" />
              <p className="text-sm font-medium text-slate-300">
                {event.key_individuals.length} Key Individual(s) Identified
              </p>
            </div>
          )}
          {event.ai_assessment_reason && (
            <p className="text-xs text-slate-500 italic sm:text-right flex-grow">
              {event.ai_assessment_reason}
            </p>
          )}
        </div>
      </div>
    </div>
  )
}

```

## 📄 .tmp_backups/data-access/actions/articles.js.bak
*Lines: 50, Size: 1.53 KB*

```
// packages/data-access/src/actions/articles.js (version 1.0.0)
'use server'

import dbConnect from '../dbConnect.js'
import { Article } from '@headlines/models'
import { revalidatePath } from '../revalidate.js'
import { buildQuery } from '../queryBuilder.js'

const ARTICLES_PER_PAGE = 10;

export async function deleteArticle(articleId) {
  if (!articleId) {
    return { success: false, message: 'Article ID is required.' }
  }
  try {
    await dbConnect()
    const result = await Article.findByIdAndDelete(articleId)
    if (!result) return { success: false, message: 'Article not found.' }
    await revalidatePath('/')
    return { success: true, message: 'Article deleted successfully.' }
  } catch (error) {
    return { success: false, message: 'Failed to delete article.' }
  }
}

const baseQuery = {
  $or: [{ relevance_article: { $gt: 25 } }, { relevance_headline: { $gt: 25 } }],
}

export async function getArticles({ page = 1, filters = {}, sort = 'date_desc' }) {
  await dbConnect()
  const { queryFilter, sortOptions } = buildQuery(Article, { filters, sort, baseQuery })
  const skipAmount = (page - 1) * ARTICLES_PER_PAGE

  const articles = await Article.find(queryFilter)
    .sort(sortOptions)
    .skip(skipAmount)
    .limit(ARTICLES_PER_PAGE)
    .lean()

  return JSON.parse(JSON.stringify(articles))
}

export async function getTotalArticleCount({ filters = {} } = {}) {
  await dbConnect()
  const { queryFilter } = buildQuery(Article, { filters, baseQuery })
  const count = await Article.countDocuments(queryFilter)
  return count
}

```

## 📄 .tmp_backups/data-access/actions/events.js.bak
*Lines: 49, Size: 1.87 KB*

```
// packages/data-access/src/actions/events.js (version 2.1.0)
'use server'

import dbConnect from '../dbConnect.js'
import mongoose from 'mongoose'
import { SynthesizedEvent, Opportunity, Article, Subscriber } from '@headlines/models'
import { revalidatePath } from '../revalidate.js'
import { buildQuery } from '../queryBuilder.js'
import { getUserIdFromSession } from '@headlines/auth/src/verifySession.js' // Helper for server components

const EVENTS_PER_PAGE = 5;

export async function deleteEvent({ eventId, userId }) {
  if (!eventId) return { success: false, message: 'Event ID is required.' }
  try {
    await dbConnect()
    // Instead of deleting, we add it to the user's discarded list.
    if (userId) {
        await Subscriber.updateOne({ _id: userId }, { $addToSet: { 'discardedItems.events': eventId } });
    }
    await revalidatePath('/')
    return { success: true, message: 'Event discarded.' }
  } catch (error) {
    return { success: false, message: `Failed to discard event: ${error.message}` }
  }
}

const baseQuery = { highest_relevance_score: { $gt: 25 } }

export async function getEvents({ page = 1, filters = {}, sort = 'date_desc' }) {
  const userId = await getUserIdFromSession(); // Get current user's ID
  await dbConnect();
  const { queryFilter, sortOptions } = await buildQuery(SynthesizedEvent, { filters, sort, baseQuery, userId });
  const skipAmount = (page - 1) * EVENTS_PER_PAGE;
  const events = await SynthesizedEvent.find(queryFilter)
    .sort(sortOptions)
    .skip(skipAmount)
    .limit(EVENTS_PER_PAGE)
    .lean();
  return JSON.parse(JSON.stringify(events));
}

export async function getTotalEventCount({ filters = {} } = {}) {
  const userId = await getUserIdFromSession();
  await dbConnect();
  const { queryFilter } = await buildQuery(SynthesizedEvent, { filters, baseQuery, userId });
  return await SynthesizedEvent.countDocuments(queryFilter);
}

```

## 📄 .tmp_backups/data-access/actions/opportunities.js.bak
*Lines: 98, Size: 3.21 KB*

```
// packages/data-access/src/actions/opportunities.js (version 2.1.0)
'use server'

import dbConnect from '../dbConnect.js'
import { Opportunity, Subscriber } from '@headlines/models'
import { revalidatePath } from '../revalidate.js'
import { buildQuery } from '../queryBuilder.js'
import { getUserIdFromSession } from '@headlines/auth/src/verifySession.js'
import mongoose from 'mongoose'

const OPPORTUNITIES_PER_PAGE = 10

export async function getOpportunities({ page = 1, filters = {}, sort = 'date_desc' }) {
  const userId = await getUserIdFromSession()
  await dbConnect()
  const { queryFilter, sortOptions } = await buildQuery(Opportunity, {
    filters,
    sort,
    userId,
  })
  const skipAmount = (page - 1) * OPPORTUNITIES_PER_PAGE

  const opportunities = await Opportunity.find(queryFilter)
    .populate({
      path: 'events',
      select:
        'synthesized_headline synthesized_summary source_articles highest_relevance_score',
      options: { limit: 1, sort: { createdAt: -1 } },
    })
    .sort(sortOptions)
    .skip(skipAmount)
    .limit(OPPORTUNITIES_PER_PAGE)
    .lean()

  const processed = opportunities.map((opp) => ({
    ...opp,
    sourceEventId: opp.events?.[0] || null,
  }))
  return JSON.parse(JSON.stringify(processed))
}

export async function getTotalOpportunitiesCount({ filters = {} } = {}) {
  const userId = await getUserIdFromSession()
  await dbConnect()
  const { queryFilter } = await buildQuery(Opportunity, { filters, userId })
  return await Opportunity.countDocuments(queryFilter)
}

export async function deleteOpportunity({ opportunityId, userId }) {
  if (!opportunityId) return { success: false, message: 'ID is required.' }
  try {
    await dbConnect()
    if (userId) {
      await Subscriber.updateOne(
        { _id: userId },
        { $addToSet: { 'discardedItems.opportunities': opportunityId } }
      )
    }
    await revalidatePath('/opportunities')
    return { success: true, message: 'Opportunity discarded.' }
  } catch (error) {
    return { success: false, message: 'Failed to discard opportunity.' }
  }
}

// NEW FUNCTION for Project Drill Down
export async function getOpportunityDetails(opportunityId) {
  if (!mongoose.Types.ObjectId.isValid(opportunityId)) {
    return { success: false, error: 'Invalid ID format.' }
  }
  try {
    await dbConnect()
    const opportunity = await Opportunity.findById(opportunityId)
      .populate({
        path: 'events',
        options: { sort: { createdAt: -1 } }, // Sort events by most recent
      })
      .lean()

    if (!opportunity) {
      return { success: false, error: 'Opportunity not found.' }
    }

    return { success: true, data: JSON.parse(JSON.stringify(opportunity)) }
  } catch (error) {
    return { success: false, error: 'Database error while fetching opportunity details.' }
  }
}

export async function getUniqueOpportunityCountries() {
  const userId = await getUserIdFromSession();
  await dbConnect();
  const { queryFilter } = await buildQuery(Opportunity, { userId });
  // Use distinct to get a list of unique 'basedIn' values that are not null/empty
  const countries = await Opportunity.distinct('basedIn', { ...queryFilter, basedIn: { $ne: null, $ne: '' } });
  return JSON.parse(JSON.stringify(countries.sort()));
}

```

## 📄 .tmp_backups/data-access/actions/subscriber.js.bak
*Lines: 56, Size: 2.1 KB*

```
// packages/data-access/src/actions/subscriber.js (version 1.1.0)
'use server'

import dbConnect from '../dbConnect.js'
import { Subscriber } from '@headlines/models'
import { revalidatePath } from '../revalidate.js'

export async function updateUserProfile({ userId, updateData }) {
  if (!userId) return { success: false, error: 'User ID is required.' }
  if (!updateData) return { success: false, error: 'No update data provided.' }

  try {
    await dbConnect()
    const updatedUser = await Subscriber.findByIdAndUpdate(userId, { $set: updateData }, { new: true })
      .select('-password')
      .lean()
    if (!updatedUser) return { success: false, error: 'User not found.' }
    await revalidatePath('/') // Revalidate all pages for user-specific data
    return { success: true, user: JSON.parse(JSON.stringify(updatedUser)) }
  } catch (error) {
    return { success: false, error: 'Failed to update profile.' }
  }
}

export async function updateUserInteraction({ userId, itemId, itemType, action }) {
    if (!userId || !itemId || !itemType || !action) return { success: false, error: 'Missing parameters.' };
    
    const fieldMap = { event: 'events', article: 'articles', opportunity: 'opportunities' };
    const field = fieldMap[itemType];
    if (!field) return { success: false, error: 'Invalid item type.' };

    let updateOperation = {};
    switch (action) {
        case 'discard':
            updateOperation = { $addToSet: { [`discardedItems.${field}`]: itemId } };
            break;
        case 'favorite':
            updateOperation = { $addToSet: { [`favoritedItems.${field}`]: itemId } };
            break;
        case 'unfavorite':
            updateOperation = { $pull: { [`favoritedItems.${field}`]: itemId } };
            break;
        default:
            return { success: false, error: 'Invalid action.' };
    }

    try {
        await dbConnect();
        await Subscriber.updateOne({ _id: userId }, updateOperation);
        await revalidatePath('/');
        return { success: true };
    } catch (error) {
        return { success: false, error: 'Failed to update user interaction.' };
    }
}

```

## 📄 .tmp_backups/data-access/actions/upload.js.bak
*Lines: 62, Size: 2.21 KB*

```
// packages/data-access/src/actions/upload.js (version 1.0)
'use server'

import { revalidatePath } from '../revalidate.js';
import { SynthesizedEvent, Opportunity } from '@headlines/models';
import { verifySession } from '@headlines/auth';
import {
  assessArticleContent,
  synthesizeEvent,
  generateOpportunitiesFromEvent,
} from '@headlines/scraper-logic/src/ai';

// This is a simplified, single-item pipeline for uploaded content.
export async function processUploadedArticle(item) {
  const { user, error } = await verifySession();
  if (!user) return { success: false, error: error || 'Authentication required' };

  try {
    // 1. Assess & Enrich (Simulated)
    // We treat the uploaded content as already enriched.
    const enrichedArticle = {
      ...item,
      relevance_article: 100, // Assume high relevance for manual uploads
      assessment_article: item.article,
      articleContent: { contents: [item.article] },
      newspaper: 'Manual Upload',
      country: 'Denmark', // Default or could be a param
      key_individuals: [], // Will be extracted during synthesis
    };

    // 2. Synthesize Event
    const synthesizedResult = await synthesizeEvent([enrichedArticle], [], '', '');
    if (!synthesizedResult || !synthesizedResult.headline) {
      throw new Error('AI failed to synthesize an event from the provided text.');
    }

    const eventToSave = new SynthesizedEvent({
      ...synthesizedResult,
      event_key: `manual-${new Date().toISOString()}`,
      highest_relevance_score: 100,
      source_articles: [{ headline: item.headline, link: '#manual', newspaper: 'Manual Upload' }],
    });

    // 3. Generate Opportunities
    const opportunitiesToSave = await generateOpportunitiesFromEvent(eventToSave, [enrichedArticle]);

    // 4. Save to DB
    await eventToSave.save();
    if (opportunitiesToSave.length > 0) {
      await Opportunity.insertMany(opportunitiesToSave.map(opp => ({...opp, events: [eventToSave._id]})));
    }
    
    await revalidatePath('/events');
    await revalidatePath('/opportunities');

    return { success: true, event: eventToSave.synthesized_headline };
  } catch (e) {
    console.error('[Upload Action Error]:', e);
    return { success: false, error: e.message };
  }
}

```

## 📄 .tmp_backups/data-access/index.js.bak
*Lines: 153, Size: 3.53 KB*

```
// packages/data-access/src/index.js (version 4.4.0)
'use server'

import {
  getAdminArticles,
  updateAdminArticle,
  deleteAdminArticle,
} from './actions/adminArticles.js'
import {
  getAdminEvents,
  getAdminEventDetails,
  updateAdminEvent,
  deleteAdminEvent,
} from './actions/adminEvents.js'
import {
  getAdminOpportunities,
  updateAdminOpportunity,
  deleteAdminOpportunity,
} from './actions/adminOpportunities.js'
import { deleteArticle, getArticles, getTotalArticleCount } from './actions/articles.js'
import { deleteEvent, getEvents, getTotalEventCount } from './actions/events.js'
import {
  getOpportunities,
  getTotalOpportunitiesCount,
  deleteOpportunity,
  getOpportunityDetails,
  getUniqueOpportunityCountries, // ADDED EXPORT
} from './actions/opportunities.js'
import { updateUserProfile, updateUserInteraction } from './actions/subscriber.js'
import {
  getAllCountries,
  createCountry,
  updateCountry,
  getGlobalCountries,
} from './actions/countries.js'
import {
  getAllSubscribers,
  createSubscriber,
  updateSubscriber,
  deleteSubscriber,
  updateSubscribersStatus,
  deleteSubscribers,
} from './actions/admin.js'
import {
  getAllSources,
  createSource,
  updateSource,
  deleteSource,
} from './actions/adminSources.js'
import { getDashboardStats } from './actions/dashboard.js'
import { getRecentRunVerdicts, getRunVerdictById } from './actions/verdicts.js'
import {
  getSuggestions,
  processWatchlistSuggestion,
  processSourceSuggestion,
} from './actions/suggestions.js'
import {
  getAllWatchlistEntities,
  createWatchlistEntity,
  updateWatchlistEntity,
  deleteWatchlistEntity,
} from './actions/watchlist.js'
import { getSettings, updateSettings } from './actions/settings.js'
import { testSourceConfig } from './actions/scrape.js'
import {
  updateSourceAnalyticsBatch,
  findSourcesForScraping,
  performHousekeeping,
  bulkWriteEvents,
  bulkWriteArticles,
  findEventsByKeys,
  findArticlesByLinks,
  getActiveWatchlistEntityNames,
  bulkWriteWatchlistSuggestions,
} from './actions/pipeline.js'

export {
  // admin pages
  getAdminArticles,
  updateAdminArticle,
  deleteAdminArticle,
  getAdminEvents,
  getAdminEventDetails,
  updateAdminEvent,
  deleteAdminEvent,
  getAdminOpportunities,
  updateAdminOpportunity,
  deleteAdminOpportunity,
  // articles
  deleteArticle,
  getArticles,
  getTotalArticleCount,
  // events
  deleteEvent,
  getEvents,
  getTotalEventCount,
  // opportunities
  getOpportunities,
  getTotalOpportunitiesCount,
  deleteOpportunity,
  getOpportunityDetails,
  getUniqueOpportunityCountries, // ADDED EXPORT
  // subscriber
  updateUserProfile,
  updateUserInteraction,
  // countries
  getAllCountries,
  createCountry,
  updateCountry,
  getGlobalCountries,
  // admin (users)
  getAllSubscribers,
  createSubscriber,
  updateSubscriber,
  deleteSubscriber,
  updateSubscribersStatus,
  deleteSubscribers,
  // admin (sources)
  getAllSources,
  createSource,
  updateSource,
  deleteSource,
  // dashboard
  getDashboardStats,
  // verdicts
  getRecentRunVerdicts,
  getRunVerdictById,
  // suggestions
  getSuggestions,
  processWatchlistSuggestion,
  processSourceSuggestion,
  // watchlist
  getAllWatchlistEntities,
  createWatchlistEntity,
  updateWatchlistEntity,
  deleteWatchlistEntity,
  // settings
  getSettings,
  updateSettings,
  // scrape
  testSourceConfig,
  // pipeline
  updateSourceAnalyticsBatch,
  findSourcesForScraping,
  performHousekeeping,
  bulkWriteEvents,
  bulkWriteArticles,
  findEventsByKeys,
  findArticlesByLinks,
  getActiveWatchlistEntityNames,
  bulkWriteWatchlistSuggestions,
}

```

## 📄 .tmp_backups/data-access/queryBuilder.js.bak
*Lines: 80, Size: 2.7 KB*

```
// packages/data-access/src/queryBuilder.js (version 2.2.0)
'use server'

import { Subscriber } from '@headlines/models'

export async function buildQuery(
  model,
  { filters = {}, sort = 'date_desc', baseQuery = {}, userId = null }
) {
  const andConditions = [{ ...baseQuery }]

  // Text search condition
  if (filters.q) {
    const searchRegex = { $regex: filters.q, $options: 'i' }
    const textSearchablePaths = Object.keys(model.schema.paths).filter(
      (p) => model.schema.paths[p].instance === 'String'
    )
    const orConditions = textSearchablePaths.map((path) => ({ [path]: searchRegex }))
    if (orConditions.length > 0) andConditions.push({ $or: orConditions })
  }

  // Country filter condition
  if (filters.country && Array.isArray(filters.country) && filters.country.length > 0) {
    const countryField = model.schema.paths.basedIn ? 'basedIn' : 'country'
    andConditions.push({ [countryField]: { $in: filters.country } })
  } else if (filters.country && typeof filters.country === 'string') {
    // Handle single country filter from opportunities page
    const countryField = model.schema.paths.basedIn ? 'basedIn' : 'country'
    andConditions.push({ [countryField]: filters.country })
  }

  // CRITICAL FIX: Add logic to handle the 'withEmail' filter.
  // This checks that the nested 'email' field exists and is not null.
  if (filters.withEmail) {
    andConditions.push({ 'contactDetails.email': { $exists: true, $ne: null } })
  }

  // Favorites filter
  if (filters.favoritesOnly && userId) {
    const user = await Subscriber.findById(userId).select('favoritedItems').lean()
    const modelName = model.modelName.toLowerCase()
    const favoritedIds = user?.favoritedItems?.[`${modelName}s`] || []
    andConditions.push({ _id: { $in: favoritedIds } })
  }

  // Filter out discarded items if a user is specified
  if (userId) {
    const user = await Subscriber.findById(userId).select('discardedItems').lean()
    if (user && user.discardedItems) {
      const modelName = model.modelName.toLowerCase()
      const discardedIds = user.discardedItems[`${modelName}s`]
      if (discardedIds && discardedIds.length > 0) {
        andConditions.push({ _id: { $nin: discardedIds } })
      }
    }
  }

  const queryFilter =
    andConditions.length > 1 ? { $and: andConditions } : andConditions[0] || {}

  const sortOptions = {}
  switch (sort) {
    case 'date_asc':
      sortOptions.createdAt = 1
      break
    case 'relevance_desc':
      sortOptions.highest_relevance_score = -1
      sortOptions.relevance_article = -1
      break
    case 'size_desc':
      sortOptions.likelyMMDollarWealth = -1
      break
    default:
      sortOptions.createdAt = -1
      break
  }

  return { queryFilter, sortOptions }
}

```

## 📄 .tmp_backups/data-access/src/actions/admin.js.bak
*Lines: 123, Size: 4.11 KB*

```
// packages/data-access/src/actions/admin.js (version 2.2.0)
'use server'

import { Subscriber } from '@headlines/models'
import { verifyAdmin } from '@headlines/auth'
import { revalidatePath } from '../revalidate.js'
import dbConnect from '../dbConnect.js' // Internal helper

export async function getAllSubscribers() {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()
    const users = await Subscriber.find({}).sort({ createdAt: -1 }).lean()
    return { success: true, data: JSON.parse(JSON.stringify(users)) }
  } catch (e) {
    console.error('[Admin Action Error - getAllSubscribers]:', e)
    return { success: false, error: 'Failed to fetch subscribers.' }
  }
}

export async function createSubscriber(userData) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()
    const newUser = new Subscriber(userData)
    await newUser.save()
    await revalidatePath('/admin/users')
    return { success: true, data: JSON.parse(JSON.stringify(newUser)) }
  } catch (e) {
    console.error('[Admin Action Error - createSubscriber]:', e)
    if (e.code === 11000) {
      return { success: false, error: 'A user with this email already exists.' }
    }
    return { success: false, error: 'Failed to create subscriber.' }
  }
}

export async function updateSubscriber(userId, updateData) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()

    // CRITICAL FIX: If the password in the update data is an empty string,
    // delete it from the update object. This prevents the 'pre-save' hook
    // from attempting to hash an empty password, which would overwrite the
    // existing hash.
    if (updateData.password === '') {
      delete updateData.password
    }
    
    // ROBUSTNESS FIX: Use findByIdAndUpdate with $set for a more reliable, atomic update.
    // This correctly handles updates to nested fields and arrays like 'countries' and 'language',
    // resolving the issue where language changes were not being saved.
    const user = await Subscriber.findByIdAndUpdate(
      userId,
      { $set: updateData },
      { new: true, runValidators: true }
    ).lean();

    if (!user) {
      return { success: false, error: 'User not found.' }
    }

    await revalidatePath('/admin/users')
    return { success: true, data: JSON.parse(JSON.stringify(user)) }
  } catch (e) {
    console.error('[Admin Action Error - updateSubscriber]:', e)
    return { success: false, error: 'Failed to update subscriber.' }
  }
}

export async function deleteSubscriber(userId) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()
    const result = await Subscriber.findByIdAndDelete(userId)
    if (!result) {
      return { success: false, error: 'User not found.' }
    }
    await revalidatePath('/admin/users')
    return { success: true }
  } catch (e) {
    console.error('[Admin Action Error - deleteSubscriber]:', e)
    return { success: false, error: 'Failed to delete subscriber.' }
  }
}

export async function updateSubscribersStatus(userIds, isActive) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }
  try {
    await dbConnect()
    await Subscriber.updateMany({ _id: { $in: userIds } }, { $set: { isActive } })
    await revalidatePath('/admin/users')
    return { success: true }
  } catch (e) {
    console.error('[Admin Action Error - updateSubscribersStatus]:', e)
    return { success: false, error: 'Failed to bulk update subscribers.' }
  }
}

export async function deleteSubscribers(userIds) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }
  try {
    await dbConnect()
    await Subscriber.deleteMany({ _id: { $in: userIds } })
    await revalidatePath('/admin/users')
    return { success: true }
  } catch (e) {
    console.error('[Admin Action Error - deleteSubscribers]:', e)
    return { success: false, error: 'Failed to bulk delete subscribers.' }
  }
}

```

## 📄 .tmp_backups/data-access/src/actions/adminArticles.js.bak
*Lines: 55, Size: 2.13 KB*

```
// packages/data-access/src/actions/adminArticles.js (version 1.0.0)
'use server'

import dbConnect from '../dbConnect.js';
import { Article } from '@headlines/models';
import { buildQuery } from '../queryBuilder.js';
import { verifyAdmin } from '@headlines/auth';
import { revalidatePath } from '../revalidate.js';

const ARTICLES_PER_PAGE = 50;

export async function getAdminArticles({ page = 1, filters = {}, sort = 'date_desc' }) {
    const { isAdmin, error } = await verifyAdmin();
    if (!isAdmin) return { success: false, error, data: [], total: 0 };
    
    await dbConnect();
    const { queryFilter, sortOptions } = await buildQuery(Article, { filters, sort, baseQuery: {} });
    const skipAmount = (page - 1) * ARTICLES_PER_PAGE;

    const [articles, total] = await Promise.all([
        Article.find(queryFilter).sort(sortOptions).skip(skipAmount).limit(ARTICLES_PER_PAGE).lean(),
        Article.countDocuments(queryFilter)
    ]);

    return { success: true, data: JSON.parse(JSON.stringify(articles)), total };
}

export async function updateAdminArticle(articleId, updateData) {
    const { isAdmin, error } = await verifyAdmin();
    if (!isAdmin) return { success: false, error };
    try {
        await dbConnect();
        const article = await Article.findByIdAndUpdate(articleId, { $set: updateData }, { new: true }).lean();
        if (!article) return { success: false, error: 'Article not found.' };
        await revalidatePath('/admin/articles');
        return { success: true, data: JSON.parse(JSON.stringify(article)) };
    } catch (e) {
        return { success: false, error: 'Failed to update article.' };
    }
}

export async function deleteAdminArticle(articleId) {
    const { isAdmin, error } = await verifyAdmin();
    if (!isAdmin) return { success: false, error };
    try {
        await dbConnect();
        const result = await Article.findByIdAndDelete(articleId);
        if (!result) return { success: false, error: 'Article not found.' };
        await revalidatePath('/admin/articles');
        return { success: true };
    } catch (e) {
        return { success: false, error: 'Failed to delete article.' };
    }
}

```

## 📄 .tmp_backups/data-access/src/actions/adminEvents.js.bak
*Lines: 81, Size: 3.28 KB*

```
// packages/data-access/src/actions/adminEvents.js (version 1.0.0)
'use server'

import dbConnect from '../dbConnect.js';
import { SynthesizedEvent, Article, Opportunity } from '@headlines/models';
import { buildQuery } from '../queryBuilder.js';
import { verifyAdmin } from '@headlines/auth';
import { revalidatePath } from '../revalidate.js';
import mongoose from 'mongoose';

// DEFINITIVE FIX: Removed pagination logic. This action now fetches all matching events.
export async function getAdminEvents({ filters = {}, sort = 'date_desc' }) {
    const { isAdmin, error } = await verifyAdmin();
    if (!isAdmin) return { success: false, error, data: [], total: 0 };
    
    await dbConnect();
    const { queryFilter, sortOptions } = await buildQuery(SynthesizedEvent, { filters, sort, baseQuery: {} });

    const [events, total] = await Promise.all([
        SynthesizedEvent.find(queryFilter)
            .select('-synthesized_summary')
            .sort(sortOptions)
            .lean(),
        SynthesizedEvent.countDocuments(queryFilter)
    ]);

    return { success: true, data: JSON.parse(JSON.stringify(events)), total };
}

export async function getAdminEventDetails(eventId) {
    const { isAdmin, error } = await verifyAdmin();
    if (!isAdmin) return { success: false, error };

    try {
        await dbConnect();
        const event = await SynthesizedEvent.findById(eventId)
            .populate({ path: 'relatedOpportunities', model: Opportunity, select: 'reachOutTo likelyMMDollarWealth' })
            .lean();

        if (!event) return { success: false, error: 'Event not found' };

        const articleLinks = event.source_articles.map(a => a.link);
        const articles = await Article.find({ link: { $in: articleLinks } }).select('headline link newspaper').lean();

        event.source_articles_full = articles;
        return { success: true, data: JSON.parse(JSON.stringify(event)) };
    } catch (e) {
        return { success: false, error: 'Failed to fetch event details.' };
    }
}

export async function updateAdminEvent(eventId, updateData) {
    const { isAdmin, error } = await verifyAdmin();
    if (!isAdmin) return { success: false, error };
    try {
        await dbConnect();
        const event = await SynthesizedEvent.findByIdAndUpdate(eventId, { $set: updateData }, { new: true }).lean();
        if (!event) return { success: false, error: 'Event not found.' };
        await revalidatePath('/admin/events');
        return { success: true, data: JSON.parse(JSON.stringify(event)) };
    } catch (e) {
        return { success: false, error: 'Failed to update event.' };
    }
}

export async function deleteAdminEvent(eventId) {
    const { isAdmin, error } = await verifyAdmin();
    if (!isAdmin) return { success: false, error };
    try {
        await dbConnect();
        const result = await SynthesizedEvent.findByIdAndDelete(eventId);
        if (!result) return { success: false, error: 'Event not found.' };
        await Opportunity.updateMany({ events: eventId }, { $pull: { events: eventId } });
        await Article.updateMany({ synthesizedEventId: eventId }, { $unset: { synthesizedEventId: '' } });
        await revalidatePath('/admin/events');
        return { success: true };
    } catch (e) {
        return { success: false, error: 'Failed to delete event.' };
    }
}

```

## 📄 .tmp_backups/data-access/src/actions/adminOpportunities.js.bak
*Lines: 71, Size: 2.37 KB*

```
// packages/data-access/src/actions/adminOpportunities.js (version 1.0.0)
'use server'

import dbConnect from '../dbConnect.js'
import { Opportunity } from '@headlines/models'
import { buildQuery } from '../queryBuilder.js'
import { verifyAdmin } from '@headlines/auth'
import { revalidatePath } from '../revalidate.js'

// DEFINITIVE FIX: The hardcoded page limit has been removed entirely.
export async function getAdminOpportunities({
  page = 1,
  filters = {},
  sort = 'date_desc',
}) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error, data: [], total: 0 }

  await dbConnect()
  // The query builder is still used for sorting and filtering.
  const { queryFilter, sortOptions } = await buildQuery(Opportunity, {
    filters,
    sort,
    baseQuery: {},
  })

  // Pagination logic is now removed. The action fetches all matching documents.
  const [opportunities, total] = await Promise.all([
    Opportunity.find(queryFilter)
      .populate({ path: 'events', select: 'synthesized_headline', options: { limit: 1 } })
      .sort(sortOptions)
      .lean(),
    Opportunity.countDocuments(queryFilter),
  ])

  // The total from countDocuments is still returned for the UI's information.
  return { success: true, data: JSON.parse(JSON.stringify(opportunities)), total }
}

export async function updateAdminOpportunity(oppId, updateData) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }
  try {
    await dbConnect()
    const opp = await Opportunity.findByIdAndUpdate(
      oppId,
      { $set: updateData },
      { new: true }
    ).lean()
    if (!opp) return { success: false, error: 'Opportunity not found.' }
    await revalidatePath('/admin/opportunities')
    return { success: true, data: JSON.parse(JSON.stringify(opp)) }
  } catch (e) {
    return { success: false, error: 'Failed to update opportunity.' }
  }
}

export async function deleteAdminOpportunity(oppId) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }
  try {
    await dbConnect()
    const result = await Opportunity.findByIdAndDelete(oppId)
    if (!result) return { success: false, error: 'Opportunity not found.' }
    await revalidatePath('/admin/opportunities')
    return { success: true }
  } catch (e) {
    return { success: false, error: 'Failed to delete opportunity.' }
  }
}

```

## 📄 .tmp_backups/data-access/src/actions/adminSources.js.bak
*Lines: 79, Size: 2.52 KB*

```
// packages/data-access/src/actions/adminSources.js (version 2.0)
'use server'

import { revalidatePath } from '../revalidate.js'
import { Source } from '@headlines/models'
import { verifyAdmin } from '@headlines/auth'
import dbConnect from '../dbConnect.js' // Internal helper

export async function getAllSources() {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()
    const sources = await Source.find({}).sort({ country: 1, name: 1 }).lean()
    return { success: true, data: JSON.parse(JSON.stringify(sources)) }
  } catch (e) {
    console.error('[Admin Action Error - getAllSources]:', e)
    return { success: false, error: 'Failed to fetch sources.' }
  }
}

export async function createSource(sourceData) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()
    const newSource = new Source(sourceData)
    await newSource.save()
    await revalidatePath('/admin/sources')
    return { success: true, data: JSON.parse(JSON.stringify(newSource)) }
  } catch (e) {
    console.error('[Admin Action Error - createSource]:', e)
    if (e.code === 11000) {
      return { success: false, error: 'A source with this name already exists.' }
    }
    return { success: false, error: 'Failed to create source.' }
  }
}

export async function updateSource(sourceId, updateData) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()
    const updatedSource = await Source.findByIdAndUpdate(sourceId, updateData, {
      new: true,
    }).lean()
    if (!updatedSource) {
      return { success: false, error: 'Source not found.' }
    }
    await revalidatePath('/admin/sources')
    return { success: true, data: JSON.parse(JSON.stringify(updatedSource)) }
  } catch (e) {
    console.error('[Admin Action Error - updateSource]:', e)
    return { success: false, error: 'Failed to update source.' }
  }
}

export async function deleteSource(sourceId) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()
    const result = await Source.findByIdAndDelete(sourceId)
    if (!result) {
      return { success: false, error: 'Source not found.' }
    }
    await revalidatePath('/admin/sources')
    return { success: true }
  } catch (e) {
    console.error('[Admin Action Error - deleteSource]:', e)
    return { success: false, error: 'Failed to delete source.' }
  }
}

```

## 📄 .tmp_backups/data-access/src/actions/countries.js.bak
*Lines: 117, Size: 3.47 KB*

```
// packages/data-access/src/actions/countries.js (version 2.2.0)
'use server'

import { revalidatePath } from '../revalidate.js'
import { Country } from '@headlines/models'
import { verifyAdmin } from '@headlines/auth'
import dbConnect from '../dbConnect.js'

// This function is for the admin panel and requires authentication.
export async function getAllCountries() {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }
  try {
    await dbConnect()
    const countries = await Country.aggregate([
      { $match: {} },
      {
        $lookup: {
          from: 'synthesized_events',
          localField: 'name',
          foreignField: 'country',
          as: 'events',
        },
      },
      {
        $lookup: {
          from: 'sources',
          localField: 'name',
          foreignField: 'country',
          as: 'sources',
        },
      },
      {
        $project: {
          name: 1,
          isoCode: 1,
          status: 1,
          createdAt: 1,
          updatedAt: 1,
          eventCount: { $size: '$events' },
          sourceCount: { $size: '$sources' },
          activeSourceCount: {
            $size: {
              $filter: {
                input: '$sources',
                as: 'source',
                cond: { $eq: ['$$source.status', 'active'] },
              },
            },
          },
        },
      },
    ])
    return { success: true, data: JSON.parse(JSON.stringify(countries)) }
  } catch (e) {
    console.error('[Action Error - getAllCountries]:', e)
    return { success: false, error: 'Failed to fetch countries with aggregate data.' }
  }
}

// This is a new, public-facing function for the client app layout. It does not require admin auth.
export async function getGlobalCountries() {
  try {
    await dbConnect()
    const countries = await Country.aggregate([
      { $match: { status: 'active' } },
      {
        $lookup: {
          from: 'synthesized_events',
          localField: 'name',
          foreignField: 'country',
          as: 'events',
        },
      },
      { $project: { name: 1, count: { $size: '$events' } } },
      { $sort: { name: 1 } },
    ])
    return { success: true, data: JSON.parse(JSON.stringify(countries)) }
  } catch (e) {
    console.error('[Action Error - getGlobalCountries]:', e)
    return { success: false, error: 'Failed to fetch global country list.' }
  }
}

export async function createCountry(countryData) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()
    const newCountry = new Country(countryData)
    await newCountry.save()
    await revalidatePath('/admin/countries')
    return { success: true, data: JSON.parse(JSON.stringify(newCountry)) }
  } catch (e) {
    if (e.code === 11000) return { success: false, error: 'Country already exists.' }
    return { success: false, error: 'Failed to create country.' }
  }
}

export async function updateCountry(countryId, updateData) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()
    const country = await Country.findByIdAndUpdate(countryId, updateData, {
      new: true,
    }).lean()
    if (!country) return { success: false, error: 'Country not found.' }
    await revalidatePath('/admin/countries')
    return { success: true, data: JSON.parse(JSON.stringify(country)) }
  } catch (e) {
    return { success: false, error: 'Failed to update country.' }
  }
}

```

## 📄 .tmp_backups/data-access/src/actions/export.js.bak
*Lines: 70, Size: 2.29 KB*

```
// packages/data-access/src/actions/export.js (version 1.0)
'use server'

import { verifyAdmin } from '@headlines/auth';

function convertToCSV(data, columns) {
    if (!data || data.length === 0) {
        return '';
    }
    
    // Use the provided column headers, or generate from the first object's keys
    const headers = columns ? columns.map(c => c.header) : Object.keys(data[0]);
    const csvRows = [headers.join(',')];

    for (const row of data) {
        const values = headers.map(header => {
            // Find the key corresponding to the header
            const column = columns ? columns.find(c => c.header === header) : { key: header };
            let value = column ? row[column.key] : '';

            // Handle nested data like contactDetails.email
            if (column && column.key.includes('.')) {
                value = column.key.split('.').reduce((o, i) => (o ? o[i] : ''), row);
            }

            if (value === null || value === undefined) {
                value = '';
            }
            
            // Handle arrays (like whyContact)
            if (Array.isArray(value)) {
                value = value.join('; ');
            }

            const stringValue = String(value);
            // Escape quotes and handle commas
            const escaped = stringValue.replace(/"/g, '""');
            if (escaped.includes(',')) {
                return `"${escaped}"`;
            }
            return escaped;
        });
        csvRows.push(values.join(','));
    }

    return csvRows.join('\n');
}


export async function exportOpportunitiesToCSV(data) {
    const { isAdmin, error } = await verifyAdmin();
    if (!isAdmin) return { success: false, error };

    try {
        const columns = [
            { header: 'Country', key: 'basedIn' },
            { header: 'City', key: 'city' },
            { header: 'Contact', key: 'reachOutTo' },
            { header: 'Wealth ($M)', key: 'likelyMMDollarWealth' },
            { header: 'Email', key: 'contactDetails.email' },
            { header: 'Reason', key: 'whyContact' },
            { header: 'Created', key: 'createdAt' },
        ];
        const csv = convertToCSV(data, columns);
        return { success: true, data: csv };
    } catch (e) {
        return { success: false, error: 'Failed to generate CSV.' };
    }
}

```

## 📄 .tmp_backups/data-access/src/actions/opportunities.js.bak
*Lines: 98, Size: 3.21 KB*

```
// packages/data-access/src/actions/opportunities.js (version 2.1.0)
'use server'

import dbConnect from '../dbConnect.js'
import { Opportunity, Subscriber } from '@headlines/models'
import { revalidatePath } from '../revalidate.js'
import { buildQuery } from '../queryBuilder.js'
import { getUserIdFromSession } from '@headlines/auth/src/verifySession.js'
import mongoose from 'mongoose'

const OPPORTUNITIES_PER_PAGE = 10

export async function getOpportunities({ page = 1, filters = {}, sort = 'date_desc' }) {
  const userId = await getUserIdFromSession()
  await dbConnect()
  const { queryFilter, sortOptions } = await buildQuery(Opportunity, {
    filters,
    sort,
    userId,
  })
  const skipAmount = (page - 1) * OPPORTUNITIES_PER_PAGE

  const opportunities = await Opportunity.find(queryFilter)
    .populate({
      path: 'events',
      select:
        'synthesized_headline synthesized_summary source_articles highest_relevance_score',
      options: { limit: 1, sort: { createdAt: -1 } },
    })
    .sort(sortOptions)
    .skip(skipAmount)
    .limit(OPPORTUNITIES_PER_PAGE)
    .lean()

  const processed = opportunities.map((opp) => ({
    ...opp,
    sourceEventId: opp.events?.[0] || null,
  }))
  return JSON.parse(JSON.stringify(processed))
}

export async function getTotalOpportunitiesCount({ filters = {} } = {}) {
  const userId = await getUserIdFromSession()
  await dbConnect()
  const { queryFilter } = await buildQuery(Opportunity, { filters, userId })
  return await Opportunity.countDocuments(queryFilter)
}

export async function deleteOpportunity({ opportunityId, userId }) {
  if (!opportunityId) return { success: false, message: 'ID is required.' }
  try {
    await dbConnect()
    if (userId) {
      await Subscriber.updateOne(
        { _id: userId },
        { $addToSet: { 'discardedItems.opportunities': opportunityId } }
      )
    }
    await revalidatePath('/opportunities')
    return { success: true, message: 'Opportunity discarded.' }
  } catch (error) {
    return { success: false, message: 'Failed to discard opportunity.' }
  }
}

// NEW FUNCTION for Project Drill Down
export async function getOpportunityDetails(opportunityId) {
  if (!mongoose.Types.ObjectId.isValid(opportunityId)) {
    return { success: false, error: 'Invalid ID format.' }
  }
  try {
    await dbConnect()
    const opportunity = await Opportunity.findById(opportunityId)
      .populate({
        path: 'events',
        options: { sort: { createdAt: -1 } }, // Sort events by most recent
      })
      .lean()

    if (!opportunity) {
      return { success: false, error: 'Opportunity not found.' }
    }

    return { success: true, data: JSON.parse(JSON.stringify(opportunity)) }
  } catch (error) {
    return { success: false, error: 'Database error while fetching opportunity details.' }
  }
}

export async function getUniqueOpportunityCountries() {
  const userId = await getUserIdFromSession();
  await dbConnect();
  const { queryFilter } = await buildQuery(Opportunity, { userId });
  // Use distinct to get a list of unique 'basedIn' values that are not null/empty
  const countries = await Opportunity.distinct('basedIn', { ...queryFilter, basedIn: { $ne: null, $ne: '' } });
  return JSON.parse(JSON.stringify(countries.sort()));
}

```

## 📄 .tmp_backups/data-access/src/actions/upload.js.bak
*Lines: 69, Size: 2.3 KB*

```
// packages/data-access/src/actions/upload.js (version 1.0)
'use server'

import { revalidatePath } from '../revalidate.js'
import { SynthesizedEvent, Opportunity } from '@headlines/models'
import { verifySession } from '@headlines/auth'
// DEFINITIVE FIX: Corrected the import path to be explicit.
import {
  assessArticleContent,
  synthesizeEvent,
  generateOpportunitiesFromEvent,
} from '@headlines/scraper-logic/src/ai/index.js'

// This is a simplified, single-item pipeline for uploaded content.
export async function processUploadedArticle(item) {
  const { user, error } = await verifySession()
  if (!user) return { success: false, error: error || 'Authentication required' }

  try {
    // 1. Assess & Enrich (Simulated)
    // We treat the uploaded content as already enriched.
    const enrichedArticle = {
      ...item,
      relevance_article: 100, // Assume high relevance for manual uploads
      assessment_article: item.article,
      articleContent: { contents: [item.article] },
      newspaper: 'Manual Upload',
      country: 'Denmark', // Default or could be a param
      key_individuals: [], // Will be extracted during synthesis
    }

    // 2. Synthesize Event
    const synthesizedResult = await synthesizeEvent([enrichedArticle], [], '', '')
    if (!synthesizedResult || !synthesizedResult.headline) {
      throw new Error('AI failed to synthesize an event from the provided text.')
    }

    const eventToSave = new SynthesizedEvent({
      ...synthesizedResult,
      event_key: `manual-${new Date().toISOString()}`,
      highest_relevance_score: 100,
      source_articles: [
        { headline: item.headline, link: '#manual', newspaper: 'Manual Upload' },
      ],
    })

    // 3. Generate Opportunities
    const opportunitiesToSave = await generateOpportunitiesFromEvent(eventToSave, [
      enrichedArticle,
    ])

    // 4. Save to DB
    await eventToSave.save()
    if (opportunitiesToSave.length > 0) {
      await Opportunity.insertMany(
        opportunitiesToSave.map((opp) => ({ ...opp, events: [eventToSave._id] }))
      )
    }

    await revalidatePath('/events')
    await revalidatePath('/opportunities')

    return { success: true, event: eventToSave.synthesized_headline }
  } catch (e) {
    console.error('[Upload Action Error]:', e)
    return { success: false, error: e.message }
  }
}

```

## 📄 .tmp_backups/data-access/src/actions/watchlist.js.bak
*Lines: 87, Size: 3.2 KB*

```
// packages/data-access/src/actions/watchlist.js (version 1.1.0)
'use server'

import { revalidatePath } from '../revalidate.js'
import { WatchlistEntity, Article } from '@headlines/models'
import { verifyAdmin } from '@headlines/auth'
import dbConnect from '../dbConnect.js'

export async function getAllWatchlistEntities() {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()
    const entities = await WatchlistEntity.find({}).sort({ name: 1 }).lean()
    return { success: true, data: JSON.parse(JSON.stringify(entities)) }
  } catch (e) {
    return { success: false, error: 'Failed to fetch watchlist.' }
  }
}

export async function createWatchlistEntity(entityData) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()
    const newEntity = new WatchlistEntity(entityData)
    await newEntity.save()
    await revalidatePath('/admin/watchlist')
    return { success: true, data: JSON.parse(JSON.stringify(newEntity)) }
  } catch (e) {
    if (e.code === 11000) return { success: false, error: 'An entity with this name already exists.' }
    return { success: false, error: 'Failed to create entity.' }
  }
}

export async function updateWatchlistEntity(entityId, updateData) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()

    // If searchTerms are being updated, recalculate the hitCount.
    if (updateData.searchTerms && Array.isArray(updateData.searchTerms)) {
      // Sanitize and unique the terms
      updateData.searchTerms = [...new Set(updateData.searchTerms.map(t => t.toLowerCase().trim()).filter(Boolean))];
      
      const entity = await WatchlistEntity.findById(entityId).select('name').lean();
      const allTerms = [entity.name, ...updateData.searchTerms].map(t => t.toLowerCase().trim()).filter(Boolean);
      const uniqueTerms = [...new Set(allTerms)];

      if (uniqueTerms.length > 0) {
        const termRegexes = uniqueTerms.map(term => new RegExp(`\\b${term.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\b`, 'i'));
        const newHitCount = await Article.countDocuments({ headline: { $in: termRegexes } });
        updateData.hitCount = newHitCount;
      } else {
        updateData.hitCount = 0;
      }
    }
    
    const entity = await WatchlistEntity.findByIdAndUpdate(entityId, { $set: updateData }, { new: true }).lean()
    if (!entity) return { success: false, error: 'Entity not found.' }
    
    await revalidatePath('/admin/watchlist')
    return { success: true, data: JSON.parse(JSON.stringify(entity)) }
  } catch (e) {
    return { success: false, error: 'Failed to update entity.' }
  }
}

export async function deleteWatchlistEntity(entityId) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()
    const result = await WatchlistEntity.findByIdAndDelete(entityId)
    if (!result) return { success: false, error: 'Entity not found.' }
    await revalidatePath('/admin/watchlist')
    return { success: true }
  } catch (e) {
    return { success: false, error: 'Failed to delete entity.' }
  }
}

```

## 📄 .tmp_backups/data-access/src/index.js.bak
*Lines: 160, Size: 3.78 KB*

```
// packages/data-access/src/index.js (version 4.4.0)
'use server'

import {
  getAdminArticles,
  updateAdminArticle,
  deleteAdminArticle,
} from './actions/adminArticles.js'
import {
  getAdminEvents,
  getAdminEventDetails,
  updateAdminEvent,
  deleteAdminEvent,
} from './actions/adminEvents.js'
import {
  getAdminOpportunities,
  updateAdminOpportunity,
  deleteAdminOpportunity,
} from './actions/adminOpportunities.js'
import { deleteArticle, getArticles, getTotalArticleCount } from './actions/articles.js'
import { deleteEvent, getEvents, getTotalEventCount } from './actions/events.js'
import {
  getOpportunities,
  getTotalOpportunitiesCount,
  deleteOpportunity,
  getOpportunityDetails,
  getUniqueOpportunityCountries,
} from './actions/opportunities.js'
// DEFINITIVE FIX: Import from the now-guaranteed-to-exist upload.js file.
import { processUploadedArticle } from './actions/upload.js'
import { exportOpportunitiesToCSV } from './actions/export.js';
import { updateUserProfile, updateUserInteraction } from './actions/subscriber.js'
import {
  getAllCountries,
  createCountry,
  updateCountry,
  getGlobalCountries,
} from './actions/countries.js'
import {
  getAllSubscribers,
  createSubscriber,
  updateSubscriber,
  deleteSubscriber,
  updateSubscribersStatus,
  deleteSubscribers,
} from './actions/admin.js'
import {
  getAllSources,
  createSource,
  updateSource,
  deleteSource,
} from './actions/adminSources.js'
import { getDashboardStats } from './actions/dashboard.js'
import { getRecentRunVerdicts, getRunVerdictById } from './actions/verdicts.js'
import {
  getSuggestions,
  processWatchlistSuggestion,
  processSourceSuggestion,
} from './actions/suggestions.js'
import {
  getAllWatchlistEntities,
  createWatchlistEntity,
  updateWatchlistEntity,
  deleteWatchlistEntity,
} from './actions/watchlist.js'
import { getSettings, updateSettings } from './actions/settings.js'
import { testSourceConfig } from './actions/scrape.js'
import {
  updateSourceAnalyticsBatch,
  findSourcesForScraping,
  performHousekeeping,
  bulkWriteEvents,
  bulkWriteArticles,
  findEventsByKeys,
  findArticlesByLinks,
  getActiveWatchlistEntityNames,
  bulkWriteWatchlistSuggestions,
} from './actions/pipeline.js'

export {
  // admin pages
  getAdminArticles,
  updateAdminArticle,
  deleteAdminArticle,
  getAdminEvents,
  getAdminEventDetails,
  updateAdminEvent,
  deleteAdminEvent,
  getAdminOpportunities,
  updateAdminOpportunity,
  deleteAdminOpportunity,
  // articles
  deleteArticle,
  getArticles,
  getTotalArticleCount,
  // events
  deleteEvent,
  getEvents,
  getTotalEventCount,
  // opportunities
  getOpportunities,
  getTotalOpportunitiesCount,
  deleteOpportunity,
  getOpportunityDetails,
  getUniqueOpportunityCountries,
  // subscriber
  updateUserProfile,
  updateUserInteraction,
  // countries
  getAllCountries,
  createCountry,
  updateCountry,
  getGlobalCountries,
  // admin (users)
  getAllSubscribers,
  createSubscriber,
  updateSubscriber,
  deleteSubscriber,
  updateSubscribersStatus,
  deleteSubscribers,
  // admin (sources)
  getAllSources,
  createSource,
  updateSource,
  deleteSource,
  // dashboard
  getDashboardStats,
  // verdicts
  getRecentRunVerdicts,
  getRunVerdictById,
  // suggestions
  getSuggestions,
  processWatchlistSuggestion,
  processSourceSuggestion,
  // watchlist
  getAllWatchlistEntities,
  createWatchlistEntity,
  updateWatchlistEntity,
  deleteWatchlistEntity,
  // settings
  getSettings,
  updateSettings,
  // scrape
  testSourceConfig,
  // pipeline
  updateSourceAnalyticsBatch,
  findSourcesForScraping,
  performHousekeeping,
  bulkWriteEvents,
  bulkWriteArticles,
  findEventsByKeys,
  findArticlesByLinks,
  getActiveWatchlistEntityNames,
  bulkWriteWatchlistSuggestions,
  // upload
  processUploadedArticle,
  exportOpportunitiesToXLSX,
  exportOpportunitiesToCSV,
}

```

## 📄 .tmp_backups/data-access/src/queryBuilder.js.bak
*Lines: 79, Size: 2.67 KB*

```
// packages/data-access/src/queryBuilder.js (version 2.2.0)
'use server'

import { Subscriber } from '@headlines/models'

export async function buildQuery(
  model,
  { filters = {}, sort = 'date_desc', baseQuery = {}, userId = null }
) {
  const andConditions = [{ ...baseQuery }]

  // Text search condition
  if (filters.q) {
    const searchRegex = { $regex: filters.q, $options: 'i' }
    const textSearchablePaths = Object.keys(model.schema.paths).filter(
      (p) => model.schema.paths[p].instance === 'String'
    )
    const orConditions = textSearchablePaths.map((path) => ({ [path]: searchRegex }))
    if (orConditions.length > 0) andConditions.push({ $or: orConditions })
  }

  // Country filter condition
  if (filters.country && Array.isArray(filters.country) && filters.country.length > 0) {
    const countryField = model.schema.paths.basedIn ? 'basedIn' : 'country'
    andConditions.push({ [countryField]: { $in: filters.country } })
  } else if (filters.country && typeof filters.country === 'string') {
    const countryField = model.schema.paths.basedIn ? 'basedIn' : 'country'
    andConditions.push({ [countryField]: filters.country })
  }

  // DEFINITIVE FIX: Add logic to handle the 'withEmail' filter.
  // This checks that the nested 'email' field exists and is not null or an empty string.
  if (filters.withEmail) {
    andConditions.push({ 'contactDetails.email': { $exists: true, $ne: null, $ne: '' } })
  }

  // Favorites filter
  if (filters.favoritesOnly && userId) {
    const user = await Subscriber.findById(userId).select('favoritedItems').lean()
    const modelName = model.modelName.toLowerCase()
    const favoritedIds = user?.favoritedItems?.[`${modelName}s`] || []
    andConditions.push({ _id: { $in: favoritedIds } })
  }

  // Filter out discarded items if a user is specified
  if (userId) {
    const user = await Subscriber.findById(userId).select('discardedItems').lean()
    if (user && user.discardedItems) {
      const modelName = model.modelName.toLowerCase()
      const discardedIds = user.discardedItems[`${modelName}s`]
      if (discardedIds && discardedIds.length > 0) {
        andConditions.push({ _id: { $nin: discardedIds } })
      }
    }
  }

  const queryFilter =
    andConditions.length > 1 ? { $and: andConditions } : andConditions[0] || {}

  const sortOptions = {}
  switch (sort) {
    case 'date_asc':
      sortOptions.createdAt = 1
      break
    case 'relevance_desc':
      sortOptions.highest_relevance_score = -1
      sortOptions.relevance_article = -1
      break
    case 'size_desc':
      sortOptions.likelyMMDollarWealth = -1
      break
    default:
      sortOptions.createdAt = -1
      break
  }

  return { queryFilter, sortOptions }
}

```

## 📄 .tmp_backups/models/Opportunity.js.bak
*Lines: 37, Size: 985 Bytes*

```
// packages/models/src/Opportunity.js (version 6.1.0)
import mongoose from 'mongoose'

const { Schema, model, models } = mongoose

const ContactDetailsSchema = new Schema(
  {
    email: { type: String, trim: true },
    role: { type: String, trim: true },
    company: { type: String, trim: true },
  },
  { _id: false }
)

const OpportunitySchema = new Schema(
  {
    reachOutTo: { type: String, required: true, trim: true, unique: true, index: true },
    contactDetails: { type: ContactDetailsSchema },
    basedIn: { type: String, trim: true, index: true },
    whyContact: { type: [String], required: true }, // Changed to array
    likelyMMDollarWealth: { type: Number, required: true, default: 0 },
    events: [
      {
        type: Schema.Types.ObjectId,
        ref: 'SynthesizedEvent',
        index: true,
      },
    ],
  },
  {
    timestamps: true,
    collection: 'opportunities',
  }
)

export default models.Opportunity || model('Opportunity', OpportunitySchema)

```

## 📄 .tmp_backups/models/Subscriber.js.bak
*Lines: 76, Size: 2.4 KB*

```
// packages/models/src/Subscriber.js (version 3.5.0)
import mongoose from 'mongoose'
import bcrypt from 'bcrypt'
import { SUBSCRIBER_ROLES, SUBSCRIPTION_TIERS } from './constants.js'

const { Schema, model, models } = mongoose
const SALT_WORK_FACTOR = 10

const CountrySubscriptionSchema = new Schema(
  {
    name: { type: String, required: true },
    active: { type: Boolean, default: true, required: true },
  },
  { _id: false }
)

const InteractionSchema = new Schema(
  {
    articles: { type: [String], default: [] },
    events: { type: [String], default: [] },
    opportunities: { type: [String], default: [] },
  },
  { _id: false }
)

const SubscriberSchema = new Schema(
  {
    email: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
      index: true,
    },
    password: { type: String, required: true, select: false },
    firstName: { type: String, required: true, trim: true },
    lastName: { type: String, required: false, trim: true },
    language: { type: String, required: true, default: 'English' },
    countries: { type: [CountrySubscriptionSchema], required: true, default: [] },
    role: { type: String, enum: SUBSCRIBER_ROLES, default: 'user', required: true },
    emailNotificationsEnabled: { type: Boolean, default: true },
    pushNotificationsEnabled: { type: Boolean, default: true },
    subscriptionTier: { type: String, enum: SUBSCRIPTION_TIERS, default: 'free' },
    subscriptionExpiresAt: { type: Date, default: null },
    isLifetimeFree: { type: Boolean, default: false },
    isActive: { type: Boolean, default: true, index: true },
    lastLoginAt: { type: Date, default: null },
    discardedItems: { type: InteractionSchema, default: () => ({}) },
    favoritedItems: { type: InteractionSchema, default: () => ({}) },
    // --- NEW COUNTERS ---
    emailSentCount: { type: Number, default: 0 },
    eventsReceivedCount: { type: Number, default: 0 },
  },
  {
    timestamps: true,
    collection: 'subscribers',
  }
)

SubscriberSchema.pre('save', function (next) {
  const user = this
  if (!user.isModified('password')) return next()

  bcrypt.genSalt(SALT_WORK_FACTOR, function (err, salt) {
    if (err) return next(err)
    bcrypt.hash(user.password, salt, function (err, hash) {
      if (err) return next(err)
      user.password = hash
      next()
    })
  })
})

export default models.Subscriber || model('Subscriber', SubscriberSchema)

```

## 📄 .tmp_backups/models/SynthesizedEvent.js.bak
*Lines: 79, Size: 2.63 KB*

```
// packages/models/src/SynthesizedEvent.js (version 5.4.0)
import mongoose from 'mongoose'

const { Schema, model, models } = mongoose

const SourceArticleSchema = new Schema(
  {
    headline: { type: String, required: true, trim: true },
    link: { type: String, required: true, trim: true },
    newspaper: { type: String, required: true, trim: true },
    imageUrl: { type: String, trim: true },
  },
  { _id: false }
)

const KeyIndividualSchema = new Schema(
  {
    name: { type: String, trim: true },
    role_in_event: { type: String, trim: true },
    company: { type: String, trim: true },
    email_suggestion: { type: String, trim: true },
  },
  { _id: false }
)

const SynthesizedEventSchema = new Schema(
  {
    event_key: { type: String, required: true, unique: true, trim: true, index: true },
    synthesized_headline: { type: String, required: true, trim: true },
    synthesized_summary: { type: String, required: true, trim: true },
    advisorSummary: { type: String, trim: true }, // NEW FIELD
    ai_assessment_reason: { type: String, trim: true },
    eventClassification: { type: String, trim: true },
    country: { type: String, required: true, index: true },
    source_articles: { type: [SourceArticleSchema], required: true },
    highest_relevance_score: { type: Number, required: true, min: 0, max: 100 },
    key_individuals: { type: [KeyIndividualSchema], default: [] },
    relatedOpportunities: [
      { type: Schema.Types.ObjectId, ref: 'Opportunity', index: true },
    ],
    enrichmentSources: {
      type: [String],
      enum: ['rag_db', 'wikipedia', 'news_api'],
      default: [],
    },
    event_date: { type: Date, default: Date.now, index: true },
    emailed: { type: Boolean, default: false },
    email_sent_at: { type: Date },
  },
  {
    timestamps: true,
    collection: 'synthesized_events',
    methods: {
      toRealtimePayload() {
        return {
          _id: this._id,
          synthesized_headline: this.synthesized_headline,
          synthesized_summary: this.synthesized_summary,
          country: this.country,
          highest_relevance_score: this.highest_relevance_score,
          key_individuals: (this.key_individuals || []).map((p) => p.name),
          opportunity_count: (this.relatedOpportunities || []).length,
          source_article_count: (this.source_articles || []).length,
          createdAt: this.createdAt,
        }
      },
    },
  }
)

SynthesizedEventSchema.index({
  synthesized_headline: 'text',
  synthesized_summary: 'text',
})
SynthesizedEventSchema.index({ country: 1, createdAt: -1 })

export default models.SynthesizedEvent ||
  model('SynthesizedEvent', SynthesizedEventSchema)

```

## 📄 .tmp_backups/models/src/Article.js.bak
*Lines: 93, Size: 3.1 KB*

```
// packages/models/src/Article.js (version 3.5.0)
import mongoose from 'mongoose'
import { ARTICLE_STATUSES } from './constants.js'

const { Schema, model, models } = mongoose

const LifecycleEventSchema = new Schema(
  {
    stage: { type: String, required: true },
    status: { type: String, required: true },
    reason: { type: String },
    timestamp: { type: Date, default: Date.now },
  },
  { _id: false }
)

const ArticleSchema = new Schema(
  {
    headline: { type: String, required: true, trim: true, minlength: 5, maxlength: 500 },
    headline_en: { type: String, trim: true },
    link: { type: String, required: true, unique: true, trim: true },
    newspaper: { type: String, required: true, trim: true },
    source: { type: String, required: true, trim: true },
    country: { type: String, trim: true, index: true },
    imageUrl: { type: String, trim: true },
    headline_selector: { type: String, trim: true },
    relevance_headline: { type: Number, required: true, min: 0, max: 100 },
    assessment_headline: { type: String, required: true, trim: true },

    // --- NEW FIELD ---
    classification: { type: String, trim: true },

    topic: { type: String, trim: true },
    relevance_article: { type: Number, min: 0, max: 100 },
    assessment_article: { type: String, trim: true },
    amount: { type: Number },
    key_individuals: [
      {
        _id: false,
        name: { type: String, trim: true },
        role_in_event: { type: String, trim: true },
        company: { type: String, trim: true },
        email_suggestion: { type: String, trim: true },
      },
    ],
    enrichment_error: { type: String, trim: true },
    emailed: { type: Boolean, default: false },
    embedding: { type: [Number] },
    synthesizedEventId: {
      type: Schema.Types.ObjectId,
      ref: 'SynthesizedEvent',
      index: true,
      required: false,
    },
    status: { type: String, enum: ARTICLE_STATUSES, default: 'scraped', index: true },
    pipeline_lifecycle: { type: [LifecycleEventSchema], default: [] },
  },
  {
    timestamps: true,
    collection: 'articles',
    methods: {
      toRealtimePayload() {
        return {
          _id: this._id,
          headline: this.headline,
          headline_en: this.headline_en,
          link: this.link,
          newspaper: this.newspaper,
          country: this.country,
          topic: this.topic,
          relevance_article: this.relevance_article,
          assessment_article: this.assessment_article,
          key_individuals: (this.key_individuals || []).map((p) => ({
            name: p.name,
            role_in_event: p.role_in_event,
            company: p.company,
          })),
          createdAt: this.createdAt,
          updatedAt: this.updatedAt,
        }
      },
    },
  }
)

ArticleSchema.index({ headline: 'text', headline_en: 'text', assessment_article: 'text' })
ArticleSchema.index({ newspaper: 1, createdAt: -1 })
ArticleSchema.index({ relevance_article: -1, createdAt: -1 })
ArticleSchema.index({ relevance_headline: -1, createdAt: -1 })
ArticleSchema.index({ country: 1, createdAt: -1 })

export default models.Article || model('Article', ArticleSchema)

```

## 📄 .tmp_backups/models/src/Opportunity.js.bak
*Lines: 39, Size: 1.13 KB*

```
// packages/models/src/Opportunity.js (version 6.1.0)
import mongoose from 'mongoose'

const { Schema, model, models } = mongoose

const ContactDetailsSchema = new Schema(
  {
    email: { type: String, trim: true },
    role: { type: String, trim: true },
    company: { type: String, trim: true },
  },
  { _id: false }
)

const OpportunitySchema = new Schema(
  {
    reachOutTo: { type: String, required: true, trim: true, unique: true, index: true },
    contactDetails: { type: ContactDetailsSchema },
    basedIn: { type: String, trim: true, index: true },
    whyContact: { type: [String], required: true },
    likelyMMDollarWealth: { type: Number, required: true, default: 0 },
    events: [
      {
        type: Schema.Types.ObjectId,
        ref: 'SynthesizedEvent',
        index: true,
      },
    ],
    // DEFINITIVE FIX v6: The simplest possible implementation for a self-referencing array of ObjectIds.
    relatedOpportunities: [{ type: Schema.Types.ObjectId, ref: 'Opportunity' }],
  },
  {
    timestamps: true,
    collection: 'opportunities',
  }
)

export default models.Opportunity || model('Opportunity', OpportunitySchema)

```

## 📄 .tmp_backups/models/src/Source.js.bak
*Lines: 67, Size: 2.25 KB*

```
// packages/models/src/Source.js (version 4.6.0)
import mongoose from 'mongoose'
import { SOURCE_STATUSES, SOURCE_FREQUENCIES, EXTRACTION_METHODS } from './constants.js'

const { Schema, model, models } = mongoose

const SourceAnalyticsSchema = new Schema(
  {
    totalRuns: { type: Number, default: 0 },
    totalSuccesses: { type: Number, default: 0 },
    totalFailures: { type: Number, default: 0 },
    totalScraped: { type: Number, default: 0 },
    totalRelevant: { type: Number, default: 0 },
    lastRunHeadlineCount: { type: Number, default: 0 },
    lastRunRelevantCount: { type: Number, default: 0 },
    lastRunContentSuccess: { type: Boolean, default: false },
  },
  { _id: false }
)

const SourceSchema = new Schema(
  {
    name: { type: String, required: true, unique: true, trim: true },
    baseUrl: { type: String, required: true, trim: true },
    sectionUrl: { type: String, required: true, trim: true },
    rssUrl: { type: String, required: false, trim: true },
    country: { type: String, required: true, trim: true, index: true },
    language: { type: String, required: true, trim: true, default: 'en' },
    status: {
      type: String,
      enum: SOURCE_STATUSES,
      default: 'active',
      required: true,
      index: true,
    },
    scrapeFrequency: {
      type: String,
      enum: SOURCE_FREQUENCIES,
      default: 'high',
      required: true,
    },
    extractionMethod: {
      type: String,
      enum: EXTRACTION_METHODS,
      required: true,
      default: 'declarative',
    },
    headlineSelector: { type: [String], required: false },
    linkSelector: { type: String, required: false, trim: true },
    headlineTextSelector: { type: String, required: false, trim: true },
    articleSelector: { type: [String], required: false },
    lastScrapedAt: { type: Date, required: false, index: true },
    lastSuccessAt: { type: Date, required: false },
    notes: { type: String, required: false, trim: true },
    analytics: { type: SourceAnalyticsSchema, default: () => ({}) },
  },
  {
    timestamps: true,
    collection: 'sources',
  }
)

SourceSchema.index({ status: 1, scrapeFrequency: 1, lastScrapedAt: 1 })
SourceSchema.index({ 'analytics.lastRunHeadlineCount': 1, status: 1 })

export default models.Source || model('Source', SourceSchema)

```

## 📄 .tmp_backups/models/src/SynthesizedEvent.js.bak
*Lines: 79, Size: 2.63 KB*

```
// packages/models/src/SynthesizedEvent.js (version 5.4.0)
import mongoose from 'mongoose'

const { Schema, model, models } = mongoose

const SourceArticleSchema = new Schema(
  {
    headline: { type: String, required: true, trim: true },
    link: { type: String, required: true, trim: true },
    newspaper: { type: String, required: true, trim: true },
    imageUrl: { type: String, trim: true },
  },
  { _id: false }
)

const KeyIndividualSchema = new Schema(
  {
    name: { type: String, trim: true },
    role_in_event: { type: String, trim: true },
    company: { type: String, trim: true },
    email_suggestion: { type: String, trim: true },
  },
  { _id: false }
)

const SynthesizedEventSchema = new Schema(
  {
    event_key: { type: String, required: true, unique: true, trim: true, index: true },
    synthesized_headline: { type: String, required: true, trim: true },
    synthesized_summary: { type: String, required: true, trim: true },
    advisorSummary: { type: String, trim: true }, // NEW FIELD
    ai_assessment_reason: { type: String, trim: true },
    eventClassification: { type: String, trim: true },
    country: { type: String, required: true, index: true },
    source_articles: { type: [SourceArticleSchema], required: true },
    highest_relevance_score: { type: Number, required: true, min: 0, max: 100 },
    key_individuals: { type: [KeyIndividualSchema], default: [] },
    relatedOpportunities: [
      { type: Schema.Types.ObjectId, ref: 'Opportunity', index: true },
    ],
    enrichmentSources: {
      type: [String],
      enum: ['rag_db', 'wikipedia', 'news_api'],
      default: [],
    },
    event_date: { type: Date, default: Date.now, index: true },
    emailed: { type: Boolean, default: false },
    email_sent_at: { type: Date },
  },
  {
    timestamps: true,
    collection: 'synthesized_events',
    methods: {
      toRealtimePayload() {
        return {
          _id: this._id,
          synthesized_headline: this.synthesized_headline,
          synthesized_summary: this.synthesized_summary,
          country: this.country,
          highest_relevance_score: this.highest_relevance_score,
          key_individuals: (this.key_individuals || []).map((p) => p.name),
          opportunity_count: (this.relatedOpportunities || []).length,
          source_article_count: (this.source_articles || []).length,
          createdAt: this.createdAt,
        }
      },
    },
  }
)

SynthesizedEventSchema.index({
  synthesized_headline: 'text',
  synthesized_summary: 'text',
})
SynthesizedEventSchema.index({ country: 1, createdAt: -1 })

export default models.SynthesizedEvent ||
  model('SynthesizedEvent', SynthesizedEventSchema)

```

## 📄 .tmp_backups/pipeline/run.sh.bak
*Lines: 16, Size: 616 Bytes*

```
#!/bin/bash
# This script executes the pipeline directly from the monorepo root.

# Get the directory of this script to reliably find the monorepo root.
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
MONOREPO_ROOT="$(dirname "$SCRIPT_DIR")"

# Change to the monorepo root directory.
cd "$MONOREPO_ROOT"

echo "Executing pipeline from: $(pwd)"
echo "---"

# Execute the pipeline's main script using paths relative to the monorepo root.
# "$@" passes all arguments from this script to the node script (e.g., ./run.sh --country Denmark).
node --env-file=./.env apps/pipeline/src/app.js "$@"
```

## 📄 .tmp_backups/pipeline/scripts/maintenance/pipeline-correct-countries.js.bak
*Lines: 81, Size: 2.96 KB*

```
// apps/pipeline/scripts/maintenance/pipeline-correct-countries.js (version 1.0)
'use server'

import mongoose from 'mongoose';
import { Opportunity } from '@headlines/models';
import dbConnect from '@headlines/data-access/src/dbConnect.js';
import { logger, reinitializeLogger } from '@headlines/utils/server';
import { countryCorrectionChain } from '@headlines/ai-services';
import { initializeScriptEnv } from '../seed/lib/script-init.js';
import colors from 'ansi-colors';
import cliProgress from 'cli-progress';
import path from 'path';

reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'));

async function main() {
  await initializeScriptEnv();
  logger.info('🚀 Starting Retrospective Country Data Cleanup (Efficient Mode)...');

  try {
    // DEFINITIVE FIX 1: Find the unique set of all 'basedIn' values.
    const allBasedInValues = await Opportunity.distinct('basedIn');
    
    if (allBasedInValues.length === 0) {
        logger.info('✅ No opportunities with country data found to scan.');
        return;
    }

    logger.info(`Found ${allBasedInValues.length} unique 'basedIn' values to analyze...`);
    
    const bulkOps = [];
    const progressBar = new cliProgress.SingleBar({
        format: `Analyzing | ${colors.cyan('{bar}')} | {percentage}% || {value}/{total} Unique Locations`,
        barCompleteChar: '\u2588',
        barIncompleteChar: '\u2591',
        hideCursor: true,
    });
    progressBar.start(allBasedInValues.length, 0);

    for (const originalCountry of allBasedInValues) {
        // Skip null/empty or already correct-looking values
        if (!originalCountry || originalCountry.length < 3 || !originalCountry.includes(' ')) {
            progressBar.increment();
            continue;
        }

        // DEFINITIVE FIX 2: Use direct await, not .invoke
        const result = await countryCorrectionChain({ location_string: originalCountry });

        if (result && !result.error && result.country && result.country !== originalCountry) {
            logger.info(`Correction found: "${originalCountry}" -> "${result.country}"`);
            bulkOps.push({
                updateMany: {
                    filter: { basedIn: originalCountry },
                    update: { $set: { basedIn: result.country } }
                }
            });
        }
        progressBar.increment();
    }
    progressBar.stop();

    if (bulkOps.length > 0) {
        logger.info(`Found ${bulkOps.length} unique corrections to apply. Applying bulk update...`);
        const result = await Opportunity.bulkWrite(bulkOps);
        logger.info(colors.green(`✅ Cleanup complete. Modified ${result.modifiedCount} opportunity documents.`));
    } else {
        logger.info('✅ No country corrections were needed. Database is clean.');
    }

  } catch (error) {
    logger.error({ err: error }, 'An error occurred during the country cleanup process.');
  } finally {
    if (mongoose.connection.readyState === 1){
        await mongoose.disconnect();
    }
  }
}

main();

```

## 📄 .tmp_backups/pipeline/scripts/seed/ingest-denmark-richlist.js.bak
*Lines: 120, Size: 4.66 KB*

```
// apps/pipeline/scripts/seed/ingest-denmark-richlist.js
import mongoose from 'mongoose'
import path from 'path'
import { reinitializeLogger, logger } from '@headlines/utils/server'
import { initializeScriptEnv } from './lib/script-init.js'
import { loadAndPrepareDenmarkRichlist } from './lib/denmark-richlist-data-loader.js'
import { Opportunity } from '@headlines/models'
import { contactFinderChain, performGoogleSearch } from '@headlines/ai-services'
import colors from 'ansi-colors'
import pLimit from 'p-limit'

const CONCURRENCY_LIMIT = 5;

async function createOrUpdateOpportunity(person) {
    try {
        const updateResult = await Opportunity.updateOne(
            { reachOutTo: person.name },
            {
                $setOnInsert: {
                    reachOutTo: person.name,
                    basedIn: person.country,
                    city: person.city,
                    likelyMMDollarWealth: person.wealthMillionsUSD,
                    // Initialize contactDetails with company if available
                    contactDetails: {
                        company: person.primaryCompany,
                    }
                },
                $addToSet: { whyContact: { $each: person.whyContact } }
            },
            { upsert: true }
        );

        if (updateResult.upsertedCount > 0) {
            logger.info(colors.green(`  ✅ Created new Opportunity for: ${person.name}`));
        } else if (updateResult.modifiedCount > 0) {
            logger.info(colors.yellow(`  🔄 Updated existing Opportunity for: ${person.name}`));
        } else {
            logger.info(`  ⚪️ No changes for Opportunity: ${person.name}`);
        }
        return { success: true, name: person.name };
    } catch (error) {
        logger.error({ err: error }, `❌ Failed to create/update opportunity for ${person.name}`);
        return { success: false };
    }
}

async function enrichOpportunityWithContact(name) {
    try {
        const opportunity = await Opportunity.findOne({ reachOutTo: name });
        if (!opportunity || opportunity.contactDetails?.email) {
            logger.trace(`  -> Skipping email search for ${name} (already exists or opp not found).`);
            return { success: true, found: false };
        }

        logger.info(`  -> AI Contact Finder: Searching for email for ${name}...`);
        
        // DEFINITIVE FIX: Perform a real web search to get context for the AI.
        const searchQuery = `"${opportunity.reachOutTo}" "${opportunity.contactDetails?.company || ''}" email contact`;
        const searchResult = await performGoogleSearch(searchQuery);

        if (!searchResult.success || !searchResult.snippets) {
            logger.warn(`  -> Web search failed for ${name}. Cannot find email.`);
            return { success: true, found: false };
        }

        const response = await contactFinderChain({ snippets: searchResult.snippets });

        if (response && !response.error && response.email) {
            opportunity.contactDetails.email = response.email;
            await opportunity.save();
            logger.info(colors.green(`    ✅ Found and saved email for ${name}: ${response.email}`));
            return { success: true, found: true };
        } else {
            logger.warn(`    -> AI could not find an email for ${name}.`);
            return { success: true, found: false };
        }
    } catch (error) {
        logger.error({ err: error }, `❌ Failed during contact enrichment for ${name}`);
        return { success: false };
    }
}

async function main() {
  reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'))
  await initializeScriptEnv()
  logger.info('🚀 Starting Denmark Direct-to-Opportunity Ingestion Script...');

  const { allIndividuals } = await loadAndPrepareDenmarkRichlist()
  
  logger.info(`🔥 Launching concurrent processing for ${allIndividuals.length} individuals with a limit of ${CONCURRENCY_LIMIT}...`);

  const limit = pLimit(CONCURRENCY_LIMIT);
  const processingPromises = allIndividuals.map(person => 
    limit(async () => {
      logger.info(colors.cyan(`\n--- Processing: ${person.name} ---`))
      const createResult = await createOrUpdateOpportunity(person);
      if (createResult.success) {
          await enrichOpportunityWithContact(createResult.name);
      }
    })
  );

  await Promise.all(processingPromises);

  logger.info('\n--- Ingestion Summary ---');
  logger.info(colors.green('✅ Script finished. All individuals processed.'));
}

main()
  .catch((err) =>
    logger.fatal({ err }, 'A critical error occurred in the main script execution.')
  )
  .finally(() => {
    if (mongoose.connection.readyState === 1) {
      mongoose.disconnect()
    }
    process.exit(0)
  })

```

## 📄 .tmp_backups/pipeline/scripts/seed/ingest-richlist.js.bak
*Lines: 91, Size: 3.49 KB*

```
// apps/pipeline/scripts/seed/ingest-richlist.js
import mongoose from 'mongoose'
import path from 'path'
import { reinitializeLogger, logger } from '@headlines/utils/server'
import { initializeScriptEnv } from './lib/script-init.js'
import { loadAndPrepareRichlist } from './lib/richlist-data-loader.js'
import { createSyntheticArticle } from './lib/synthetic-article-builder.js'
import { runInjectedPipeline } from './lib/pipeline-injector.js'
import { enrichThinProfile } from './lib/enrich-thin-profile.js'
import { chunkHistoryIntoEvents } from './lib/event-chunker.js'
import colors from 'ansi-colors'

async function main() {
  reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'))
  await initializeScriptEnv()
  logger.info('🚀 Starting Rich List Ingestion Script (Sequential, Verbose Mode)...')

  const { allIndividuals, rawIndividualData } = await loadAndPrepareRichlist()

  logger.info(
    `Preparing to process ${allIndividuals.length} individuals from the ${allIndividuals[0]?.year || 'latest'} rich list...`
  );
  
  let totalEventsCreated = 0;
  let totalOppsCreated = 0;

  // DEFINITIVE FIX: Revert to a sequential for...of loop to ensure logs appear in order.
  for (const person of allIndividuals) {
    logger.info(colors.cyan(`\n--- Analyzing: ${person.name} ---`))

    if (person.isThinProfile) {
      logger.info(colors.magenta(`  📝 Thin profile detected for ${person.name.toUpperCase()}. Triggering AI enrichment...`));
      const rawData = rawIndividualData.find(p => p.name === person.name);
      logger.info({ raw_data: rawData }, `Raw JSON data for ${person.name}`);
      const enrichedData = await enrichThinProfile(person);
      person.background = enrichedData.generated_background;
    }

    const eventChunks = await chunkHistoryIntoEvents(person);

    for (const [index, chunk] of eventChunks.entries()) {
      logger.info(
        colors.bold(
          `  └── Processing event chunk ${index + 1}/${eventChunks.length}: "${chunk.description}"`
        )
      )
      try {
        const syntheticArticle = createSyntheticArticle(person, chunk)

        // The call to this function will now display all its internal logs.
        const { savedEvents, savedOpportunities } =
          await runInjectedPipeline(syntheticArticle)

        if (savedEvents && savedEvents.length > 0) {
          totalEventsCreated += savedEvents.length;
          savedEvents.forEach(event => {
            logger.info(colors.green(`    ✅ Event Created: "${event.synthesized_headline}"`));
          });
        }
        if (savedOpportunities && savedOpportunities.length > 0) {
          totalOppsCreated += savedOpportunities.length;
          savedOpportunities.forEach((opp) => {
            logger.info(colors.green(`    ✅ Opportunity Created: "${opp.reachOutTo}" (~$${opp.likelyMMDollarWealth}M)`));
          });
        }
      } catch (error) {
        logger.error(
          { err: error },
          `    ❌ Failed to process event chunk: "${chunk.description}"`
        )
      }
    }
  }

  logger.info('\n--- Ingestion Summary ---');
  logger.info(colors.green(`✅ Successfully created ${totalEventsCreated} events.`));
  logger.info(colors.green(`✅ Successfully created ${totalOppsCreated} opportunities.`));
  logger.info('✅ Script finished.')
}

main()
  .catch((err) =>
    logger.fatal({ err }, 'A critical error occurred in the main script execution.')
  )
  .finally(() => {
    if (mongoose.connection.readyState === 1) {
      mongoose.disconnect()
    }
    process.exit(0)
  })

```

## 📄 .tmp_backups/pipeline/scripts/seed/lib/denmark-richlist-data-loader.js.bak
*Lines: 77, Size: 2.57 KB*

```
// apps/pipeline/scripts/seed/lib/denmark-richlist-data-loader.js
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import { Opportunity } from '@headlines/models'
import { logger } from '@headlines/utils/server'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const BASE_PATH = path.resolve(__dirname, '../../')
const DKK_TO_USD_RATE = 0.14; // Approximate conversion rate

const cityToCountryMap = {
  "london": "United Kingdom",
  "geneva": "Switzerland",
  "zug": "Switzerland",
  "dubai": "United Arab Emirates",
  "boston": "United States",
  "palo alto": "United States",
  "san francisco": "United States",
  "new york": "United States",
  "los angeles": "United States",
  "frankfurt": "Germany",
  "munich": "Germany",
  "berlin": "Germany",
  "sydney": "Australia",
  "marbella": "Spain",
  "mallorca": "Spain",
  "monte carlo": "Monaco",
  "lugano": "Switzerland",
  "utrecht": "Netherlands",
  "reykjavik": "Iceland",
};

function getCountryFromCity(city) {
    if (!city) return 'Denmark';
    const lowerCity = city.toLowerCase();
    return cityToCountryMap[lowerCity] || 'Denmark';
}

export async function loadAndPrepareDenmarkRichlist() {
  const jsonPath = path.join(BASE_PATH, 'seed/data/denmark.json')
  const rawIndividuals = JSON.parse(fs.readFileSync(jsonPath, 'utf8'))
  
  const uniqueIndividuals = Array.from(new Map(rawIndividuals.map(item => [item['full name'], item])).values());
  logger.info(
    `Loaded ${rawIndividuals.length} total individuals from ${path.basename(jsonPath)}, filtered down to ${uniqueIndividuals.length} unique entries.`
  )

  const existingOppNames = (await Opportunity.find({}).select('reachOutTo').lean()).map(
    (o) => o.reachOutTo
  )
  const existingSet = new Set(existingOppNames)

  const preparedIndividuals = uniqueIndividuals.map((person) => {
    const wealthUSD = person['net worth'] * DKK_TO_USD_RATE;
    const wealthMillionsUSD = Math.round(wealthUSD / 1000000);

    const preparedPersonObject = {
      name: person['full name'],
      city: person.city,
      country: getCountryFromCity(person.city),
      industry: person.industry || 'Finance',
      wealthMillionsUSD: wealthMillionsUSD,
      // The 'event' field from the JSON is now the primary source for 'whyContact'
      whyContact: [person.event],
      primaryCompany: 'Private Equity', // Default, can be refined by AI
      year: new Date().getFullYear(),
      isExisting: existingSet.has(person['full name']),
    };
    
    return preparedPersonObject;
  });

  return { allIndividuals: preparedIndividuals };
}

```

## 📄 .tmp_backups/pipeline/scripts/seed/lib/enrich-thin-profile.js.bak
*Lines: 64, Size: 3.08 KB*

```
// apps/pipeline/scripts/seed/lib/enrich-thin-profile.js
import { callLanguageModel } from '@headlines/ai-services';
import { settings } from '@headlines/config/server';
// DEFINITIVE FIX: Import loggers from the shared utils package
import { logger, auditLogger } from '@headlines/utils/server';
import { z } from 'zod';

const enrichmentSchema = z.object({
  summary: z.string().min(20).describe("The generated 2-3 sentence background summary based on the provided facts."),
});

const createFallbackText = (person) => `This is a wealth profile for ${person.name}, a notable figure in the ${person.industry} sector, primarily associated with the company ${person.primaryCompany}. Their estimated wealth is approximately $${person.wealthMillionsUSD}M USD.`;

/**
 * Uses a direct AI call to generate a background summary for an individual
 * based on structured data from a trusted source (the rich list).
 * The AI's role is to enrich, not to verify, the individual's significance.
 * @param {object} person - A person object from the rich list.
 * @returns {Promise<{generated_background: string}>} The AI-generated or fallback text.
 */
export async function enrichThinProfile(person) {
  logger.info(`  -> AI Enrichment: Attempting to generate background for ${person.name}...`);

  const systemPrompt = `You are a financial biographer. Your task is to synthesize the provided, trusted data points into a concise, professional background summary (2-3 sentences) suitable for a rich list publication. Use your general knowledge to gracefully weave the facts together. If you have no additional public knowledge, simply rephrase the provided data into a coherent summary.

Respond ONLY with a valid JSON object: {"summary": "Your generated text."}`;
  
  const userContent = `
    DATA:
    - Name: ${person.name}
    - Primary Company / Industry: ${person.primaryCompany} / ${person.industry}
    - Estimated Wealth: $${person.wealthMillionsUSD}M USD
    - Country: ${person.country}
  `;

  try {
    auditLogger.info({ context: { system_prompt: systemPrompt, user_content: userContent }}, `Enrichment Input for ${person.name}`);
    const response = await callLanguageModel({
        modelName: settings.LLM_MODEL_UTILITY,
        systemPrompt: systemPrompt,
        userContent: userContent,
        isJson: true,
    });
    auditLogger.info({ context: { llm_response: response }}, `Enrichment Raw Output for ${person.name}`);

    const validation = enrichmentSchema.safeParse(response);

    if (!validation.success) {
      logger.warn(`  -> AI enrichment for ${person.name} failed validation or returned no summary. Using structured fallback text.`, { err: validation.error?.flatten(), raw_response: response });
      return { generated_background: createFallbackText(person) };
    }
    
    logger.info(`  -> AI enrichment successful for ${person.name}.`);
    return { generated_background: validation.data.summary };

  } catch (error) {
    logger.error(
      { err: error },
      `AI enrichment process failed for ${person.name}. Using fallback text.`
    );
    return { generated_background: createFallbackText(person) };
  }
}

```

## 📄 .tmp_backups/pipeline/scripts/seed/lib/event-chunker.js.bak
*Lines: 119, Size: 4.03 KB*

```
// apps/pipeline/scripts/seed/lib/event-chunker.js
import { callLanguageModel } from '@headlines/ai-services'
import { settings } from '@headlines/config/server'
import { logger, auditLogger } from '@headlines/utils/server'
import { z } from 'zod'

const eventChunkSchema = z.object({
  events: z.array(
    z.object({
      date: z.string().describe('Estimated date of the event in YYYY-MM-DD format.'),
      description: z
        .string()
        .describe('A concise, one-sentence summary of the specific event.'),
      participants: z
        .array(z.string())
        .optional()
        .describe('List of key individuals or companies involved.'),
      type: z
        .string()
        .describe("The type of event (e.g., 'Sale', 'IPO', 'Wealth Profile')."),
    })
  ),
})

// --- REINFORCED PROMPT ---
const PROMPT = `You are a financial historian AI. Your task is to read a long biography of a wealthy individual and break it down into a timeline of distinct, significant wealth events.

**CRITICAL INSTRUCTIONS:**
1.  Read the entire background text provided.
2.  Identify specific, discrete events that impacted the person's wealth (e.g., company sales, major investments, IPOs, inheritance).
3.  For each event, extract the estimated date, a concise description, a list of key participants, and a simple event type string.
4.  If the text is a general profile without specific past events, you MUST create a single "Wealth Profile" event for the current year.
5.  Ignore non-financial events.

**OUTPUT FORMAT (MANDATORY):**
You MUST respond ONLY with a valid JSON object. This object MUST contain a single key called "events".
The value of "events" MUST be an ARRAY of event objects.

**EXAMPLE 1 (Multiple Events):**
{
  "events": [
    {
      "date": "1986-01-01",
      "description": "Faced legal issues regarding oil freight charges, but the case was later dropped.",
      "participants": ["John Fredriksen"],
      "type": "Legal Dispute"
    },
    {
      "date": "2007-01-01",
      "description": "Donated 50 million kroner to the Radium hospital for cancer research.",
      "participants": ["John Fredriksen"],
      "type": "Philanthropy"
    }
  ]
}

**EXAMPLE 2 (Single Event):**
{
  "events": [
    {
      "date": "2024-09-15",
      "description": "General wealth profile for a prominent figure in the Shipping industry.",
      "participants": ["John Fredriksen"],
      "type": "Wealth Profile"
    }
  ]
}

Your entire response must be ONLY the JSON object.`

const createFallbackEvent = (person) => {
  return [
    {
      date: `${person.year}-09-15`,
      description: `Wealth profile for ${person.name}, a prominent figure in the ${person.industry} sector with an estimated fortune of $${person.wealthMillionsUSD}M USD.`,
      participants: [person.name],
      type: 'Wealth Profile',
    },
  ]
}

export async function chunkHistoryIntoEvents(person) {
  logger.info(`  -> AI Event Chunker: Analyzing history for ${person.name}...`)
  try {
    auditLogger.info({ context: { background_text: person.background }}, `Event Chunker Input for ${person.name}`);
    const response = await callLanguageModel({
      modelName: settings.LLM_MODEL_UTILITY,
      systemPrompt: PROMPT,
      userContent: person.background,
      isJson: true,
    })
    auditLogger.info({ context: { llm_response: response }}, `Event Chunker Raw Output for ${person.name}`);

    const validation = eventChunkSchema.safeParse(response)
    if (!validation.success) {
      logger.error(
        { err: validation.error.flatten(), raw_response: response },
        'AI response failed Zod validation.'
      )
      return createFallbackEvent(person)
    }

    if (validation.data.events.length === 0) {
      return createFallbackEvent(person)
    }

    logger.info(
      `  -> AI Event Chunker: Identified ${validation.data.events.length} distinct event(s).`
    )
    return validation.data.events
  } catch (error) {
    logger.error(
      { err: error },
      `Event chunking failed for ${person.name}. Creating a single fallback event.`
    )
    return createFallbackEvent(person)
  }
}

```

## 📄 .tmp_backups/pipeline/scripts/seed/lib/pipeline-injector.js.bak
*Lines: 77, Size: 2.67 KB*

```
// apps/pipeline/scripts/seed/lib/pipeline-injector.js
import { runAssessAndEnrich } from '../../../src/pipeline/3_assessAndEnrich.js'
import { runClusterAndSynthesize } from '../../../src/pipeline/4_clusterAndSynthesize.js'
import { judgeAndFilterOutput } from '../../../src/pipeline/submodules/commit/1_judgeOutput.js'
import { saveResultsToDb } from '../../../src/pipeline/submodules/commit/2_saveResults.js'
import { tokenTracker, apiCallTracker, logger } from '@headlines/utils/server'
import { settings } from '@headlines/config/server'

const FATAL_JUDGEMENT_QUALITIES = ['Irrelevant', 'Poor']

/**
 * Injects a synthetic article into the pipeline from Stage 3 onwards.
 * @param {object} syntheticArticle - The article object to process.
 * @returns {Promise<{savedEvents: Array, savedOpportunities: Array}>} The final saved data.
 */
export async function runInjectedPipeline(syntheticArticle) {
  tokenTracker.reset()
  apiCallTracker.reset()

  tokenTracker.initializeModels([
    settings.LLM_MODEL_HEADLINE_ASSESSMENT,
    settings.LLM_MODEL_ARTICLE_ASSESSMENT,
    settings.LLM_MODEL_SYNTHESIS,
    settings.LLM_MODEL_UTILITY,
  ])

  let payload = {
    articlesForPipeline: [syntheticArticle],
    runStats: {
      errors: [],
      synthesizedEventsForReport: [],
      enrichmentOutcomes: [],
      headlinesScraped: 0,
      scraperHealth: [],
      validatedHeadlines: 0,
      freshHeadlinesFound: 1,
      headlinesAssessed: 0,
      relevantHeadlines: 0,
      articlesEnriched: 0,
      relevantArticles: 0,
      eventsClustered: 0,
      eventsSynthesized: 0,
      judgeVerdict: null,
      eventsEmailed: 0,
      tokenUsage: {},
      apiCalls: {},
    },
  }

  logger.info('  -> Injecting into Stage 3: Assess & Enrich...')
  payload = (await runAssessAndEnrich(payload)).payload

  if (payload.enrichedArticles?.length > 0) {
    logger.info('  -> Injecting into Stage 4: Cluster & Synthesize...')
    payload = (await runClusterAndSynthesize(payload)).payload
  } else {
    logger.warn('  -> Skipping Stage 4: No articles were successfully enriched.')
  }

  logger.info('  -> Injecting into Stage 5 (Commit): Judging output...')
  const { finalEvents, finalOpportunities } = await judgeAndFilterOutput(
    payload,
    FATAL_JUDGEMENT_QUALITIES
  )

  logger.info('  -> Injecting into Stage 5 (Commit): Saving results to database...')
  // DEFINITIVE FIX: saveResultsToDb already returns the fully populated, saved documents.
  // The bug was in the calling script, which has since been fixed. This function is already correct.
  const { savedEvents, savedOpportunities } = await saveResultsToDb(
    payload,
    finalEvents,
    finalOpportunities
  )

  return { savedEvents, savedOpportunities }
}

```

## 📄 .tmp_backups/pipeline/scripts/seed/lib/richlist-data-loader.js.bak
*Lines: 82, Size: 2.7 KB*

```
// apps/pipeline/scripts/seed/lib/richlist-data-loader.js
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import { Opportunity } from '@headlines/models'
import { logger } from '@headlines/utils/server'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const BASE_PATH = path.resolve(__dirname, '../../')

const cityToCountryMap = {
  Sveits: 'Switzerland',
  USA: 'United States',
  Kypros: 'Cyprus',
  Storbritannia: 'United Kingdom',
  Belgia: 'Belgium',
  Danmark: 'Denmark',
  Brasil: 'Brazil',
  Italia: 'Italy',
  Monaco: 'Monaco',
  Portugal: 'Portugal',
  Spania: 'Spain',
  Singapore: 'Singapore',
  Østerrike: 'Austria',
}

function getCountry(city) {
  return cityToCountryMap[city] || 'Norway'
}

function parseWealth(wealthStr) {
  if (!wealthStr || typeof wealthStr !== 'string') return 0
  const match = wealthStr.match(/([\d,]+)\s*mrd/)
  if (!match) return 0
  const cleaned = match[1].replace(/,/g, '.')
  const value = parseFloat(cleaned)
  return Math.round(value * 94)
}

export async function loadAndPrepareRichlist() {
  const jsonPath = path.join(BASE_PATH, 'seed/data/norway.json')
  const jsonData = JSON.parse(fs.readFileSync(jsonPath, 'utf8'))
  const allIndividuals = jsonData.individuals
  logger.info(
    `Loaded ${allIndividuals.length} total individuals from ${path.basename(jsonPath)}.`
  )

  const existingOppNames = (await Opportunity.find({}).select('reachOutTo').lean()).map(
    (o) => o.reachOutTo
  )
  const existingSet = new Set(existingOppNames)

  const preparedIndividuals = await Promise.all(allIndividuals.map(async (person) => {
    const background = person.scraped_data.background_information
    const isThinProfile = !background || background.trim().length < 50
    
    if (isThinProfile) {
        let reason = !background ? 'is null/undefined' : `is too short (${background.trim().length} chars)`;
        logger.trace({ person: person.name, reason }, `Identified as thin profile because background_information ${reason}.`);
    }

    const preparedPersonObject = {
      name: person.name,
      city: person.scraped_data.city,
      country: getCountry(person.scraped_data.city),
      industry: person.industry,
      wealthMillionsUSD: parseWealth(person.scraped_data.current_wealth),
      background: isThinProfile ? null : background,
      wealthSummary: person.scraped_data.wealth_summary,
      primaryCompany: person.scraped_data.roles?.[0]?.company || person.industry,
      year: jsonData.list_metadata.year,
      isExisting: existingSet.has(person.name),
      isThinProfile,
    };
    
    return preparedPersonObject;
  }));

  return { allIndividuals: preparedIndividuals, rawIndividualData: allIndividuals };
}

```

## 📄 .tmp_backups/pipeline/src/app.js.bak
*Lines: 72, Size: 2.25 KB*

```
// apps/pipeline/src/app.js (version 7.1.0)
process.env.IS_PIPELINE_RUN = 'true'; // Set env variable for environment detection

import { env } from '@headlines/config/server'; 
import { reinitializeLogger } from '@headlines/utils/server';
import { initializeAuditLogger } from './utils/auditLogger.js';
import path from 'path'
import yargs from 'yargs'
import { hideBin } from 'yargs/helpers'
import { runPipeline } from './orchestrator.js'
import humanLogStream from './utils/humanLogStream.js'
import fs from 'fs'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
// Correct path from `apps/pipeline/src` up to monorepo root
const PROJECT_ROOT = path.resolve(__dirname, '../../..') 

const logDirectory = path.join(PROJECT_ROOT, 'apps/pipeline/logs');
if (!fs.existsSync(logDirectory)) fs.mkdirSync(logDirectory, { recursive: true })

const logFile = path.join(logDirectory, 'run.log')
try {
  fs.unlinkSync(logFile)
} catch (e) {
  if (e.code !== 'ENOENT') console.error('Could not clear old log file:', e)
}
const fileWriteStream = fs.createWriteStream(logFile, { flags: 'a' })
humanLogStream.pipe(fileWriteStream)
const extraStreams = [{ level: 'trace', stream: humanLogStream }]

const logger = reinitializeLogger(logDirectory, extraStreams)
initializeAuditLogger(logDirectory)

async function start() {
  const argv = yargs(hideBin(process.argv)).argv
  const options = {
    ...argv,
    countryFilter: argv.country,
    sourceFilter: argv.source,
    projectRoot: PROJECT_ROOT,
  }

  logger.info('--- Pipeline Execution Flags ---')
  Object.entries(argv).forEach(([key, value]) => {
    if (key !== '_' && key !== '$0' && value) {
      logger.info(`- ${key.toUpperCase()}: ${value}`)
    }
  })
  logger.info('------------------------------------')

  let result
  try {
    result = await runPipeline(options)
  } catch (error) {
    logger.fatal({ err: error }, 'A top-level, unhandled exception occurred.')
    process.exit(1)
  }

  if (result && !result.success) {
    logger.warn(
      'Pipeline completed with one or more fatal errors. Exiting with status 1.'
    )
    process.exit(1)
  } else {
    logger.info('Pipeline completed successfully. Exiting with status 0.')
    process.exit(0)
  }
}
start()

```

## 📄 .tmp_backups/pipeline/src/auditLogger.js.bak
*Lines: 86, Size: 2.61 KB*

```
// packages/utils/src/auditLogger.js (version 2.0)
import pino from 'pino'
import fs from 'fs'
import path from 'path'
import { Transform } from 'stream'
import { EOL } from 'os'
import moment from 'moment'
import { format } from 'util'

const COLORS = {
  reset: '\x1b[0m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m',
  yellow: '\x1b[33m',
  grey: '\x1b[90m',
}

const humanAuditStream = new Transform({
  transform(chunk, enc, cb) {
    try {
      const logObject = JSON.parse(chunk)
      const { time, msg, context } = logObject
      const timestamp = moment(time).format('HH:mm:ss.SSS')
      let output = `${COLORS.cyan}--- [${timestamp}] ${msg} ---${COLORS.reset}${EOL}`

      if (context) {
        for (const [key, value] of Object.entries(context)) {
          const formattedKey = key
            .replace(/_/g, ' ')
            .replace(/\b\w/g, (l) => l.toUpperCase())
          output += `  ${COLORS.yellow}${formattedKey}:${COLORS.reset}${EOL}`
          output += `${COLORS.grey}${format(value).replace(/^/gm, '    > ')}${COLORS.reset}${EOL}${EOL}`
        }
      }
      this.push(output)
    } catch (e) {
      this.push(chunk) // Pass through non-JSON
    }
    cb()
  },
})

let auditLoggerInstance

export function initializeAuditLogger(logDirectory) {
  if (auditLoggerInstance) return auditLoggerInstance

  if (!logDirectory) {
    throw new Error('[AuditLogger] Initialization failed: logDirectory must be provided.')
  }

  if (!fs.existsSync(logDirectory)) fs.mkdirSync(logDirectory, { recursive: true })

  const auditLogFile = path.join(logDirectory, 'run_audit.log')
  try {
    fs.unlinkSync(auditLogFile)
  } catch (e) {
    if (e.code !== 'ENOENT') console.error('Could not clear old audit log file:', e)
  }

  const fileWriteStream = fs.createWriteStream(auditLogFile, { flags: 'a' })
  humanAuditStream.pipe(fileWriteStream)

  auditLoggerInstance = pino({ level: 'info' }, humanAuditStream)
  return auditLoggerInstance
}

// Export a proxy object. This allows modules to import `auditLogger` directly,
// and it will begin working as soon as initializeAuditLogger() is called from app.js.
export const auditLogger = new Proxy(
  {},
  {
    get(target, prop) {
      if (auditLoggerInstance) {
        return auditLoggerInstance[prop]
      }
      // Fallback behavior before initialization
      if (prop === 'info' || prop === 'warn' || prop === 'error' || prop === 'fatal' || prop === 'debug' || prop === 'trace') {
        // console.warn(`[AuditLogger] Not initialized. Call to '${String(prop)}' was ignored.`)
        return () => {} // Return a no-op function to prevent crashes
      }
      return undefined
    },
  }
)

```

## 📄 .tmp_backups/pipeline/src/modules/dataStore/index.js.bak
*Lines: 125, Size: 5.86 KB*

```
// apps/pipeline/src/modules/dataStore/index.js (version 6.0.0)
import { Pinecone } from '@pinecone-database/pinecone'
import { logger } from '@headlines/utils/server';
import { generateEmbedding } from '@headlines/ai-services'
import { env } from '@headlines/config/server'
import { bulkWriteEvents, bulkWriteArticles, findEventsByKeys, findArticlesByLinks } from '@headlines/data-access'

const { PINECONE_API_KEY, PINECONE_INDEX_NAME } = env;

if (!PINECONE_API_KEY) throw new Error('Pinecone API Key is missing!')
const pc = new Pinecone({ apiKey: PINECONE_API_KEY })
const pineconeIndex = pc.index(PINECONE_INDEX_NAME)

export async function savePipelineResults(articlesToSave, eventsToSave) {
  logger.info(`Committing pipeline results to databases (MongoDB & Pinecone)...`)

  let savedEvents = []
  const pineconeVectors = []

  try {
    if (eventsToSave && eventsToSave.length > 0) {
      const eventOps = eventsToSave.map((event) => {
        const eventPayload = event.toObject ? event.toObject() : event
        delete eventPayload._id
        return {
          updateOne: {
            filter: { event_key: event.event_key },
            update: { $set: { ...eventPayload, emailed: false } },
            upsert: true,
          },
        }
      })
      const eventResult = await bulkWriteEvents(eventOps);
      if (!eventResult.success) throw new Error(eventResult.error);
      logger.info(`MongoDB Event commit complete. Upserted: ${eventResult.upsertedCount}, Modified: ${eventResult.modifiedCount}.`)

      const eventKeys = eventsToSave.map((e) => e.event_key)
      const findResult = await findEventsByKeys(eventKeys);
      if (!findResult.success) throw new Error(findResult.error);
      savedEvents = findResult.data;

      for (const event of savedEvents) {
        const textToEmbed = `${event.synthesized_headline}\n${event.synthesized_summary}`
        const embedding = await generateEmbedding(textToEmbed)
        const eventDate = event.event_date ? new Date(event.event_date) : new Date(); // Robust date handling
        pineconeVectors.push({
          id: `event_${event._id.toString()}`, values: embedding,
          metadata: { type: 'event', headline: event.synthesized_headline, summary: event.synthesized_summary, country: event.country, event_date: eventDate.toISOString(), key_individuals: event.key_individuals.map((p) => p.name).join(', ') },
        })
      }
    }

    if (articlesToSave && articlesToSave.length > 0) {
      const articleOps = []
      const eventKeyToIdMap = new Map(savedEvents.map((e) => [e.event_key, e._id]))
      const articleIdToEventKeyMap = new Map()
      for (const event of eventsToSave) {
        for (const sourceArticle of event.source_articles) {
          const article = articlesToSave.find((a) => a.link === sourceArticle.link)
          if (article) articleIdToEventKeyMap.set(article._id.toString(), event.event_key)
        }
      }

      for (const article of articlesToSave) {
        // Embed the AI-generated summary, not the full text
        if (article.relevance_article && article.assessment_article) {
          const textToEmbed = `${article.headline}\n${article.assessment_article}`
          article.embedding = await generateEmbedding(textToEmbed)
        }
        const articleIdStr = article._id.toString()
        if (article.embedding) {
          pineconeVectors.push({
            id: `article_${articleIdStr}`, values: article.embedding,
            metadata: { type: 'article', headline: article.headline, summary: article.assessment_article || 'No summary.', newspaper: article.newspaper, country: article.country },
          })
        }

        const eventKey = articleIdToEventKeyMap.get(articleIdStr)
        if (eventKey) article.synthesizedEventId = eventKeyToIdMap.get(eventKey)

        const { _id, ...dataToSet } = article
        // Delete articleContent before saving
        delete dataToSet.articleContent;
        Object.keys(dataToSet).forEach((key) => dataToSet[key] === undefined && delete dataToSet[key])
        if ((dataToSet.relevance_headline <= 25 && dataToSet.relevance_article <= 25)) delete dataToSet.articleContent
        delete dataToSet.embedding
        articleOps.push({ updateOne: { filter: { link: article.link }, update: { $set: dataToSet }, upsert: true } })
      }
      await bulkWriteArticles(articleOps);
      logger.info(`MongoDB Article commit complete. Upserted/Modified: ${articleOps.length}.`)
    }

    if (pineconeVectors.length > 0) {
      await pineconeIndex.upsert(pineconeVectors)
      logger.info(`Pinecone commit complete. Upserted ${pineconeVectors.length} vectors.`)
    }

    return { success: true, savedEvents }
  } catch (error) {
    logger.fatal({ err: error }, 'CRITICAL: Failed to commit pipeline results to the databases.')
    return { success: false, savedEvents: [] }
  }
}

export async function filterFreshArticles(articles, isRefreshMode = false) {
  if (!articles || articles.length === 0) return []
  const scrapedLinks = articles.map((a) => a.link)
  if (isRefreshMode) {
    logger.warn('REFRESH MODE: All scraped articles will be processed.')
    const result = await findArticlesByLinks(scrapedLinks);
    if (!result.success) throw new Error(result.error);
    const existingArticlesMap = new Map(result.data.map((a) => [a.link, a._id]))
    const articlesForReprocessing = articles.map((scrapedArticle) =>
      existingArticlesMap.get(scrapedArticle.link) ? { ...scrapedArticle, _id: existingArticlesMap.get(scrapedArticle.link) } : scrapedArticle
    )
    return articlesForReprocessing
  }
  const result = await findArticlesByLinks(scrapedLinks);
  if (!result.success) throw new Error(result.error);
  const existingLinks = new Set(result.data.map((a) => a.link))
  const freshArticles = articles.filter((a) => !existingLinks.has(a.link))
  logger.info(`Filtering complete. Found ${existingLinks.size} existing articles, ${freshArticles.length} are fresh.`)
  return freshArticles
}

```

## 📄 .tmp_backups/pipeline/src/modules/notifications/emailDispatcher.js.bak
*Lines: 113, Size: 4.17 KB*

```
// apps/pipeline/src/modules/notifications/emailDispatcher.js (version 4.0.1)
import { groupItemsByCountry, getCountryFlag } from '@headlines/utils/server';
import { logger } from '@headlines/utils/server';
import { createPersonalizedEmailBody } from '../email/components/emailBodyBuilder.js'
import { sendWealthEventsEmail } from '../email/mailer.js'
import { emailSubjectChain, emailIntroChain, translateChain } from '@headlines/ai-services'

export async function sendBulkEmails(emailQueue) {
  if (emailQueue.length === 0) return 0

  const isDryRun = process.env.DRY_RUN === 'true'
  if (isDryRun) {
    logger.warn(
      'DRY RUN MODE: Email dispatch is being simulated. No actual emails will be sent.'
    )
    let simulatedSuccessCount = 0
    for (const { user, events } of emailQueue) {
      if (events && events.length > 0) {
        // CORRECTED: This template literal is simple and has no nesting issues.
        logger.info(
          `[DRY RUN] Would have sent ${user.language} email to ${user.email} with ${events.length} events.`
        )
        simulatedSuccessCount++
      }
    }
    return simulatedSuccessCount
  }

  logger.info(
    `Dispatching ${emailQueue.length} personalized emails with AI-powered copy...`
  )
  let successCount = 0

  for (const { user, events, opportunities } of emailQueue) {
    try {
      if (!events || events.length === 0) {
        logger.info(`Skipping email for ${user.email} as it contained no valid events.`)
        continue
      }

      // --- AI-Powered Subject and Intro Generation ---
      const eventsByCountry = groupItemsByCountry(events, 'country')
      const primaryCountry = Object.keys(eventsByCountry)[0]
      const countryFlag = getCountryFlag(primaryCountry);

      const eventPayloadForAI = events.map((e) => ({
        headline: e.synthesized_headline,
        summary: e.synthesized_summary,
      }))

      const [subjectResult, introResult] = await Promise.all([
        emailSubjectChain.invoke({
          events_json_string: JSON.stringify(eventPayloadForAI),
        }),
        emailIntroChain.invoke({
          payload_json_string: JSON.stringify({
            firstName: user.firstName,
            events: eventPayloadForAI,
          }),
        }),
      ])

      const aiSubject = subjectResult.subject_headline || 'Key Developments'
      
      const aiIntro = introResult.error ? {
          greeting: `Dear ${user.firstName},`,
          body: 'Here are the latest relevant wealth events we have identified for your review.',
          bullets: events.slice(0, 2).map(e => `A key development regarding ${e.synthesized_headline.substring(0, 40)}...`),
          signoff: 'We wish you a fruitful day!\\n\\nThe team at Wealth Watch'
      } : introResult;
      
      const subject = `${countryFlag} Wealth News (${events.length}): ${aiSubject}`

      const htmlBody = await createPersonalizedEmailBody(
        user,
        eventsByCountry,
        subject,
        aiIntro
      )

      if (!htmlBody) {
        logger.error(`Failed to generate email body for ${user.email}. Skipping.`)
        continue
      }
      
      let finalHtmlBody = htmlBody;
      const targetLanguage = user.language || 'English';

      if (targetLanguage !== 'English') {
          logger.info(`Translating email for ${user.email} into ${targetLanguage}...`);
          const translationResult = await translateChain.invoke({ language: targetLanguage, html_content: htmlBody });
          if (translationResult.error) {
              logger.error({ err: translationResult.error, user: user.email }, `AI translation to ${targetLanguage} failed. Sending in English as a fallback.`);
          } else {
              finalHtmlBody = translationResult.translated_html;
              logger.info(`Successfully translated email for ${user.email}.`);
          }
      }

      const mailOptions = { to: user.email, subject, html: finalHtmlBody }
      const wasSent = await sendWealthEventsEmail(mailOptions)
      if (wasSent) successCount++
    } catch (error) {
      logger.error(
        { err: error, user: user.email },
        'A critical, unhandled error occurred during the email dispatch loop for a user. Skipping this user.'
      )
    }
  }

  return successCount
}

```

## 📄 .tmp_backups/pipeline/src/orchestrator.js.bak
*Lines: 148, Size: 5.26 KB*

```
// apps/pipeline/src/orchestrator.js (version 14.2.0)
import { logger } from './utils/logger.js'
import { tokenTracker, apiCallTracker } from '@headlines/utils/server'
import { logFinalReport } from './utils/pipelineLogger.js'
import { runPreFlightChecks } from './pipeline/1_preflight.js'
import { runScrapeAndFilter } from './pipeline/2_scrapeAndFilter.js'
import { runAssessAndEnrich } from './pipeline/3_assessAndEnrich.js'
import { runClusterAndSynthesize } from './pipeline/4_clusterAndSynthesize.js'
import { runCommitAndNotify } from './pipeline/5_commitAndNotify.js'
import { suggestNewWatchlistEntities } from './pipeline/6_suggestNewWatchlistEntities.js'
import { runSelfHealAndOptimize } from './pipeline/7_selfHealAndOptimize.js'
import { updateSourceAnalytics } from './pipeline/submodules/commit/4_updateSourceAnalytics.js'
import { settings } from '@headlines/config/server'
import { RunVerdict } from '@headlines/models'

async function saveRunVerdict(payload, duration) {
  if (payload.dbConnection && !payload.noCommitMode && !payload.useTestPayload) {
    try {
      const runVerdict = new RunVerdict({
        runStats: payload.runStats,
        judgeVerdict: payload.runStats.judgeVerdict || {},
        generatedEvents: (payload.savedEvents || []).map((e) => e._id),
        generatedOpportunities: (payload.savedOpportunities || []).map((o) => o._id),
        duration_seconds: duration,
        cost_summary: {
          tokens: payload.runStats.tokenUsage,
          apis: payload.runStats.apiCalls,
        },
      })
      await runVerdict.save()
    } catch (error) {
      logger.error({ err: error }, 'Failed to save the run verdict.')
      payload.runStats.errors.push('VERDICT_SAVE_FAILED: ' + error.message)
    }
  }
}

export async function runPipeline(options) {
  const runStartTime = Date.now()
  let success = true

  apiCallTracker.reset()

  let currentPayload = {
    ...options,
    runStats: {
      headlinesScraped: 0,
      scraperHealth: [],
      validatedHeadlines: 0,
      freshHeadlinesFound: 0,
      headlinesAssessed: 0,
      relevantHeadlines: 0,
      articlesEnriched: 0,
      relevantArticles: 0,
      eventsClustered: 0,
      eventsSynthesized: 0,
      synthesizedEventsForReport: [],
      enrichmentOutcomes: [],
      judgeVerdict: null,
      eventsEmailed: 0,
      errors: [],
      tokenUsage: {},
      apiCalls: {},
    },
    dbConnection: false,
  }

  try {
    const preflight = await runPreFlightChecks(currentPayload)
    if (!preflight.success) {
      success = false
      return { success }
    }
    currentPayload = preflight.payload

    tokenTracker.initializeModels([
      settings.LLM_MODEL_HEADLINE_ASSESSMENT,
      settings.LLM_MODEL_ARTICLE_ASSESSMENT,
      settings.LLM_MODEL_SYNTHESIS,
      settings.LLM_MODEL_UTILITY,
    ])

    if (options.useTestPayload) {
      logger.warn('--- USING TEST PAYLOAD ---')
      const { testArticles } = await import('../scripts/test-pipeline/test-payload.js')
      currentPayload.articlesForPipeline = testArticles
      currentPayload.runStats.freshHeadlinesFound = testArticles.length
    } else {
      const scrape = await runScrapeAndFilter(currentPayload)
      currentPayload = scrape.payload
    }

    if (
      currentPayload.articlesForPipeline &&
      currentPayload.articlesForPipeline.length > 0
    ) {
      const assess = await runAssessAndEnrich(currentPayload)
      currentPayload = assess.payload
      if (currentPayload.enrichedArticles && currentPayload.enrichedArticles.length > 0) {
        const synthesize = await runClusterAndSynthesize(currentPayload)
        currentPayload = synthesize.payload
      }
    } else {
      logger.info('No fresh articles to process. Skipping AI analysis stages.')
    }

    currentPayload.runStats.tokenUsage = tokenTracker.getStats()
    currentPayload.runStats.apiCalls = apiCallTracker.getStats()

    if (!options.useTestPayload) {
      await updateSourceAnalytics(currentPayload)

      // Only run the final commit/notify stages if new events were actually generated
      if (
        currentPayload.synthesizedEvents &&
        currentPayload.synthesizedEvents.length > 0
      ) {
        const commit = await runCommitAndNotify(currentPayload)
        currentPayload = commit.payload
        await suggestNewWatchlistEntities(currentPayload)
      } else {
        logger.info(
          'No new events were synthesized. Skipping commit and notification stages, but sending a supervisor report.'
        )
        // Send a report even if no events, for visibility
        const { sendSupervisorReportEmail } = await import('./modules/email/index.js')
        await sendSupervisorReportEmail(currentPayload.runStats)
      }
    }
  } catch (error) {
    success = false
    logger.fatal(
      { err: error },
      'A critical, unhandled error occurred in the orchestrator.'
    )
    currentPayload.runStats.errors.push(`ORCHESTRATOR_FATAL: ${error.message}`)
  } finally {
    const runEndTime = Date.now()
    const durationInSeconds = (runEndTime - runStartTime) / 1000
    currentPayload.runStats.tokenUsage = tokenTracker.getStats()
    currentPayload.runStats.apiCalls = apiCallTracker.getStats()

    await saveRunVerdict(currentPayload, durationInSeconds)
    await logFinalReport(currentPayload.runStats, durationInSeconds)
  }
  return { success }
}

```

## 📄 .tmp_backups/pipeline/src/pipeline/2_scrapeAndFilter.js.bak
*Lines: 165, Size: 5.46 KB*

```
// apps/pipeline/src/pipeline/2_scrapeAndFilter.js
import { logger, auditLogger } from '@headlines/utils/server'
import { filterFreshArticles } from '../modules/dataStore/index.js'
import { triggerSelectorRepair } from './submodules/triggerSelectorRepair.js'
import { Source, Article } from '@headlines/models'
import { scrapeAllHeadlines } from '@headlines/scraper-logic/src/scraper/orchestrator.js'
import { scrapeArticleContent } from '@headlines/scraper-logic/src/scraper/index.js'
import mongoose from 'mongoose'
import { settings } from '@headlines/config/server'

async function performContentPreflight(source, articles) {
  if (!articles || articles.length === 0)
    return { success: false, reason: 'No headlines to test' }

  const firstArticle = {
    ...articles[0],
    source: source.name,
    newspaper: source.name,
    country: source.country,
  }
  const contentResult = await scrapeArticleContent(firstArticle, source)
  const content = contentResult.articleContent?.contents?.join('')

  if (!content || content.length < settings.MIN_ARTICLE_CHARS) {
    const reason = !content
      ? contentResult.enrichment_error
      : `Content too short (${content.length} < ${settings.MIN_ARTICLE_CHARS} chars).`
    logger.warn(`[Content Pre-flight] ❌ FAILED for "${source.name}". Reason: ${reason}`)
    return { success: false, reason }
  }

  logger.info(`✅ Content pre-flight check PASSED for "${source.name}".`)
  return { success: true }
}

export async function runScrapeAndFilter(pipelinePayload) {
  logger.info('--- STAGE 2: SCRAPE & FILTER ---')
  const { runStats } = pipelinePayload

  const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000)

  const baseQuery = {
    status: 'active',
    $or: [
      { scrapeFrequency: 'high' },
      { scrapeFrequency: 'low', lastScrapedAt: { $lt: twentyFourHoursAgo } },
      { scrapeFrequency: 'low', lastScrapedAt: { $exists: false } },
    ],
  }

  const queryCriteria = { ...baseQuery }

  if (pipelinePayload.countryFilter) {
    queryCriteria.country = new RegExp(`^${pipelinePayload.countryFilter}$`, 'i')
    delete queryCriteria.$or
  }
  if (pipelinePayload.sourceFilter) {
    queryCriteria.name = new RegExp(`^${pipelinePayload.sourceFilter}$`, 'i')
    delete queryCriteria.$or
  }

  const sourcesToScrape = await Source.find(queryCriteria).lean()
  if (sourcesToScrape.length === 0) {
    logger.warn(
      `No active sources found matching filter: ${JSON.stringify(queryCriteria)}. Ending run.`
    )
    return { success: false, payload: pipelinePayload }
  }

  const { allArticles, scraperHealth } = await scrapeAllHeadlines(sourcesToScrape)
  runStats.scraperHealth = scraperHealth
  auditLogger.info(
    {
      context: {
        all_scraped_headlines: allArticles.map((a) => ({
          headline: a.headline,
          source: a.newspaper,
        })),
      },
    },
    'All Scraped Headlines'
  )

  const freshArticles = await filterFreshArticles(
    allArticles,
    pipelinePayload.isRefreshMode
  )
  auditLogger.info(
    { context: { fresh_headlines: freshArticles.map((a) => a.headline) } },
    'Fresh Headlines After Filtering'
  )

  const freshArticlesBySource = freshArticles.reduce((acc, article) => {
    if (!acc[article.source]) acc[article.source] = []
    acc[article.source].push(article)
    return acc
  }, {})

  const sourcesWithFreshContent = new Set(Object.keys(freshArticlesBySource))
  logger.info(
    `Found ${sourcesWithFreshContent.size} sources with fresh content that require a content pre-flight check.`
  )

  let validatedArticles = []
  const analyticsUpdateOps = []

  for (const sourceName of sourcesWithFreshContent) {
    const source = sourcesToScrape.find((s) => s.name === sourceName)
    const healthReport = scraperHealth.find((h) => h.source === sourceName)

    if (source && healthReport && healthReport.success) {
      const contentCheck = await performContentPreflight(
        source,
        freshArticlesBySource[sourceName]
      )
      if (contentCheck.success) {
        validatedArticles.push(...freshArticlesBySource[sourceName])
        analyticsUpdateOps.push({
          updateOne: {
            filter: { _id: source._id },
            update: { $set: { 'analytics.lastRunContentSuccess': true } },
          },
        })
      } else {
        analyticsUpdateOps.push({
          updateOne: {
            filter: { _id: source._id },
            update: { $set: { 'analytics.lastRunContentSuccess': false } },
          },
        })
      }
    }
  }

  if (analyticsUpdateOps.length > 0) {
    await Source.bulkWrite(analyticsUpdateOps)
  }

  runStats.headlinesScraped = allArticles.length
  runStats.validatedHeadlines = validatedArticles.length

  const articlesWithIds = validatedArticles.map((article) => ({
    ...article,
    _id: article._id || new mongoose.Types.ObjectId(),
    status: 'scraped',
  }))
  runStats.freshHeadlinesFound = articlesWithIds.length

  if (articlesWithIds.length > 0) {
    await Article.insertMany(articlesWithIds, { ordered: false }).catch((err) => {
      if (err.code !== 11000) logger.error({ err }, 'Error inserting scraped articles')
    })
    logger.info(
      `Successfully saved ${articlesWithIds.length} fresh & validated articles to the database.`
    )
  } else {
    logger.info('No new, validated articles to process. Ending run early.')
    pipelinePayload.articlesForPipeline = []
    return { success: true, payload: pipelinePayload }
  }

  pipelinePayload.articlesForPipeline = articlesWithIds
  return { success: true, payload: pipelinePayload }
}

```

## 📄 .tmp_backups/pipeline/src/pipeline/3_assessAndEnrich.js.bak
*Lines: 206, Size: 9.21 KB*

```
// apps/pipeline/src/pipeline/3_assessAndEnrich.js (version 9.2.0 - Retry & Fallback Logic)
import { truncateString, sleep } from '@headlines/utils/server';
import { logger } from '../utils/logger.js';
import { settings } from '@headlines/config/server'
import { Article } from '@headlines/models'
import { batchHeadlineChain } from '@headlines/ai-services'
import { processSingleArticle } from './submodules/processSingleArticle.js'
import pLimit from 'p-limit'
import { env } from '@headlines/config/server'
import { getConfig } from '@headlines/scraper-logic/src/config.js'

const BATCH_SIZE = 8; // Reduced batch size
const MAX_RETRIES = 1;

async function withRetry(fn, retries = MAX_RETRIES) {
    for (let i = 0; i <= retries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === retries) {
                throw error;
            }
            logger.warn(`Operation failed. Retrying in 2 seconds... (Attempt ${i + 1}/${retries})`);
            await sleep(2000);
        }
    }
}

function findWatchlistHits(text, country) {
  const hits = new Map()
  const lowerText = text.toLowerCase()
  const config = getConfig()
  if (!config.configStore?.watchlistEntities) return []
  const createSearchRegex = (term) =>
    new RegExp(`\\b${term.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\b`, 'i')

  const relevantEntities = Array.from(
    config.configStore.watchlistEntities.values()
  ).filter(
    (entity) =>
      !entity.country ||
      entity.country === country ||
      entity.country === 'Global PE' ||
      entity.country === 'M&A Aggregators'
  )

  for (const entity of relevantEntities) {
    const terms = [entity.name.toLowerCase(), ...(entity.searchTerms || [])]
    for (const term of terms) {
      if (term.length > 3 && createSearchRegex(term).test(lowerText)) {
        if (!hits.has(entity.name)) hits.set(entity.name, { entity, matchedTerm: term })
      }
    }
  }
  return Array.from(hits.values())
}

export async function runAssessAndEnrich(pipelinePayload) {
  logger.info('--- STAGE 3: ASSESS & ENRICH ---')
  const { runStats, articlesForPipeline } = pipelinePayload

  if (!articlesForPipeline || articlesForPipeline.length === 0) {
    pipelinePayload.enrichedArticles = []
    return { success: true, payload: pipelinePayload }
  }

  // DEFINITIVE FIX: Separate synthetic articles from real ones.
  const syntheticArticles = articlesForPipeline.filter(a => a.source === 'Richlist Ingestion');
  const realArticles = articlesForPipeline.filter(a => a.source !== 'Richlist Ingestion');

  logger.info(`Processing ${realArticles.length} real articles and ${syntheticArticles.length} synthetic articles.`);

  let assessedCandidates = [];
  
  if (realArticles.length > 0) {
      logger.info(`Assessing ${realArticles.length} real headlines in batches of ${BATCH_SIZE}...`)
      const batches = [];
      for (let i = 0; i < realArticles.length; i += BATCH_SIZE) {
          batches.push(realArticles.slice(i, i + BATCH_SIZE));
      }
      
      for (const [index, batch] of batches.entries()) {
        logger.info(`Assessing batch ${index + 1} of ${batches.length}...`);
        try {
            const batchProcessor = async () => {
                const batchWithContext = batch.map(article => {
                    const hits = findWatchlistHits(article.headline, article.country);
                    let headlineWithContext = `[COUNTRY CONTEXT: ${article.country}] ${article.headline}`;
                    if (hits.length > 0) {
                        const hitStrings = hits.map(hit => `[WATCHLIST HIT: ${hit.entity.name} (matched on '${hit.matchedTerm}')]`).join(' ');
                        headlineWithContext = `${hitStrings} ${headlineWithContext}`;
                    }
                    return { ...article, headlineWithContext };
                });

                const response = await batchHeadlineChain.invoke({ headlines_json_string: JSON.stringify(batchWithContext.map(a => a.headlineWithContext)) });

                if (response.error || !response.assessments || response.assessments.length !== batch.length) {
                    throw new Error('Batch assessment failed or returned mismatched count.');
                }

                const batchResults = batchWithContext.map((originalArticle, i) => {
                    const assessment = response.assessments[i];
                    if (originalArticle.headlineWithContext.includes('[WATCHLIST HIT')) {
                        let score = assessment.relevance_headline;
                        score = Math.min(100, score + settings.WATCHLIST_SCORE_BOOST);
                        assessment.assessment_headline = `Watchlist boost (+${settings.WATCHLIST_SCORE_BOOST}). ${assessment.assessment_headline}`;
                        assessment.relevance_headline = score;
                    }
                    return { ...originalArticle, ...assessment };
                });
                return batchResults;
            };
            
            const results = await withRetry(batchProcessor);
            assessedCandidates.push(...results);

        } catch (batchError) {
            logger.error({ err: batchError }, `Batch ${index + 1} failed after all retries. FALLING BACK to single-article assessment.`);
            const fallbackPromises = batch.map(article => processSingleArticle(article));
            const fallbackResults = await Promise.all(fallbackPromises);
            
            fallbackResults.forEach((result, i) => {
                const originalArticle = batch[i];
                if (result.article) {
                    assessedCandidates.push({ ...originalArticle, ...result.article });
                } else {
                    assessedCandidates.push({ ...originalArticle, relevance_headline: 0, assessment_headline: result.lifecycleEvent.reason });
                }
            });
        }
      }
  }

  runStats.headlinesAssessed = assessedCandidates.length;

  logger.info("--- Headline Assessment Complete ---");
  assessedCandidates.forEach(article => {
      const status = article.relevance_headline >= settings.HEADLINES_RELEVANCE_THRESHOLD ? 'PASSED' : 'DROPPED';
      const color = status === 'PASSED' ? '\\x1b[32m' : '\\x1b[90m';
      logger.info(`${color}[${status.padEnd(7)}] [Score: ${String(article.relevance_headline).padStart(3)}] "${truncateString(article.headline, 60)}" (${article.assessment_headline})\\x1b[0m`);
  });

  const relevantCandidates = assessedCandidates.filter(
    (a) => a.relevance_headline >= settings.HEADLINES_RELEVANCE_THRESHOLD
  );
  runStats.relevantHeadlines = relevantCandidates.length;

  // DEFINITIVE FIX: Add synthetic articles directly to the enrichment queue.
  const enrichmentQueue = [...relevantCandidates, ...syntheticArticles];

  logger.info(`Found ${relevantCandidates.length} relevant headlines. Total for full enrichment (including synthetic): ${enrichmentQueue.length}.`);
  if (enrichmentQueue.length === 0) {
    pipelinePayload.enrichedArticles = [];
    return { success: true, payload: pipelinePayload };
  }

  const limit = pLimit(env.CONCURRENCY_LIMIT);
  const processingPromises = enrichmentQueue.map((article) =>
    limit(() => processSingleArticle(article))
  );
  const results = await Promise.all(processingPromises);

  const enrichedArticles = [];
  const articleUpdates = [];
  runStats.enrichmentOutcomes = [];

  logger.info("--- Full Article Enrichment Results ---");
  results.forEach((result, index) => {
    const originalArticle = enrichmentQueue[index];
    const finalArticleState = { ...originalArticle, ...result.article, pipeline_lifecycle: [...(originalArticle.pipeline_lifecycle || []), result.lifecycleEvent] };
    const outcome = result.lifecycleEvent.status;

    runStats.enrichmentOutcomes.push({
      link: finalArticleState.link, headline: finalArticleState.headline, newspaper: finalArticleState.newspaper,
      headlineScore: finalArticleState.relevance_headline, assessment_headline: finalArticleState.assessment_headline,
      finalScore: finalArticleState.relevance_article, assessment_article: finalArticleState.assessment_article,
      content_snippet: truncateString(result.contentPreview, 200), outcome: outcome, reason: result.lifecycleEvent.reason,
    });

    if (outcome === 'success') {
      enrichedArticles.push(finalArticleState);
      logger.info(`✅ [SUCCESS] "${truncateString(originalArticle.headline, 60)}" - Final Score: ${finalArticleState.relevance_article}`);
    } else {
      logger.warn(`❌ [${outcome.toUpperCase()}] "${truncateString(originalArticle.headline, 60)}" - Reason: ${result.lifecycleEvent.reason}`);
    }
    
    if (result.article || result.lifecycleEvent) {
        articleUpdates.push({ updateOne: { filter: { _id: originalArticle._id }, update: { $set: finalArticleState } } });
    }
  });

  if (articleUpdates.length > 0) {
    await Article.bulkWrite(articleUpdates, { ordered: false });
  }

  runStats.articlesEnriched = enrichedArticles.length;
  runStats.relevantArticles = enrichedArticles.length;

  logger.info(`Enrichment complete. Successfully enriched ${enrichedArticles.length} of ${enrichmentQueue.length} candidates.`);
  pipelinePayload.enrichedArticles = enrichedArticles;
  pipelinePayload.assessedCandidates = assessedCandidates; // Keep this for analytics

  return { success: true, payload: pipelinePayload };
}

```

## 📄 .tmp_backups/pipeline/src/pipeline/4_clusterAndSynthesize.js.bak
*Lines: 156, Size: 7.06 KB*

```
// apps/pipeline/src/pipeline/4_clusterAndSynthesize.js (version 6.5.0)
import { truncateString } from '@headlines/utils/server'
import { logger, auditLogger } from '@headlines/utils/server'
import {
  clusteringChain,
  synthesisChain,
  entityExtractorChain,
  opportunityChain,
  findSimilarArticles,
} from '@headlines/ai-services'
import { settings } from '@headlines/config/server'
import { getConfig } from '@headlines/scraper-logic/src/config.js'

async function synthesizeEventsFromCluster(
  articlesInCluster,
  clusterKey,
  runStats
) {
  const config = getConfig()
  const primaryHeadline = articlesInCluster[0]?.headline || clusterKey
  logger.info(`--- [ Synthesizing from Cluster: "${truncateString(primaryHeadline, 60)}" ] ---`)

  const uniqueArticlesInCluster = Array.from(new Map(articlesInCluster.map((a) => [a.link, a])).values());
  const combinedText = uniqueArticlesInCluster.map((a) => `${a.headline}\n${a.assessment_article}`).join('\n\n');

  const entityResult = await entityExtractorChain({ article_text: combinedText });
  const entities = entityResult.entities || [];

  const historicalContext = await findSimilarArticles(entities.join(', '));
  const [wikiResults, newsApiResult] = await Promise.all([
    entities.length > 0 ? Promise.all(entities.map((e) => config.utilityFunctions.fetchWikipediaSummary(e))) : Promise.resolve([]),
    config.utilityFunctions.findNewsApiArticlesForEvent(primaryHeadline),
  ]);

  const enrichmentSources = [];
  if (historicalContext.length > 0) enrichmentSources.push('rag_db');
  if (wikiResults.some((r) => r.success)) enrichmentSources.push('wikipedia');
  if (newsApiResult.success) enrichmentSources.push('news_api');

  const wikipediaContext = wikiResults.filter((r) => r.success).map((r) => r.summary).join('\n---\n') || 'Not available.';
  const newsApiContext = newsApiResult.snippets;

  const synthesisInput = {
    "[ TODAY'S NEWS ]": uniqueArticlesInCluster.map((a) => ({
      headline: a.headline,
      source: a.newspaper,
      full_text: a.assessment_article,
      key_individuals: a.key_individuals || [],
    })),
    '[ HISTORICAL CONTEXT (Internal Database) ]': historicalContext,
    '[ PUBLIC WIKIPEDIA CONTEXT ]': wikipediaContext,
    '[ LATEST NEWS CONTEXT (NewsAPI) ]': newsApiContext,
  };

  auditLogger.info({ context: synthesisInput }, `Synthesis Context for: "${primaryHeadline}"`);
  const synthesisResult = await synthesisChain({ context_json_string: JSON.stringify(synthesisInput) });
  auditLogger.info({ context: { 'LLM Output': synthesisResult } }, `Synthesis Verdict for: "${primaryHeadline}"`);

  if (!synthesisResult || synthesisResult.error || !synthesisResult.events) {
    logger.warn({ details: synthesisResult?.error }, 'Synthesis failed for cluster.');
    return [];
  }

  const highestScoreInCluster = Math.max(...uniqueArticlesInCluster.map((a) => a.relevance_article || 0));
  
  const finalEventsAndOpps = [];

  for (const [index, eventData] of synthesisResult.events.entries()) {
    if (highestScoreInCluster < settings.EVENT_RELEVANCE_THRESHOLD) {
      logger.warn({ score: highestScoreInCluster, threshold: settings.EVENT_RELEVANCE_THRESHOLD, headline: eventData.headline }, 'Event failed final quality gate. Discarding.');
      continue;
    }
    
    runStats.eventsSynthesized++;
    const eventObject = {
      ...eventData,
      event_key: `${clusterKey}-${index}`,
      ai_assessment_reason: uniqueArticlesInCluster[0].assessment_article,
      highest_relevance_score: highestScoreInCluster,
      source_articles: uniqueArticlesInCluster.map((a) => ({ headline: a.headline, link: a.link, newspaper: a.newspaper, imageUrl: a.imageUrl })),
      enrichmentSources,
    };

    const opportunityInput = { context_text: `Event Key: ${eventObject.event_key}\nSynthesized Event Headline: ${eventObject.synthesized_headline}\nSynthesized Event Summary: ${eventObject.synthesized_summary}\nKey Individuals already identified: ${JSON.stringify(eventObject.key_individuals)}\nSource Article Snippets: ${truncateString(combinedText, settings.LLM_CONTEXT_MAX_CHARS)}` };
    const opportunityResult = await opportunityChain(opportunityInput);
    
    runStats.synthesizedEventsForReport.push({ synthesized_headline: eventObject.synthesized_headline, highest_relevance_score: eventObject.highest_relevance_score });
    
    finalEventsAndOpps.push({
        event: eventObject,
        opportunities: opportunityResult.opportunities || []
    });
  }
  
  return finalEventsAndOpps;
}

export async function runClusterAndSynthesize(pipelinePayload) {
  logger.info('--- STAGE 4: CLUSTER & SYNTHESIZE ---')
  const { runStats, enrichedArticles } = pipelinePayload

  const articlesForProcessing = enrichedArticles.filter((a) => a.relevance_article >= settings.ARTICLES_RELEVANCE_THRESHOLD)
  if (articlesForProcessing.length === 0) {
    logger.info('No relevant articles were promoted for synthesis stage.')
    pipelinePayload.synthesizedEvents = []
    pipelinePayload.opportunitiesToSave = []
    return { success: true, payload: pipelinePayload }
  }

  const fullArticleMap = new Map(articlesForProcessing.map((a) => [a._id.toString(), a]))
  const articlePayload = articlesForProcessing.map((a) => ({ id: a._id.toString(), headline: a.headline, source: a.newspaper, summary: a.assessment_article || '' }))
  const clusterResult = await clusteringChain({ articles_json_string: JSON.stringify(articlePayload) })

  const eventClusters = clusterResult.events || []
  runStats.eventsClustered = eventClusters.length
  logger.info({ details: eventClusters }, `Clustered ${articlesForProcessing.length} articles into ${eventClusters.length} unique events.`)

  const clusteredArticleIds = new Set(eventClusters.flatMap((c) => c.article_ids))
  let synthesizedEvents = []
  let opportunitiesToSave = []
  
  const synthesisPromises = [];

  for (const cluster of eventClusters) {
    const articlesInCluster = cluster.article_ids.map((id) => fullArticleMap.get(id)).filter(Boolean)
    if (articlesInCluster.length > 0) {
      synthesisPromises.push(synthesizeEventsFromCluster(articlesInCluster, cluster.event_key, runStats))
    }
  }

  const singletonArticles = articlesForProcessing.filter(
    (a) => !clusteredArticleIds.has(a._id.toString()) && a.relevance_article >= settings.SINGLETON_RELEVANCE_THRESHOLD
  )
  if (singletonArticles.length > 0) {
    logger.info(`Found ${singletonArticles.length} high-quality singleton articles to process as individual events.`)
    for (const article of singletonArticles) {
      const event_key = `singleton-${article.newspaper.toLowerCase().replace(/[^a-z0-9]/g, '')}-${article._id.toString()}`
      synthesisPromises.push(synthesizeEventsFromCluster([article], event_key, runStats))
    }
  }

  const results = await Promise.all(synthesisPromises)
  const flattenedResults = results.flat();
  
  flattenedResults.forEach((result) => {
    if (result) {
      synthesizedEvents.push(result.event)
      opportunitiesToSave.push(...result.opportunities)
    }
  })

  pipelinePayload.synthesizedEvents = synthesizedEvents
  pipelinePayload.opportunitiesToSave = opportunitiesToSave
  return { success: true, payload: pipelinePayload }
}

```

## 📄 .tmp_backups/pipeline/src/pipeline/6_suggestNewWatchlistEntities.js.bak
*Lines: 81, Size: 2.55 KB*

```
// apps/pipeline/src/pipeline/6_suggestNewWatchlistEntities.js (version 4.1)
import { logger } from '@headlines/utils/server';
import { watchlistSuggestionChain } from '@headlines/ai-services'
import {
  getActiveWatchlistEntityNames,
  bulkWriteWatchlistSuggestions,
} from '@headlines/data-access'
import { settings } from '@headlines/config/server'

export async function suggestNewWatchlistEntities(pipelinePayload) {
  logger.info('--- STAGE 6: WATCHLIST SUGGESTION ---')

  const { savedEvents } = pipelinePayload
  if (!savedEvents || savedEvents.length === 0) {
    logger.info('No new events saved. Skipping watchlist suggestion.')
    return
  }

  const highQualityEvents = savedEvents.filter(
    (e) => e.highest_relevance_score >= settings.SUGGESTION_GENERATION_THRESHOLD
  )
  if (highQualityEvents.length === 0) {
    logger.info(
      `No events met quality threshold (${settings.SUGGESTION_GENERATION_THRESHOLD}) for suggestions.`
    )
    return
  }

  logger.info(
    `Analyzing ${highQualityEvents.length} high-quality events for new watchlist candidates...`
  )

  const existingEntitiesResult = await getActiveWatchlistEntityNames()
  if (!existingEntitiesResult.success) {
    logger.error(
      { err: existingEntitiesResult.error },
      'Failed to fetch existing watchlist entities.'
    )
    return
  }
  const existingNames = new Set(
    existingEntitiesResult.data.map((e) => e.name.toLowerCase())
  )

  const result = await watchlistSuggestionChain.invoke({
    events_json_string: JSON.stringify(highQualityEvents),
  })

  if (result.error || !result.suggestions) {
    logger.warn('AI failed to generate watchlist suggestions.', result)
    return
  }

  // Post-filter to ensure we don't suggest entities that already exist
  const newSuggestions = result.suggestions.filter(
    (s) => !existingNames.has(s.name.toLowerCase())
  )

  if (newSuggestions.length > 0) {
    logger.info(`AI generated ${newSuggestions.length} new watchlist suggestions.`)
    const bulkOps = newSuggestions.map((suggestion) => ({
      updateOne: {
        filter: { name: suggestion.name },
        update: { $setOnInsert: suggestion },
        upsert: true,
      },
    }))

    const dbResult = await bulkWriteWatchlistSuggestions(bulkOps)
    if (dbResult.success) {
      logger.info(
        `Successfully saved ${newSuggestions.length} new suggestions to the database.`
      )
    } else {
      logger.error({ err: dbResult.error }, 'Failed to save new watchlist suggestions.')
    }
  } else {
    logger.info('AI analysis did not yield any new watchlist suggestions.')
  }
}

```

## 📄 .tmp_backups/pipeline/src/pipeline/submodules/commit/1_judgeOutput.js.bak
*Lines: 78, Size: 2.48 KB*

```
// apps/pipeline/src/pipeline/submodules/commit/1_judgeOutput.js (version 2.4.1)
import { logger } from '@headlines/utils/src/logger.js';
import { judgeChain } from '@headlines/ai-services'

export async function judgeAndFilterOutput(pipelinePayload, fatalQualities) {
  const {
    synthesizedEvents: initialEvents = [],
    opportunitiesToSave: initialOpportunities = [],
    runStats,
  } = pipelinePayload

  logger.info(
    `[Judge Agent] Received ${initialEvents.length} events and ${initialOpportunities.length} opportunities for final review.`
  )

  const lightweightEvents = initialEvents.map((e) => ({
    identifier: `Event: ${e.synthesized_headline}`,
    summary: e.synthesized_summary,
    assessment: e.ai_assessment_reason,
    score: e.highest_relevance_score,
  }))
  const lightweightOpportunities = initialOpportunities.map((o) => ({
    identifier: `Opportunity: ${o.reachOutTo}`,
    reason: o.whyContact,
    wealth_estimate_mm: o.likelyMMDollarWealth,
  }))

  const payloadForJudge = {
    events: lightweightEvents,
    opportunities: lightweightOpportunities,
  }
  const judgeVerdict = await judgeChain.invoke({
    payload_json_string: JSON.stringify(payloadForJudge),
  })

  runStats.judgeVerdict = judgeVerdict

  if (judgeVerdict.error) {
    logger.error(
      'Judge agent returned an error. Allowing all items to pass as a failsafe.',
      { details: judgeVerdict.error }
    )
    return { finalEvents: initialEvents, finalOpportunities: initialOpportunities }
  }

  const fatalQualitiesSet = new Set(fatalQualities)

  const approvedEventIdentifiers = new Set(
    (judgeVerdict?.event_judgements || [])
      .filter((j) => !fatalQualitiesSet.has(j.quality))
      .map((j) => j.identifier)
  )

  const finalEvents = initialEvents.filter((event) => {
    const identifier = `Event: ${event.synthesized_headline}`
    const wasApproved = approvedEventIdentifiers.has(identifier)
    if (!wasApproved) {
      const verdict = judgeVerdict.event_judgements.find(
        (j) => j.identifier === identifier
      )
      logger.warn(
        { event: event.synthesized_headline, verdict: verdict },
        `Event discarded by Judge's final verdict.`
      )
    }
    return wasApproved
  })

  logger.info(
    `[Judge Agent] Verdict complete. Approved ${finalEvents.length} out of ${initialEvents.length} events.`
  )

  // For now, we are not filtering opportunities, but the framework is here.
  const finalOpportunities = initialOpportunities

  return { finalEvents, finalOpportunities }
}

```

## 📄 .tmp_backups/pipeline/src/pipeline/submodules/commit/2_saveResults.js.bak
*Lines: 53, Size: 1.89 KB*

```
// apps/pipeline/src/pipeline/submodules/commit/2_saveResults.js (version 2.1.1)
import mongoose from 'mongoose'
import { savePipelineResults } from '../../../modules/dataStore/index.js'
import { enrichAndLinkOpportunities } from '../opportunityUpserter.js'
import { logger } from '@headlines/utils/src/logger.js';

export async function saveResultsToDb(
  pipelinePayload,
  finalEventsToSave,
  finalOpportunitiesToSave
) {
  const { assessedCandidates, isDryRun, runStats } = pipelinePayload
  const articlesToSave = assessedCandidates || []

  if (isDryRun) {
    logger.warn('DRY RUN: Simulating database save.')
    const savedEvents = finalEventsToSave.map((event) => ({
      ...event,
      _id: new mongoose.Types.ObjectId(),
    }))
    return {
      savedEvents,
      savedOpportunities: finalOpportunitiesToSave,
      articlesSavedCount: articlesToSave.length,
    }
  }

  const commitResult = await savePipelineResults(articlesToSave, finalEventsToSave)

  if (commitResult.success) {
    const savedEvents = commitResult.savedEvents
    try {
      const savedOpportunities = await enrichAndLinkOpportunities(
        finalOpportunitiesToSave,
        savedEvents
      );
      return {
        savedEvents,
        savedOpportunities,
        articlesSavedCount: articlesToSave.length,
      }
    } catch (error) {
        logger.error({ err: error }, 'CRITICAL: Failed during opportunity enrichment and linking. Opportunities will not be saved or sent.');
        runStats.errors.push('CRITICAL: Opportunity processing failed: ' + error.message);
        // Return successfully saved events, but an empty array for failed opportunities.
        return { savedEvents, savedOpportunities: [], articlesSavedCount: articlesToSave.length };
    }
  } else {
    runStats.errors.push('CRITICAL: Failed to commit pipeline results.')
    return { savedEvents: [], savedOpportunities: [], articlesSavedCount: 0 }
  }
}

```

## 📄 .tmp_backups/pipeline/src/pipeline/submodules/processSingleArticle.js.bak
*Lines: 179, Size: 6.1 KB*

```
// apps/pipeline/src/pipeline/submodules/processSingleArticle.js
import { logger } from '../../utils/logger.js'
import { articleChain, articlePreAssessmentChain } from '@headlines/ai-services'
import { getConfig } from '@headlines/scraper-logic/src/config.js'
import { scrapeArticleContent } from '@headlines/scraper-logic/src/scraper/contentScraper.js'
import { settings } from '@headlines/config/server'
import { Source } from '@headlines/models'

function createLifecycleEvent(stage, status, reason) {
  return { stage, status, reason, timestamp: new Date() }
}

async function salvageHighSignalArticle(article) {
  logger.warn(
    { headline: article.headline },
    `SALVAGE MODE: Attempting to find alternative sources for high-signal headline.`
  )
  const config = getConfig()
  const searchResult = await config.utilityFunctions.findAlternativeSources(
    article.headline
  )
  if (!searchResult.success || searchResult.results.length === 0) {
    logger.error(
      { headline: article.headline },
      'SALVAGE FAILED: No alternative sources found.'
    )
    return {
      article: null,
      lifecycleEvent: createLifecycleEvent(
        'salvage',
        'failed',
        'No alternative sources found'
      ),
    }
  }

  for (const altSource of searchResult.results.slice(0, 2)) {
    const tempSourceConfig = { name: altSource.source, articleSelector: 'body' }
    const tempArticle = { ...article, link: altSource.link }
    const contentResult = await scrapeArticleContent(tempArticle, tempSourceConfig)

    if (contentResult.articleContent) {
      const finalAssessment = await articleChain.invoke({
        article_text: contentResult.articleContent.contents.join('\n'),
      })
      if (
        finalAssessment &&
        !finalAssessment.error &&
        finalAssessment.relevance_article >= settings.ARTICLES_RELEVANCE_THRESHOLD
      ) {
        logger.info(
          { headline: article.headline },
          'SALVAGE SUCCESS: Successfully enriched from alternative source.'
        )
        const salvagedArticle = {
          ...finalAssessment,
          assessment_article: `[SALVAGED] ${finalAssessment.assessment_article}`,
        }
        return {
          article: salvagedArticle,
          lifecycleEvent: createLifecycleEvent(
            'salvage',
            'success',
            `Used alternative source: ${altSource.link}`
          ),
        }
      }
    }
  }
  return {
    article: null,
    lifecycleEvent: createLifecycleEvent(
      'salvage',
      'failed',
      'All alternatives failed enrichment'
    ),
  }
}

export async function processSingleArticle(article) {
  let transientArticle
  try {
    let source
    // --- CRITICAL FIX ---
    // Check if this is a synthetic article from our ingestion script.
    // If so, create a mock source object to satisfy the content scraper's needs
    // without performing a database lookup for a source that doesn't exist.
    if (article.source === 'Richlist Ingestion') {
      logger.trace('Using mock source config for synthetic rich list article.')
      source = {
        name: 'Richlist Ingestion',
        // The articleSelector can be a generic tag since the synthetic article
        // has no real HTML structure; Readability.js will handle it.
        articleSelector: ['body'],
      }
      // For synthetic articles, we bypass the content scraper and use the provided content directly.
      transientArticle = article
    } else {
      // This is the original logic for real, scraped articles.
      source = await Source.findOne({ name: article.source }).lean()
      if (!source)
        throw new Error(`Could not find source document for "${article.source}"`)
      transientArticle = await scrapeArticleContent(article, source)
    }

    if (transientArticle.articleContent) {
      const articleText = transientArticle.articleContent.contents.join('\n')
      const triageResult = await articlePreAssessmentChain.invoke({ input: articleText })

      if (triageResult.error || triageResult.classification !== 'private') {
        return {
          article: null,
          lifecycleEvent: createLifecycleEvent(
            'enrichment',
            'dropped',
            `Failed AI Triage (classified as ${triageResult.classification})`
          ),
          contentPreview: transientArticle.contentPreview,
        }
      }

      const finalAssessment = await articleChain.invoke({ article_text: articleText })

      if (finalAssessment.error) {
        throw new Error(finalAssessment.error)
      }

      if (finalAssessment.relevance_article >= settings.ARTICLES_RELEVANCE_THRESHOLD) {
        return {
          article: finalAssessment,
          lifecycleEvent: createLifecycleEvent(
            'enrichment',
            'success',
            `Final score: ${finalAssessment.relevance_article}`
          ),
          contentPreview: transientArticle.contentPreview,
        }
      } else {
        return {
          article: { ...finalAssessment },
          lifecycleEvent: createLifecycleEvent(
            'enrichment',
            'dropped',
            `Content score ${finalAssessment.relevance_article} < threshold ${settings.ARTICLES_RELEVANCE_THRESHOLD}`
          ),
          contentPreview: transientArticle.contentPreview,
        }
      }
    } else {
      if (article.relevance_headline >= settings.HIGH_SIGNAL_HEADLINE_THRESHOLD) {
        return {
          ...(await salvageHighSignalArticle(article)),
          contentPreview: transientArticle.contentPreview,
        }
      } else {
        return {
          article: null,
          lifecycleEvent: createLifecycleEvent(
            'enrichment',
            'dropped',
            `Content scrape failed and headline score ${article.relevance_headline} was not high-signal`
          ),
          contentPreview: transientArticle.contentPreview,
        }
      }
    }
  } catch (error) {
    logger.error(
      { err: error, articleLink: article.link },
      'Critical error during single article processing.'
    )
    return {
      article: null,
      lifecycleEvent: createLifecycleEvent('enrichment', 'error', error.message),
      contentPreview: transientArticle?.contentPreview,
    }
  }
}

```

## 📄 .tmp_backups/pipeline/src/utils/humanLogStream.js.bak
*Lines: 62, Size: 2.01 KB*

```
// apps/pipeline/src/utils/humanLogStream.js (version 2.1.0)
import { Transform } from 'stream'
import { EOL } from 'os'
import moment from 'moment'
import { format } from 'util'

const KEYS_TO_IGNORE = new Set(['level', 'time', 'pid', 'hostname', 'msg', 'v']);

function prettyPrint(obj, indent = '  ') {
    let output = '';
    for (const [key, value] of Object.entries(obj)) {
        if (KEYS_TO_IGNORE.has(key)) continue;
        if (value === undefined || value === null || (Array.isArray(value) && value.length === 0)) continue;

        const formattedKey = key.replace(/([A-Z])/g, ' $1').replace(/^./, (str) => str.toUpperCase());
        
        if (typeof value === 'object' && value !== null) {
            const nested = prettyPrint(value, indent + '  ');
            if (nested) {
                output += `${indent}${formattedKey}:${EOL}${nested}`;
            }
        } else {
            output += `${indent}${formattedKey}: ${format(value)}${EOL}`;
        }
    }
    return output;
}

const humanLogStream = new Transform({
    transform(chunk, enc, cb) {
        try {
            const logObject = JSON.parse(chunk);
            const { time, msg, level, ...rest } = logObject;
            
            // Skip logging the initial "PIPELINE RUN INITIATED" banner to this stream
            if (msg.includes("PIPELINE RUN INITIATED")) {
                return cb();
            }

            const timestamp = moment(time).format('HH:mm:ss.SSS');
            let output = `[${timestamp}] ${msg}${EOL}`;

            // Only print details for logs of level INFO (30) or higher
            if (level >= 30) {
              const details = prettyPrint(rest);
              if (details) {
                  output += details + EOL;
              }
            }
            
            this.push(output);
        } catch (e) {
            // Non-JSON logs (like the final report) will pass through as is.
            this.push(chunk);
            this.push(EOL);
        }
        cb();
    },
});

export default humanLogStream;

```

## 📄 .tmp_backups/prompts/src/examples/shotsInputHeadlines.js.bak
*Lines: 41, Size: 1.74 KB*

```
// packages/prompts/src/examples/shotsInputHeadlines.js (version 4.0)
export const shotsInputHeadlines = [
  [
    'Rockwool står foran massive udvidelser over hele kloden',
    'Boeing henter 145 mia. kr.',
    'Boligejere med for stor grundskyldsregning har udsigt til hjælp',
    'Aarstiderne solgt til gigant',
    'Scandinavian family sells company for $500M',
    'Familien Danielsens formue nærmer sig to mia. kroner',
  ].join('\n- '),

  [
    'Egeria raises €1.25 billion with new private equity fund',
    'Egeria enters new partnership with Junge Die Bäckerei.',
    'FSN Capital VI acquires a majority stake in ilionx',
    'Egeria divests Dutch Bakery after a period of strong growth',
    'Axcel closes its seventh fund at EUR 1.3 billion',
  ].join('\n- '),

  [
    'A.P. Moller Foundation donates $100 million to charity',
    'LEGO family (KIRKBI A/S) in acquisition talks for rival toy company for DKK 5 billion',
    'Danfoss heir (Bitten & Mads Clausen Foundation) announces succession plan for family business leadership',
    'Widex and Demant plan to merge operations',
    '3Shape (privately owned) is working on an IPO',
  ].join('\n- '),

  [
    'Nå|Spår milliard-smell fra toll', // Stellantis example
    'Familieejet koncern bestrider millionkrav efter Nordic Waste', // USTC example
    'Fynske bankers fusionsplaner skydes ned af storaktionær', // Public bank merger
  ].join('\n- '),

  [
    'Grundfos owner (Poul Due Jensen Foundation) announces DKK 300 million dividend distribution to family members',
    'Bestseller owner Anders Holch Povlsen personally acquires Scottish estate for DKK 150 million',
    "Martin Thorborg's AI Startup Secures Funding",
    'Martin Thorborg giver et foredrag om iværksætteri',
  ].join('\n- '),
]

```

## 📄 .tmp_backups/prompts/src/examples/shotsOutputHeadlines.js.bak
*Lines: 144, Size: 4.5 KB*

```
// packages/prompts/src/examples/shotsOutputHeadlines.js (version 4.0)
export const shotsOutputHeadlines = [
  JSON.stringify({
    assessment: [
      {
        headline_en: 'Rockwool faces massive expansions across the globe',
        relevance_headline: 10,
        assessment_headline: 'Operational news.',
      },
      {
        headline_en: 'Boeing raises DKK 145 billion',
        relevance_headline: 5,
        assessment_headline: 'Corporate fundraising.',
      },
      {
        headline_en: 'Homeowners with excessive property tax bills can expect help',
        relevance_headline: 0,
        assessment_headline: 'Noise.',
      },
      {
        headline_en: 'Aarstiderne sold to giant',
        relevance_headline: 95,
        assessment_headline: 'Private company sale.',
      },
      {
        headline_en: 'Scandinavian family sells company for $500M',
        relevance_headline: 100,
        assessment_headline: 'Private company sale.',
      },
      {
        headline_en: "The Danielsen family's fortune approaches DKK 2 billion",
        relevance_headline: 95,
        assessment_headline: 'Family wealth profile.',
      },
    ],
  }),
  JSON.stringify({
    assessment: [
      {
        headline_en: 'Egeria raises €1.25 billion with new private equity fund',
        relevance_headline: 0,
        assessment_headline: 'Corporate fundraising.',
      },
      {
        headline_en: 'Egeria enters new partnership with Junge Die Bäckerei.',
        relevance_headline: 90,
        assessment_headline: 'PE acquisition.',
      },
      {
        headline_en: 'FSN Capital VI acquires a majority stake in ilionx',
        relevance_headline: 95,
        assessment_headline: 'PE acquisition.',
      },
      {
        headline_en: 'Egeria divests Dutch Bakery after a period of strong growth',
        relevance_headline: 95,
        assessment_headline: 'PE exit.',
      },
      {
        headline_en: 'Axcel closes its seventh fund at EUR 1.3 billion',
        relevance_headline: 0,
        assessment_headline: 'Corporate fundraising.',
      },
    ],
  }),
  JSON.stringify({
    assessment: [
      {
        headline_en: 'A.P. Moller Foundation donates $100 million to charity',
        relevance_headline: 0,
        assessment_headline: 'Noise.',
      },
      {
        headline_en:
          'LEGO family (KIRKBI A/S) in acquisition talks for rival toy company for DKK 5 billion',
        relevance_headline: 95,
        assessment_headline: 'Future liquidity event.',
      },
      {
        headline_en:
          'Danfoss heir (Bitten & Mads Clausen Foundation) announces succession plan for family business leadership',
        relevance_headline: 30,
        assessment_headline: 'Operational news.',
      },
      {
        headline_en: 'Widex and Demant plan to merge operations',
        relevance_headline: 70,
        assessment_headline: 'M&A involving private family.',
      },
      {
        headline_en: '3Shape (privately owned) is working on an IPO',
        relevance_headline: 80,
        assessment_headline: 'Future liquidity event.',
      },
    ],
  }),
  JSON.stringify({
    assessment: [
      {
        headline_en: 'Now | Predicts billion-krone blow from tariffs',
        relevance_headline: 5,
        assessment_headline: 'Noise.',
      },
      {
        headline_en:
          'Family-owned conglomerate disputes million-krone claim after Nordic Waste',
        relevance_headline: 85,
        assessment_headline: 'Legal/financial dispute.',
      },
      {
        headline_en: "Funen banks' merger plans shot down by major shareholder",
        relevance_headline: 10,
        assessment_headline: 'Public market noise.',
      },
    ],
  }),
  JSON.stringify({
    assessment: [
      {
        headline_en:
          'Grundfos owner (Poul Due Jensen Foundation) announces DKK 300 million dividend distribution to family members',
        relevance_headline: 95,
        assessment_headline: 'Family wealth event.',
      },
      {
        headline_en:
          'Bestseller owner Anders Holch Povlsen personally acquires Scottish estate for DKK 150 million',
        relevance_headline: 90,
        assessment_headline: 'Individual wealth event.',
      },
      {
        headline_en: "Martin Thorborg's AI Startup Secures Funding",
        relevance_headline: 10,
        assessment_headline: 'Corporate fundraising.',
      },
      {
        headline_en: 'Martin Thorborg gives a lecture on entrepreneurship',
        relevance_headline: 0,
        assessment_headline: 'Noise.',
      },
    ],
  }),
]

```

## 📄 .tmp_backups/prompts/src/instructionArticle.js.bak
*Lines: 47, Size: 4.8 KB*

```
// packages/prompts/src/instructionArticle.js (version 3.2)
import { settings } from '@headlines/config/server'

export const getInstructionArticle = () => ({
  whoYouAre: `You are a "Due Diligence" analyst for an elite, multi-billion dollar wealth advisory team. Your job is to read the full article to verify intelligence, enrich it with details, and make a final recommendation on its relevance. Your work is the final filter before it reaches advisors. A missed opportunity is a massive failure, but a false positive is a waste of time.`,
  whatYouDo: `You analyze full-text articles to confirm and detail liquidity events or significant wealth status changes, structuring the information for our CRM.`,
  primaryMandate: `Verify the signal. Your analysis must confirm if the event creates actionable private liquidity or provides a significant update to a target's wealth profile. Be ruthless in downgrading headlines that turn out to be noise.`,
  analyticalFramework: `
1.  **Chain of Thought Reasoning (CRITICAL):** First, you MUST populate the \`reasoning\` JSON object.
    - \`event_type\`: Classify the event: ["M&A / Sale of private company", "Family Wealth Profile", "Individual Wealth Profile", "Legal / Financial Dispute", "Corporate Funding Round", "Public Market Transaction", "Operational News", "Other"].
    - \`is_liquidity_event\`: A boolean (true/false). A "Wealth Profile" or "Dispute" is not a liquidity event but is still highly relevant.
    - \`beneficiary\`: Who is the subject? (e.g., "Søren Ejlersen", "The Danielsen Family").

2.  **Event Classification (NEW):** You MUST classify the article's content into ONE of the following categories:
    - **"New wealth"**: For clear liquidity events like a company sale, M&A, or an exit where a principal receives cash.
    - **"Wealth detection"**: For articles profiling existing significant wealth (e.g., a "rich list" feature, a story about a family's large fortune).
    - **"IPO"**: For any news specifically about a company planning, undergoing, or completing an Initial Public Offering.
    - **"Interview"**: If the primary format of the article is an interview with a key individual, even if it's not a direct wealth event.
    - **"Other"**: If it doesn't fit any of the above categories.

3.  **Verification & Downgrading:** Your primary value is to catch false positives. If a headline implied a private sale but the article reveals it's a transaction between two public companies, you MUST assign a low score (0-10).

4.  **Contextual Intelligence Doctrine:** If the headline signaled a high-relevance event (like a major Legal Dispute or a Family Wealth profile), your primary job is to CONFIRM the facts. DO NOT downgrade the score simply because no money is changing hands. A legal battle involving a UHNW family is just as important as a small company sale.

5.  **Key Individuals Extraction (CRITICAL UPDATE):** You MUST extract principal individuals who are direct beneficiaries of a wealth event (>$${settings.SIGNIFICANT_PRIVATE_BENEFICIARY_USD_MM}M) or subjects of a wealth profile.
    - **FOCUS:** Founders, sellers, major private shareholders, and UHNW family members.
    - **EXCLUDE:** FORBIDDEN from extracting peripheral actors like journalists, lawyers, advisors, or non-owner executives.
    - **SCHEMA:** Populate the \`key_individuals\` JSON array with objects adhering to this exact schema:
      - \`name\`: Full name of the person or family.
      - \`role_in_event\`: Specific role (e.g., "Founder & Seller", "Subject of Wealth Profile").
      - \`company\`: Primary company in this event.
      - \`email_suggestion\`: Infer a plausible corporate email (e.g., "s.ejlersen@aarstiderne.com"). If a plausible, specific corporate email cannot be inferred, you MUST use \`null\`. DO NOT hallucinate generic emails.
    If no relevant individuals are mentioned, return an empty array \`[]\`.

6.  **Conciseness Mandate:** Your \`assessment_article\` MUST be a single, concise sentence.
`,
  scoring: `
  - Score 95-100: Confirmed sale of a privately-owned company by named individuals/families for >$${settings.HIGH_VALUE_DEAL_USD_MM}M.
  - Score 85-94: Mention of a major UHNW individual or family. Or: a confirmed take-private acquisition.
  - Score 70-84: A confirmed, significant legal or financial dispute involving a known UHNW entity.
  - Score 50-69: Strongly implied but unconfirmed liquidity events. "Wealth in the making".
  - Score 0-49: Anything that fails verification, is below the financial threshold, or involves no identifiable private beneficiaries.
  `,
  outputFormatDescription: `Respond ONLY with a properly formatted JSON object.`,
  reiteration: `Only respond with a properly formatted JSON object. Start with 'reasoning'. Be ruthless in verification and only extract principal, wealthy beneficiaries for 'key_individuals'. You MUST include the new 'classification' field.`,
})

```

## 📄 .tmp_backups/prompts/src/instructionEmailIntro.js.bak
*Lines: 16, Size: 1.39 KB*

```
// packages/prompts/src/instructionEmailIntro.js (version 2.4.0)
export const instructionEmailIntro = {
  whoYouAre:
    'You are a sharp, eloquent, and positive senior analyst at an elite wealth management firm. You are writing the opening for a daily intelligence briefing for a valued client.',
  whatYouDo:
    "You will receive the client's first name and a list of today's key wealth events. Your task is to craft a warm, concise, and encouraging introduction that highlights the most significant opportunities.",
  guidelines: [
    '1. **Greeting:** The `greeting` field MUST be "Dear [FirstName],".',
    '2. **Body:** The `body` field MUST be a single, positive, forward-looking sentence that sets the stage.',
    '3. **Bullets (CRITICAL):** The `bullets` field MUST be an array of strings. You MUST select a MAXIMUM of THREE of the most remarkable and actionable events from the provided list and create one compelling bullet point for each. DO NOT list all events.',
    '4. **Sign-off (CRITICAL):** The `signoff` field MUST be an ORIGINAL EQUIVALENT of "We wish you a fruitful day!\\n\\nThe team at Wealth Watch". The double backslash `\\n` is crucial for creating a line break.',
    '5. **Concise is Key:** The entire introduction should be brief and easily scannable.',
  ],
  outputFormatDescription: `Respond ONLY with a valid JSON object with the keys "greeting", "body", "bullets", and "signoff".`,
}

```

## 📄 .tmp_backups/prompts/src/instructionHeadlines.js.bak
*Lines: 65, Size: 3.81 KB*

```
// packages/prompts/src/instructionHeadlines.js (version 4.1)
export const instructionHeadlines = {
  whoYouAre: `You are a "Signal Detection" analyst for an elite Private Wealth division. Your sole purpose is to identify actionable intelligence. A missed opportunity is a critical failure.`,
  whatYouDo: `You scan headlines to find signals of private wealth events. You evaluate each against a mandatory checklist.`,
  primaryMandate: `Your UNWAVERING FOCUS is on identifying nascent liquidity and significant wealth status changes for private individuals, foundations and wealthy families. You are a filter against the noise of public markets and routine corporate news.`,
  analyticalFramework: `
**Mandatory Checklist:** You MUST evaluate each headline against these patterns in order:

1.  **Private Company Sale / M&A?** (Score 95-100)
    - Keywords: "sells", "acquires", "merges", "divests", "buyout".
    - Target: A private or family-owned business.
    - Example: "Local Tech Firm acquired by Visma" -> HIGHLY RELEVANT.

2.  **Family/Individual Wealth Statement?** (Score 90-95)
    - Keywords: "fortune", "wealth", "net worth", "rich list", "billionaire", "inheritance".
    - Target: A specific family or individual's name.
    - Example: "The Danielsen family's fortune grows" -> TOP-TIER SIGNAL.

3.  **PE/VC Transaction (Acquisition or Exit)?** (Score 85-95)
    - Keywords: "EQT", "Polaris", "Altor", "acquires", "invests in", "exits".
    - Logic: An acquisition or exit IS a liquidity event for the owners. A new investment (funding round) is NOT.
    - Example: "EQT exits stake in Company X" -> RELEVANT.
    - Example: "New startup raises capital from EQT" -> IRRELEVANT (Score 0-10).

4.  **Public Market Sale by Principal?** (Score 80-90)
    - Keywords: "founder sells", "family sells stake", "major owner divests".
    - Logic: A principal (founder, family, major private holder) selling a large block of a PUBLIC company.
    - Example: "Spotify founder Daniel Ek sells $100M in shares" -> RELEVANT.

5.  **Legal/Financial Dispute of UHNW Entity?** (Score 75-85)
    - Keywords: "dispute", "lawsuit", "investigation", "sues".
    - Target: A known UHNW family or their primary company.
    - Logic: This is critical contextual intelligence.
    - Example: "USTC group (owners of Nordic Waste) disputes bankruptcy claim" -> RELEVANT.

6.  **Speculative Future Event?** (Score 50-70)
    - Keywords: "explores sale", "in talks to", "considers IPO".
    - Logic: An early warning signal.
    - Example: "3Shape considers IPO on Copenhagen exchange" -> RELEVANT.

**If a headline does not match any of the above patterns, it is NOISE. Score it 0-10.**

**RUTHLESS EXCLUSION CRITERIA (CRITICAL):**
-   **Public Market Noise:** Standard stock price movements, earnings reports (unless it's a principal sale per Rule #4).
-   **Corporate Funding:** A company raising capital is NOT a liquidity event for its owners.
-   **Operational News:** New hires, product launches, partnerships, general financial analysis, market commentary.
-   **Trivial "Private Economy" News:** Articles about consumer finance, mortgages, neighborly disputes, or lifestyle choices are irrelevant.
-   **Sports, Culture, Geopolitics:** Unless there is a direct, significant financial transaction involving a private individual, these are irrelevant.
-   **Conciseness Mandate:** Your \`assessment_headline\` MUST be a short, keyword-based phrase. (e.g., "Private sale.", "Family wealth profile.", "PE acquisition.", "Public market noise."). It MUST NOT be a full sentence.
`,
  outputFormatDescription: `
Respond with a valid JSON object with a top-level "assessment" key.
Example JSON:
{{
  "assessment": [
    {{
      "headline_en": "The Danielsen family's fortune approaches DKK 2 billion",
      "relevance_headline": 95,
      "assessment_headline": "Family wealth statement."
    }}
  ]
}}
`,
}

```

## 📄 .tmp_backups/prompts/src/instructionOpportunities.js.bak
*Lines: 24, Size: 4.05 KB*

```
// packages/prompts/src/instructionOpportunities.js (version 3.2)
import { settings } from '@headlines/config/server'

export const getInstructionOpportunities = () => ({
  whoYouAre:
    'You are a ruthless M&A deal-flow data extraction engine. Your output is pure, structured JSON data for a CRM. You are obsessively focused on identifying individuals who have just gained or already possess significant liquid wealth.',
  whatYouDo: `Your sole mission is to analyze news data and extract a list of ALL individuals who are prime candidates for wealth management services (>$${settings.MINIMUM_EVENT_AMOUNT_USD_MILLIONS}M). You must estimate the wealth associated with the specific event or profile.`,
  guidelines: [
    '**M&A ANALYSIS (Non-Negotiable Rule #1)**: In any M&A transaction (merger, acquisition, sale), your **unwavering primary target** is the **SELLER** of a **PRIVATELY-HELD ASSET**. The buyer is irrelevant. You must deduce who the sellers are, even if they are not explicitly named (e.g., "the founding family", "the owners").',
    "**WEALTH PROFILE ANALYSIS (Non-negotiable Rule #2)**: If the article is a **wealth profile** or a report on the financial success of a specific, named individual (like a Rich List member like Troels Holch Povlsen), you MUST list them. The 'whyContact' reason should be 'Identified as a UHNW individual with significant existing assets.'",
    `**WEALTH THRESHOLD (Non-Negotiable Rule #3)**: You MUST NOT generate an opportunity if \`likelyMMDollarWealth\` is less than ${settings.MINIMUM_EVENT_AMOUNT_USD_MILLIONS}. An "opportunity" with less than $${settings.MINIMUM_EVENT_AMOUNT_USD_MILLIONS}M wealth is a system failure. If no individual in the article meets this criteria, you MUST return an empty "opportunities" array.`,
    '**WEALTH ESTIMATION (NEW NUANCE)**: You MUST provide a numerical estimate for `likelyMMDollarWealth`. If the article provides a specific transaction amount, use it to estimate the wealth. If no amount is mentioned, use your general knowledge about the company or individual to make a *conservative* estimate. If you cannot make a reasonable estimate based on the text, use `null` for the value.',
    '**CONTACT DETAILS & ROLE (STRICT)**: The `contactDetails` field MUST be a JSON object containing `email`, `role`, and `company`. You will often receive an `email_suggestion` in the input context for key individuals; you MUST use this value for the `email` field. You are FORBIDDEN from inventing placeholder emails or domains. If an email is not provided or cannot be plausibly inferred, its value MUST be `null`. You MUST specify their role in the transaction (e.g., "Founder & Seller", "Majority Shareholder", "Acquiring Principal"). If any detail is unknown, its value should be `null`.',
    "**LOCATION FORMATTING (CRITICAL):** The `basedIn` field MUST contain a valid, fully-written, UN-recognized sovereign country name (e.g., 'United Kingdom', 'United States of America'), or one of the special regions 'Global', 'Europe', 'Scandinavia', or 'Unknown'. You are FORBIDDEN from using abbreviations (like 'UK' or 'USA'), and from adding cities or any other descriptive text. The `city` field should contain the city name if available.",
    '**REASON FORMATTING (CRITICAL UPDATE)**: The `whyContact` field MUST now be an array of strings. Each string should be a concise, one-sentence reason for contact. For example: `["Received significant liquidity from the sale of Eliantie to ProData Consult."]`',
    '**EVENT KEY (MANDATORY)**: You MUST extract the `event_key` from the provided context and include it in each opportunity object.',
    '**reachOutTo FORMAT (CRITICAL)**: The `reachOutTo` field MUST be a simple string containing the person or family name, NOT a nested object.'
  ],
  outputFormatDescription: `
    Respond ONLY with a valid JSON object containing a single key "opportunities", which is an array of objects.
    Each object in the array MUST contain the key "reachOutTo" as a STRING.
    IF NO CONTACTS ARE FOUND, OR IF NO CONTACTS MEET THE $${settings.MINIMUM_EVENT_AMOUNT_USD_MILLIONS}M WEALTH THRESHOLD, RETURN AN EMPTY ARRAY.`,
})

```

## 📄 .tmp_backups/prompts/src/instructionSynthesize.js.bak
*Lines: 31, Size: 2.56 KB*

```
// packages/prompts/src/instructionSynthesize.js (version 3.2)
export const instructionSynthesize = {
  whoYouAre:
    'You are an expert financial journalist working for an exclusive executive briefing service in English. Your task is to perform targeted information extraction and synthesis.',
  whatYouDo:
    'You will analyze a collection of related news articles and contextual data to produce a single, unified, and fact-checked brief about a core wealth event.',
  guidelines: [
    '1. **IDENTIFY ALL CORE EVENTS:** The provided text may describe multiple distinct wealth events. Your first task is to identify every single one. An article about a company sale might also mention a recent founder dividend payment; these are two separate events.',
    '2. **RUTHLESSLY IGNORE PERIPHERAL NOISE:** For each event you identify, your synthesized headline and summary MUST focus exclusively on that event.',
    `3. **DETERMINE COUNTRY (CRITICAL):** For each event, you MUST determine the primary country. The value MUST be a fully-written, UN-recognized sovereign country name (e.g., 'United Kingdom', 'United States of America'), or one of the special regions 'Global', 'Europe', 'Scandinavia', or 'Unknown'. You are FORBIDDEN from using abbreviations or adding extra text.`,
    '4. **CONSOLIDATE KEY INDIVIDUALS:** For each event, identify and list the key individuals involved in that specific event.',
    '5. **SYNTHESIZE HEADLINE & SUMMARY:** For each event, write a new, dense, factual headline and a concise summary (max 4 sentences, under 90 words).',
    '6. **CREATE ADVISOR SUMMARY (CRITICAL):** For each event, you MUST write an `advisor_summary`. This is a single, concise sentence that directly answers "Why is this relevant to a wealth advisor?" and focuses on the event\'s implication.',
    '7. **FORBIDDEN PHRASES:** NEVER state that "context was not available" or mention any limitations.',
  ],
  outputFormatDescription: `
    Respond ONLY with a valid JSON object with a single key "events", which is an array of event objects. If you find no events, return an empty array.
    {{
      "events": [
        {{
          "headline": "New, synthesized headline for the FIRST event.",
          "summary": "New, synthesized summary for the FIRST event.",
          "advisor_summary": "The one-sentence actionable summary for the FIRST event.",
          "country": "The single, primary country from the allowed list for the FIRST event.",
          "key_individuals": [ {{ "name": "...", "role_in_event": "...", "company": "...", "email_suggestion": "..." }} ]
        }}
      ]
    }}
  `,
}

```

## 📄 .tmp_backups/scraper-logic/ai/agents/batchArticleAgent.js.bak
*Lines: 63, Size: 2.04 KB*

```
// packages/scraper-logic/src/ai/agents/batchArticleAgent.js (version 1.0)
// DEFINITIVE FIX: Corrected import path for getConfig.
import { getConfig } from '../../config.js'
import { AIAgent } from '../AIAgent.js'
import { batchArticleAssessmentSchema } from '../schemas/batchArticleAssessmentSchema.js'
import { env } from '@headlines/config'
import { getInstructionBatchArticleAssessment } from '@headlines/prompts'
import { assessArticleContent } from './articleAgent.js' // Fallback

const BATCH_SIZE = 5

const getAgent = () =>
  new AIAgent({
    model: env.LLM_MODEL_ARTICLE_ASSESSMENT,
    systemPrompt: getInstructionBatchArticleAssessment,
    zodSchema: batchArticleAssessmentSchema,
  })

export async function batchAssessArticles(articles) {
  if (!articles || articles.length === 0) return []

  const batchAgent = getAgent()
  const articleBatches = []
  for (let i = 0; i < articles.length; i += BATCH_SIZE) {
    articleBatches.push(articles.slice(i, i + BATCH_SIZE))
  }

  const allResults = []

  for (const batch of articleBatches) {
    const payload = batch.map((article) => ({
      headline: article.headline,
      content: (article.articleContent?.contents || []).join('\n'),
    }))

    const response = await batchAgent.execute(JSON.stringify(payload))

    if (response.error || response.assessments.length !== batch.length) {
      getConfig().logger.error(
        {
          details: response,
          expectedCount: batch.length,
          receivedCount: response.assessments?.length,
        },
        'Batch assessment failed or returned mismatched count. Falling back to single-article processing for this batch.'
      )

      const fallbackPromises = batch.map((article) => assessArticleContent(article))
      const fallbackResults = await Promise.all(fallbackPromises)
      allResults.push(...fallbackResults)
      continue
    }

    const mergedResults = batch.map((originalArticle, index) => ({
      ...originalArticle,
      ...response.assessments[index],
    }))
    allResults.push(...mergedResults)
  }

  return allResults
}

```

## 📄 .tmp_backups/scraper-logic/ai/agents/clusteringAgent.js.bak
*Lines: 70, Size: 2.34 KB*

```
// packages/scraper-logic/src/ai/agents/clusteringAgent.js (version 2.2.1)
// DEFINITIVE FIX: Corrected import path for getConfig.
import { getConfig } from '../../config.js'
import { AIAgent } from '../AIAgent.js'
import { clusterSchema } from '../schemas/clusterSchema.js'
import { env } from '@headlines/config'
import { instructionCluster } from '@headlines/prompts'

const getAgent = () =>
  new AIAgent({
    model: env.LLM_MODEL_ARTICLE_ASSESSMENT,
    systemPrompt: instructionCluster,
    zodSchema: clusterSchema,
  })

export async function clusterArticlesIntoEvents(articles) {
  const articleClusterAgent = getAgent()
  getConfig().logger.info(`Clustering ${articles.length} articles into unique events...`)
  const CLUSTER_BATCH_SIZE = 25
  const batches = []
  for (let i = 0; i < articles.length; i += CLUSTER_BATCH_SIZE) {
    batches.push(articles.slice(i, i + CLUSTER_BATCH_SIZE))
  }
  getConfig().logger.info(`Processing clusters in ${batches.length} batches.`)

  const allClusters = []
  for (const [index, batch] of batches.entries()) {
    getConfig().logger.info(`Clustering batch ${index + 1} of ${batches.length}...`)
    const articlePayload = batch.map((a) => ({
      id: a._id.toString(),
      headline: a.headline,
      source: a.newspaper,
      summary: (a.topic || a.assessment_article || '').substring(0, 400),
    }))
    const userContent = JSON.stringify(articlePayload)
    const response = await articleClusterAgent.execute(userContent)

    if (response.error || !response.events) {
      getConfig().logger.error(`Failed to cluster articles in batch ${index + 1}.`, {
        response,
      })
      continue
    }
    allClusters.push(...response.events)
  }

  if (allClusters.length === 0) {
    getConfig().logger.warn('Failed to cluster any articles across all batches.')
    return []
  }

  const finalEventMap = new Map()
  allClusters.forEach((event) => {
    if (finalEventMap.has(event.event_key)) {
      const existing = finalEventMap.get(event.event_key)
      event.article_ids.forEach((id) => existing.article_ids.add(id))
    } else {
      finalEventMap.set(event.event_key, {
        event_key: event.event_key,
        article_ids: new Set(event.article_ids),
      })
    }
  })

  return Array.from(finalEventMap.values()).map((event) => ({
    event_key: event.event_key,
    article_ids: Array.from(event.article_ids),
  }))
}

```

## 📄 .tmp_backups/scraper-logic/ai/agents/emailAgents.js.bak
*Lines: 62, Size: 2.28 KB*

```
// packages/scraper-logic/src/ai/agents/emailAgents.js (version 2.2.1)
// DEFINITIVE FIX: Corrected import path for getConfig.
import { getConfig } from '../../config.js'
import { AIAgent } from '../AIAgent.js'
import { emailSubjectSchema } from '../schemas/emailSubjectSchema.js'
import { emailIntroSchema } from '../schemas/emailIntroSchema.js'
import { env } from '@headlines/config'
import { instructionEmailSubject } from '@headlines/prompts'
import { instructionEmailIntro } from '@headlines/prompts'

const getAgent = (systemPrompt, zodSchema) =>
  new AIAgent({
    model: env.LLM_MODEL_SYNTHESIS,
    systemPrompt,
    zodSchema,
  })

export async function generateEmailSubjectLine(events) {
  const subjectLineAgent = getAgent(instructionEmailSubject, emailSubjectSchema)
  try {
    const eventPayload = events.map((e) => ({
      headline: e.synthesized_headline,
      summary: e.synthesized_summary,
    }))
    const response = await subjectLineAgent.execute(JSON.stringify(eventPayload))
    if (response.error || !response.subject_headline) {
      getConfig().logger.warn(
        'AI failed to generate a custom email subject line.',
        response
      )
      return 'Key Developments' // Fallback
    }
    return response.subject_headline
  } catch (error) {
    getConfig().logger.error({ err: error }, 'Error in generateEmailSubjectLine')
    return 'Key Developments' // Fallback
  }
}

export async function generatePersonalizedIntro(user, events) {
  const introAgent = getAgent(instructionEmailIntro, emailIntroSchema)
  try {
    const eventPayload = events.map((e) => ({
      headline: e.synthesized_headline,
      summary: e.synthesized_summary,
    }))
    const payload = {
      firstName: user.firstName,
      events: eventPayload,
    }
    const response = await introAgent.execute(JSON.stringify(payload))
    if (response.error || !response.intro_text) {
      getConfig().logger.warn('AI failed to generate a personalized intro.', response)
      return `Dear ${user.firstName}, here are the latest relevant wealth events we have identified.`
    }
    return response.intro_text
  } catch (error) {
    getConfig().logger.error({ err: error }, 'Error in generatePersonalizedIntro')
    return `Dear ${user.firstName}, here are the latest relevant wealth events we have identified.`
  }
}

```

## 📄 .tmp_backups/scraper-logic/ai/agents/executiveSummaryAgent.js.bak
*Lines: 40, Size: 1.37 KB*

```
// packages/scraper-logic/src/ai/agents/executiveSummaryAgent.js (version 2.0)
// DEFINITIVE FIX: Corrected import path for getConfig.
import { getConfig } from '../../config.js'
import { AIAgent } from '../AIAgent.js'
import { env } from '@headlines/config'
import { instructionExecutiveSummary } from '@headlines/prompts'
import { z } from 'zod'

const executiveSummarySchema = z.object({
  summary: z.string(),
})

const getAgent = () =>
  new AIAgent({
    model: env.LLM_MODEL_SYNTHESIS,
    systemPrompt: instructionExecutiveSummary,
    zodSchema: executiveSummarySchema,
  })

export async function generateExecutiveSummary(judgeVerdict, runStats) {
  const agent = getAgent()
  try {
    // Create a payload with the crucial context
    const payload = {
      freshHeadlinesFound: runStats.freshHeadlinesFound,
      judgeVerdict: judgeVerdict || { event_judgements: [], opportunity_judgements: [] },
    }

    const response = await agent.execute(JSON.stringify(payload))
    if (response.error || !response.summary) {
      getConfig().logger.warn('AI failed to generate an executive summary.', response)
      return 'AI failed to generate a summary for this run.'
    }
    return response.summary
  } catch (error) {
    getConfig().logger.error({ err: error }, 'Error in generateExecutiveSummary')
    return 'An unexpected error occurred while generating the executive summary.'
  }
}

```

## 📄 .tmp_backups/scraper-logic/ai/agents/headlineAgent.js.bak
*Lines: 99, Size: 3.36 KB*

```
// packages/scraper-logic/src/ai/agents/headlineAgent.js (version 4.1.3)
import pLimit from 'p-limit'
import { AIAgent } from '../AIAgent.js'
import { headlineAssessmentSchema } from '../schemas/headlineAssessmentSchema.js'
import { env } from '@headlines/config'
import { instructionHeadlines } from '@headlines/prompts'
import { shotsInputHeadlines } from '@headlines/prompts'
import { shotsOutputHeadlines } from '@headlines/prompts'
import { getConfig } from '../../config.js'

const getAgent = () =>
  new AIAgent({
    model: env.LLM_MODEL_HEADLINE_ASSESSMENT,
    systemPrompt: instructionHeadlines,
    fewShotInputs: shotsInputHeadlines,
    fewShotOutputs: shotsOutputHeadlines,
    zodSchema: headlineAssessmentSchema,
  })

function findWatchlistHits(text, country) {
  const hits = new Map()
  const lowerText = text.toLowerCase()
  const config = getConfig()
  if (!getConfig().configStore?.watchlistEntities) return []

  const createSearchRegex = (term) =>
    new RegExp(`\\b${term.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\b`, 'i')

  const relevantEntities = Array.from(
    getConfig().configStore.watchlistEntities.values()
  ).filter(
    (entity) =>
      !entity.country ||
      entity.country === country ||
      entity.country === 'Global PE' ||
      entity.country === 'M&A Aggregators'
  )

  for (const entity of relevantEntities) {
    const nameKey = entity.name.toLowerCase()
    if (nameKey.length > 3 && createSearchRegex(nameKey).test(lowerText)) {
      if (!hits.has(entity.name)) hits.set(entity.name, { entity, matchedTerm: nameKey })
    }
    for (const term of entity.searchTerms || []) {
      if (term.length > 3 && createSearchRegex(term).test(lowerText)) {
        if (!hits.has(entity.name)) hits.set(entity.name, { entity, matchedTerm: term })
      }
    }
  }
  return Array.from(hits.values())
}

async function assessSingleHeadline(article) {
  const headlineAssessmentAgent = getAgent()
  const hits = findWatchlistHits(article.headline, article.country)
  let headlineWithContext = `[COUNTRY CONTEXT: ${article.country}] ${article.headline}`

  if (hits.length > 0) {
    const hitStrings = hits
      .map(
        (hit) => `[WATCHLIST HIT: ${hit.entity.name} (matched on '${hit.matchedTerm}')]`
      )
      .join(' ')
    headlineWithContext = `${hitStrings} ${headlineWithContext}`
  }

  const response = await headlineAssessmentAgent.execute(headlineWithContext)

  let assessment = {
    relevance_headline: 0,
    assessment_headline: 'AI assessment failed.',
    headline_en: article.headline,
  }

  if (response && response.assessment && response.assessment.length > 0) {
    assessment = response.assessment[0]
    let score = assessment.relevance_headline
    // DEFINITIVE FIX: Corrected the property access for WATCHLIST_SCORE_BOOST
    const boost = getConfig().settings.WATCHLIST_SCORE_BOOST
    if (hits.length > 0 && boost > 0) {
      score = Math.min(100, score + boost)
      assessment.assessment_headline = `Watchlist boost (+${boost}). ${assessment.assessment_headline}`
    }
    assessment.relevance_headline = score
  }

  return { ...article, ...assessment }
}

export async function assessHeadlinesInBatches(articles) {
  const limit = pLimit(env.CONCURRENCY_LIMIT)
  const assessmentPromises = articles.map((article) =>
    limit(() => assessSingleHeadline(article))
  )

  const results = await Promise.all(assessmentPromises)
  return results
}

```

## 📄 .tmp_backups/scraper-logic/ai/agents/judgeAgent.js.bak
*Lines: 63, Size: 1.91 KB*

```
// packages/scraper-logic/src/ai/agents/judgeAgent.js (version 2.3.2)
// DEFINITIVE FIX: Corrected import path for getConfig.
import { getConfig } from '../../config.js'
import { AIAgent } from '../AIAgent.js'
import { judgeSchema } from '../schemas/judgeSchema.js'
import { env } from '@headlines/config'
import { instructionJudge } from '@headlines/prompts'

const getAgent = () =>
  new AIAgent({
    model: env.LLM_MODEL_SYNTHESIS,
    systemPrompt: instructionJudge,
    zodSchema: judgeSchema,
  })

export async function judgePipelineOutput(events, opportunities) {
  const judgeAgent = getAgent()
  if (
    (!events || events.length === 0) &&
    (!opportunities || opportunities.length === 0)
  ) {
    return {
      event_judgements: [],
      opportunity_judgements: [],
    }
  }
  getConfig().logger.info(
    '⚖️ [Judge Agent] Reviewing final pipeline output for quality control...'
  )
  const lightweightEvents = (events || []).map((e) => ({
    identifier: `Event: ${e.synthesized_headline}`,
    summary: e.synthesized_summary,
    assessment: e.ai_assessment_reason,
    score: e.highest_relevance_score,
  }))
  const lightweightOpportunities = (opportunities || []).map((o) => ({
    identifier: `Opportunity: ${o.reachOutTo}`,
    reason: o.whyContact,
    wealth_estimate_mm: o.likelyMMDollarWealth,
  }))
  const inputText = JSON.stringify({
    events: lightweightEvents,
    opportunities: lightweightOpportunities,
  })
  const response = await judgeAgent.execute(inputText)
  if (response.error) {
    getConfig().logger.error(
      { details: response },
      'Judge Agent failed to produce a verdict.'
    )
    // Return a default "empty" verdict on failure to avoid crashing the pipeline
    return {
      event_judgements: [],
      opportunity_judgements: [],
    }
  }
  getConfig().logger.info(
    { details: response },
    '[Judge Agent] Successfully produced quality control verdicts.'
  )
  return response
}

```

## 📄 .tmp_backups/scraper-logic/ai/agents/selectorRepairAgent.js.bak
*Lines: 53, Size: 1.52 KB*

```
// packages/scraper-logic/src/ai/agents/selectorRepairAgent.js (version 3.0.0)
import { truncateString } from '@headlines/utils'
// DEFINITIVE FIX: Corrected import path for getConfig.
import { getConfig } from '../../config.js'
import { AIAgent } from '../AIAgent.js'
import { selectorRepairSchema } from '../schemas/selectorRepairSchema.js'
import { env } from '@headlines/config'
import { instructionSelectorRepair } from '@headlines/prompts'

const getAgent = () =>
  new AIAgent({
    model: env.LLM_MODEL_UTILITY,
    systemPrompt: instructionSelectorRepair,
    zodSchema: selectorRepairSchema,
  })

export async function suggestNewSelector(
  url,
  failedSelector,
  htmlContent,
  heuristicSuggestions = []
) {
  const selectorRepairAgent = getAgent()
  try {
    const payload = {
      url,
      failed_selector: failedSelector,
      // NEW: Add heuristic suggestions to the payload
      heuristic_suggestions: heuristicSuggestions.map((s) => ({
        selector: s.selector,
        samples: s.samples.slice(0, 3),
      })),
      html_content: truncateString(htmlContent, 30000),
    }

    const response = await selectorRepairAgent.execute(JSON.stringify(payload))
    if (response.error || !response.suggested_selectors) {
      getConfig().logger.error(
        'Selector repair agent failed to produce a valid suggestion.',
        {
          response,
        }
      )
      return null
    }

    return response
  } catch (error) {
    getConfig().logger.error({ err: error }, 'Error in suggestNewSelector')
    return null
  }
}

```

## 📄 .tmp_backups/scraper-logic/ai/agents/watchlistAgent.js.bak
*Lines: 44, Size: 1.64 KB*

```
// packages/scraper-logic/src/ai/agents/watchlistAgent.js (version 2.3.1)
// DEFINITIVE FIX: Corrected import path for getConfig.
import { getConfig } from '../../config.js'
import { AIAgent } from '../AIAgent.js'
import { watchlistSuggestionSchema } from '../schemas/watchlistSuggestionSchema.js'
import { env } from '@headlines/config'
import { instructionWatchlistSuggestion } from '@headlines/prompts'

const getAgent = () =>
  new AIAgent({
    model: env.LLM_MODEL_SYNTHESIS,
    systemPrompt: instructionWatchlistSuggestion,
    zodSchema: watchlistSuggestionSchema,
  })

/**
 * Analyzes events to generate new watchlist suggestions.
 * @param {Array<object>} events - High-quality synthesized events.
 * @param {Set<string>} existingWatchlistNames - A set of lowercase names already on the watchlist.
 * @returns {Promise<Array<object>>} An array of new WatchlistSuggestion documents.
 */
export async function generateWatchlistSuggestions(events, existingWatchlistNames) {
  const watchlistSuggestionAgent = getAgent()
  try {
    const payload = { events }
    const response = await watchlistSuggestionAgent.execute(JSON.stringify(payload))

    if (response.error || !Array.isArray(response.suggestions)) {
      getConfig().logger.warn('AI failed to generate watchlist suggestions.', response)
      return []
    }

    // Post-filter to ensure we don't suggest entities that already exist
    const newSuggestions = response.suggestions.filter(
      (s) => !existingWatchlistNames.has(s.name.toLowerCase())
    )

    return newSuggestions
  } catch (error) {
    getConfig().logger.error({ err: error }, 'Error in generateWatchlistSuggestions')
    return []
  }
}

```

## 📄 .tmp_backups/scraper-logic/src/pipeline/submodules/opportunityUpserter.js.bak
*Lines: 163, Size: 5.47 KB*

```
// apps/pipeline/src/pipeline/submodules/opportunityUpserter.js (version 7.0.0)
import { Opportunity, SynthesizedEvent, WatchlistEntity } from '@headlines/models'
import { logger } from '@headlines/utils/server';
import { contactFinderChain, entityCanonicalizerChain } from '@headlines/ai-services'
import { getConfig } from '@headlines/scraper-logic/src/config.js'

async function selfCorrectWatchlist(opportunityName, canonicalName) {
  if (opportunityName.toLowerCase() === canonicalName.toLowerCase()) return

  const watchlistEntity = await WatchlistEntity.findOne({ name: canonicalName })
  if (watchlistEntity) {
    const newSearchTerm = opportunityName.toLowerCase().trim()
    if (!watchlistEntity.searchTerms.includes(newSearchTerm)) {
      watchlistEntity.searchTerms.push(newSearchTerm)
      await watchlistEntity.save()
      logger.info(
        `[Self-Correct] Added search term '${newSearchTerm}' to watchlist entity '${canonicalName}'.`
      )
    }
  }
}

async function findContactEmail(person) {
  const config = getConfig()
  logger.info(`[Contact Research] Initiated for: ${person.reachOutTo}`)
  const queries = [
    `"${person.reachOutTo}" ${person.contactDetails.company} email address`,
    `"${person.reachOutTo}" contact information`,
  ]

  let combinedSnippets = ''
  for (const query of queries) {
    const searchResult = await config.utilityFunctions.performGoogleSearch(query)
    if (searchResult.success && searchResult.snippets) {
      combinedSnippets += `\n--- Results for query: "${query}" ---\n${searchResult.snippets}`
    }
  }

  if (!combinedSnippets) {
    logger.warn(`[Contact Research] No search results for "${person.reachOutTo}".`)
    return null
  }

  const response = await contactFinderChain.invoke({ snippets: combinedSnippets })

  if (response.error || !response.email) {
    logger.warn(
      `[Contact Research] LLM failed to extract email for "${person.reachOutTo}".`
    )
    return null
  }

  logger.info(
    { email: response.email },
    `[Contact Research] Found email for "${person.reachOutTo}".`
  )
  return response.email
}

export async function enrichAndLinkOpportunities(potentialOpportunities, savedEvents) {
  if (!potentialOpportunities || potentialOpportunities.length === 0) {
    return []
  }

  logger.info(
    `--- Opportunity Enrichment & Linking: Processing ${potentialOpportunities.length} potential opportunities... ---`
  )

  const canonicalizedOpportunities = await Promise.all(
    potentialOpportunities.map(async (opp) => {
      const originalName = opp.reachOutTo
      const response = await entityCanonicalizerChain.invoke({
        entity_name: originalName,
      })
      if (response && !response.error && response.canonical_name) {
        opp.reachOutTo = response.canonical_name
        await selfCorrectWatchlist(originalName, response.canonical_name)
      }
      return opp
    })
  )

  const enrichedOpportunities = await Promise.all(
    canonicalizedOpportunities.map(async (opp) => {
      if (!opp.contactDetails.email) {
        const email = await findContactEmail(opp)
        if (email) {
          opp.contactDetails.email = email
        }
      }
      return opp
    })
  )

  // CORRECTED LOGIC: Separate upsert and update operations to avoid conflict.
  const findOrCreateOps = enrichedOpportunities.map((opp) => {
      const whyContactArray = Array.isArray(opp.whyContact) ? opp.whyContact : [opp.whyContact];
      return {
          updateOne: {
              filter: { reachOutTo: opp.reachOutTo },
              update: {
                  $setOnInsert: {
                      reachOutTo: opp.reachOutTo,
                      basedIn: opp.basedIn,
                      likelyMMDollarWealth: opp.likelyMMDollarWealth,
                      contactDetails: opp.contactDetails,
                  },
                  // Use $addToSet to add new reasons without creating duplicates
                  $addToSet: { whyContact: { $each: whyContactArray } }
              },
              upsert: true,
          },
      };
  });


  if (findOrCreateOps.length > 0) {
    await Opportunity.bulkWrite(findOrCreateOps, { ordered: false })
  }

  const allOppNames = enrichedOpportunities.map((o) => o.reachOutTo)
  const allOpportunityDocs = await Opportunity.find({ reachOutTo: { $in: allOppNames } })
  const oppMap = new Map(allOpportunityDocs.map((o) => [o.reachOutTo, o]))
  const eventMap = new Map(savedEvents.map((e) => [e.event_key, e]))

  const oppLinkOps = []
  const eventLinkOps = []

  for (const enrichedOpp of enrichedOpportunities) {
    const opportunityDoc = oppMap.get(enrichedOpp.reachOutTo)
    const eventDoc = eventMap.get(enrichedOpp.event_key)
    if (opportunityDoc && eventDoc) {
      eventLinkOps.push({
        updateOne: {
          filter: { _id: eventDoc._id },
          update: { $addToSet: { relatedOpportunities: opportunityDoc._id } },
        },
      })
      oppLinkOps.push({
        updateOne: {
          filter: { _id: opportunityDoc._id },
          update: {
            $addToSet: { events: eventDoc._id },
            $max: { likelyMMDollarWealth: enrichedOpp.likelyMMDollarWealth },
          },
        },
      })
    }
  }

  if (oppLinkOps.length > 0) {
    await Promise.all([
      Opportunity.bulkWrite(oppLinkOps, { ordered: false }),
      SynthesizedEvent.bulkWrite(eventLinkOps, { ordered: false }),
    ])
    logger.info(
      `Successfully linked ${oppLinkOps.length} opportunity-event relationships.`
    )
  }

  return Opportunity.find({ _id: { $in: allOpportunityDocs.map((o) => o._id) } }).lean()
}

```

## 📄 .tmp_backups/ui/src/EditableCell.jsx.bak
*Lines: 62, Size: 2.45 KB*

```
// packages/ui/src/EditableCell.jsx (version 1.0.0)
'use client'

import React, { useState, useEffect, useRef } from 'react';
import { Input } from './components/input';
import { Edit } from 'lucide-react';
import { cn } from '@headlines/utils';

export const EditableCell = ({ initialValue, onSave, placeholder = 'N/A', type = 'text', allowWrap = false }) => {
    const [isEditing, setIsEditing] = useState(false);
    const [value, setValue] = useState(initialValue || '');
    const inputRef = useRef(null);
    const wrapperRef = useRef(null);

    const handleSave = () => {
        const finalValue = type === 'number' ? (value ? Number(value) : null) : value.trim();
        if (finalValue !== (initialValue || (type === 'number' ? null : ''))) {
            onSave(finalValue);
        }
        setIsEditing(false);
    };

    useEffect(() => {
        function handleClickOutside(event) {
            if (wrapperRef.current && !wrapperRef.current.contains(event.target)) {
                if (isEditing) {
                    handleSave();
                }
            }
        }
        
        if (isEditing) {
            inputRef.current?.focus();
            // Bind the event listener
            document.addEventListener("mousedown", handleClickOutside);
            return () => {
                // Unbind the event listener on clean up
                document.removeEventListener("mousedown", handleClickOutside);
            };
        }
    }, [isEditing]); // Only re-run the effect if isEditing changes

    if (isEditing) {
        return (
            <div ref={wrapperRef}>
                <Input type={type} ref={inputRef} value={value} onChange={(e) => setValue(e.target.value)} onKeyDown={(e) => { if (e.key === 'Enter') handleSave() }} className="h-8 bg-secondary"/>
            </div>
        );
    }
    
    let displayValue = initialValue;
    if (type === 'number' && initialValue) displayValue = `$${initialValue}M`;
    if (!initialValue || initialValue.length === 0) displayValue = <span className="text-muted-foreground italic">{placeholder}</span>;

    return (
        <div className="group flex items-center cursor-pointer p-2 -m-2 rounded-md hover:bg-secondary/50" onClick={() => setIsEditing(true)}>
            <span className={cn(!allowWrap && "truncate", allowWrap && "whitespace-normal")}>{displayValue}</span>
            <Edit className="h-3 w-3 ml-auto text-muted-foreground opacity-0 group-hover:opacity-100 flex-shrink-0"/>
        </div>
    );
}

```

## 📄 .tmp_backups/ui/src/ExportButton.jsx.bak
*Lines: 46, Size: 1.59 KB*

```
// packages/ui/src/ExportButton.jsx (version 1.0)
'use client'

import { useState } from 'react';
import { Button } from './components/button';
import { Download, Loader2 } from 'lucide-react';
import { toast } from 'sonner';

export function ExportButton({ data, filename, exportAction }) {
    const [isLoading, setIsLoading] = useState(false);

    const handleExport = async () => {
        if (!data || data.length === 0) {
            toast.info("No data available to export.");
            return;
        }
        setIsLoading(true);
        const result = await exportAction(data);
        setIsLoading(false);

        if (result.success) {
            const blob = new Blob([result.data], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", `${filename}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                toast.success("Export successful!");
            }
        } else {
            toast.error("Export failed", { description: result.error });
        }
    };

    return (
        <Button onClick={handleExport} disabled={isLoading || !data || data.length === 0}>
            {isLoading ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Download className="mr-2 h-4 w-4" />}
            Export CSV
        </Button>
    );
}

```

## 📄 .tmp_backups/ui/src/data-table.jsx.bak
*Lines: 246, Size: 8.54 KB*

```
// packages/ui/src/data-table.jsx (version 2.9.2)
'use client'

import React, { useState, useEffect, useRef, useCallback } from 'react'
import {
  flexRender,
  getCoreRowModel,
  getFilteredRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  useReactTable,
} from '@tanstack/react-table'
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from './components/table'
import { Input } from './components/input'
import { Button } from './components/button'
import { Checkbox } from './components/checkbox'
import { LoadingOverlay } from './LoadingOverlay'
import { ScrollArea } from './components/scroll-area'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from './components/select'

const ROW_HEIGHT = 65; 

const useDynamicPageSize = (containerRef, dataLength) => {
    const [pageSize, setPageSize] = useState(10);

    const calculatePageSize = useCallback(() => {
        if (containerRef.current) {
            const containerHeight = containerRef.current.offsetHeight;
            const headerFooterHeight = 150; 
            const tableBodyHeight = containerHeight - headerFooterHeight;
            const newPageSize = Math.floor(tableBodyHeight / ROW_HEIGHT);
            // DEFINITIVE FIX: Changed minimum page size from 5 to 13.
            setPageSize(Math.max(13, newPageSize));
        }
    }, [containerRef]);

    useEffect(() => {
        calculatePageSize();
        const handleResize = () => calculatePageSize();
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, [calculatePageSize, dataLength]);

    return pageSize;
};

const PaginationControls = ({ table }) => {
    if (table.getPageCount() <= 1) {
        return <div className="h-10"></div>; 
    }

    return (
        <div className="flex items-center justify-end space-x-2 h-10">
            <span className="text-sm text-muted-foreground">
              Page {table.getState().pagination.pageIndex + 1} of {table.getPageCount()}
            </span>
            {table.getCanPreviousPage() && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => table.previousPage()}
                >
                  Previous
                </Button>
            )}
            {table.getCanNextPage() && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => table.nextPage()}
                >
                  Next
                </Button>
            )}
        </div>
    )
}

const addSelectionColumn = (columns) => [
  { id: 'select', header: ({ table }) => (<Checkbox checked={table.getIsAllPageRowsSelected() || (table.getIsSomePageRowsSelected() && 'indeterminate')} onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)} aria-label="Select all"/>), cell: ({ row }) => (<Checkbox checked={row.getIsSelected()} onCheckedChange={(value) => row.toggleSelected(!!value)} aria-label="Select row"/>), enableSorting: false, enableHiding: false, },
  ...columns,
]

export function DataTable({
  columns,
  data,
  isLoading,
  filterColumn,
  filterPlaceholder,
  secondaryFilterColumn,
  secondaryFilterOptions = [],
  initialSort = [],
  initialStatusFilter,
  enableRowSelection = false,
  onRowSelectionChange, onSecondaryFilterChange,
}) {
  const containerRef = useRef(null);
  const dynamicPageSize = useDynamicPageSize(containerRef, data.length);

  const [sorting, setSorting] = useState(initialSort)
  const [rowSelection, setRowSelection] = useState({})
  const [columnFilters, setColumnFilters] = useState(() => {
    const filters = []
    if (initialStatusFilter) {
      filters.push({ id: 'health', value: initialStatusFilter })
    }
    return filters
  })
  const [pagination, setPagination] = useState({ pageIndex: 0, pageSize: dynamicPageSize });
  
  const tableColumns = React.useMemo(() => enableRowSelection ? addSelectionColumn(columns) : columns, [enableRowSelection, columns]);

  const table = useReactTable({
    data,
    columns: tableColumns,
    getCoreRowModel: getCoreRowModel(),
    onSortingChange: setSorting,
    getSortedRowModel: getSortedRowModel(),
    onColumnFiltersChange: setColumnFilters,
    getFilteredRowModel: getFilteredRowModel(),
    onPaginationChange: setPagination,
    getPaginationRowModel: getPaginationRowModel(),
    onRowSelectionChange: setRowSelection,
    autoResetPageIndex: false,
    state: { sorting, columnFilters, rowSelection, pagination },
  })
  
  useEffect(() => {
    table.setPageSize(dynamicPageSize);
  }, [dynamicPageSize, table]);

  useEffect(() => {
    if (onRowSelectionChange) {
      onRowSelectionChange(table.getSelectedRowModel().flatRows.map(row => row.original));
    }
  }, [rowSelection, onRowSelectionChange, table]);
  
  useEffect(() => {
    table.setPageIndex(0)
  }, [columnFilters, sorting, table])

  return (
    <div className="relative isolate flex flex-col h-full" ref={containerRef}>
      <LoadingOverlay isLoading={isLoading} />
      <div className="relative z-10 flex-shrink-0">
          <div className="flex items-center justify-between py-4">
            <div className="flex items-center gap-4">
              <Input
                placeholder={filterPlaceholder}
                value={table.getColumn(filterColumn)?.getFilterValue() ?? ''}
                onChange={(event) =>
                  table.getColumn(filterColumn)?.setFilterValue(event.target.value)
                }
                className="max-w-sm"
              />
              {secondaryFilterColumn && (
                <Select
                  value={table.getColumn(secondaryFilterColumn)?.getFilterValue() || 'all'}
                  onValueChange={(value) =>
                    table
                      .getColumn(secondaryFilterColumn)
                      ?.setFilterValue(value === 'all' ? undefined : value)
                  }
                >
                  <SelectTrigger className="w-[180px]">
                    <SelectValue placeholder="All..." />
                  </SelectTrigger>
                  <SelectContent>
                    <ScrollArea className="h-72">
                      <SelectItem value="all">
                        All{' '}
                        {secondaryFilterColumn.charAt(0).toUpperCase() +
                          secondaryFilterColumn.slice(1)}
                        s
                      </SelectItem>
                      {secondaryFilterOptions.map((c) => (
                        <SelectItem key={c} value={c}>
                          {c}
                        </SelectItem>
                      ))}
                    </ScrollArea>
                  </SelectContent>
                </Select>
              )}
            </div>
            <PaginationControls table={table} />
          </div>
      </div>
      <div className="flex-grow rounded-md border overflow-hidden">
        <ScrollArea className="h-full">
            <Table>
              <TableHeader className="sticky top-0 bg-background z-10">
                {table.getHeaderGroups().map((headerGroup) => (
                  <TableRow key={headerGroup.id}>
                    {headerGroup.headers.map((header) => (
                      <TableHead key={header.id} style={{ width: header.getSize() !== 150 ? header.getSize() : undefined }}>
                        {header.isPlaceholder
                          ? null
                          : flexRender(header.column.columnDef.header, header.getContext())}
                      </TableHead>
                    ))}
                  </TableRow>
                ))}
              </TableHeader>
              <TableBody>
                {table.getRowModel().rows?.length ? (
                  table.getRowModel().rows.map((row) => (
                    <TableRow
                      key={row.id}
                      data-state={row.getIsSelected() && 'selected'}
                    >
                      {row.getVisibleCells().map((cell) => (
                        <TableCell key={cell.id}>
                          {flexRender(cell.column.columnDef.cell, cell.getContext())}
                        </TableCell>
                      ))}
                    </TableRow>
                  ))
                ) : (
                  <TableRow>
                    <TableCell colSpan={tableColumns.length} className="h-24 text-center">
                      No results.
                    </TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
        </ScrollArea>
      </div>
    </div>
  )
}

```

## 📄 .tmp_backups/ui/src/index.js.bak
*Lines: 65, Size: 4.53 KB*

```
// packages/ui/src/index.js (version 3.1.0)
'use client'

import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from './components/accordion';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogOverlay, AlertDialogPortal, AlertDialogTitle, AlertDialogTrigger } from './components/alert-dialog';
import { Badge, badgeVariants } from './components/badge';
import { Button, buttonVariants } from './components/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from './components/card';
import { Checkbox } from './components/checkbox';
import { Command, CommandDialog, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList, CommandSeparator, CommandShortcut } from './components/command';
import { Dialog, DialogClose, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogOverlay, DialogPortal, DialogTitle, DialogTrigger } from './components/dialog';
import { DropdownMenu, DropdownMenuCheckboxItem, DropdownMenuContent, DropdownMenuGroup, DropdownMenuItem, DropdownMenuLabel, DropdownMenuPortal, DropdownMenuRadioGroup, DropdownMenuRadioItem, DropdownMenuSeparator, DropdownMenuShortcut, DropdownMenuSub, DropdownMenuSubContent, DropdownMenuSubTrigger, DropdownMenuTrigger } from './components/dropdown-menu';
import { Input } from './components/input';
import { Label } from './components/label';
import { Popover, PopoverContent, PopoverTrigger } from './components/popover';
import { ScrollArea, ScrollBar } from './components/scroll-area';
import { Select, SelectContent, SelectGroup, SelectItem, SelectLabel, SelectScrollDownButton, SelectScrollUpButton, SelectSeparator, SelectTrigger, SelectValue } from './components/select';
import { Separator } from './components/separator';
import { Sheet, SheetClose, SheetContent, SheetDescription, SheetFooter, SheetHeader, SheetOverlay, SheetPortal, SheetTitle, SheetTrigger } from './components/sheet';
import { Toaster } from './components/sonner';
import { Switch } from './components/switch';
import { Table, TableBody, TableCaption, TableCell, TableFooter, TableHead, TableHeader, TableRow } from './components/table';
import { Tabs, TabsContent, TabsList, TabsTrigger } from './components/tabs';
import { Textarea } from './components/textarea';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from './components/tooltip';
import { ConfirmationDialog } from './ConfirmationDialog.jsx';
import { DataTable } from './data-table.jsx';
import { LoadingOverlay } from './LoadingOverlay.jsx';
import PageHeader from './page-header.jsx';
import { PremiumSpinner } from './PremiumSpinner.jsx';
import { SkeletonCard } from './SkeletonCard.jsx';
import { EditableCell } from './EditableCell.jsx'; // DEFINITIVE ADDITION

export {
  Accordion, AccordionContent, AccordionItem, AccordionTrigger,
  AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogOverlay, AlertDialogPortal, AlertDialogTitle, AlertDialogTrigger,
  Badge, badgeVariants,
  Button, buttonVariants,
  Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle,
  Checkbox,
  Command, CommandDialog, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList, CommandSeparator, CommandShortcut,
  Dialog, DialogClose, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogOverlay, DialogPortal, DialogTitle, DialogTrigger,
  DropdownMenu, DropdownMenuCheckboxItem, DropdownMenuContent, DropdownMenuGroup, DropdownMenuItem, DropdownMenuLabel, DropdownMenuPortal, DropdownMenuRadioGroup, DropdownMenuRadioItem, DropdownMenuSeparator, DropdownMenuShortcut, DropdownMenuSub, DropdownMenuSubContent, DropdownMenuSubTrigger, DropdownMenuTrigger,
  Input,
  Label,
  Popover, PopoverContent, PopoverTrigger,
  ScrollArea, ScrollBar,
  Select, SelectContent, SelectGroup, SelectItem, SelectLabel, SelectScrollDownButton, SelectScrollUpButton, SelectSeparator, SelectTrigger, SelectValue,
  Separator,
  Sheet, SheetClose, SheetContent, SheetDescription, SheetFooter, SheetHeader, SheetOverlay, SheetPortal, SheetTitle, SheetTrigger,
  Toaster,
  Switch,
  Table, TableBody, TableCaption, TableCell, TableFooter, TableHead, TableHeader, TableRow,
  Tabs, TabsContent, TabsList, TabsTrigger,
  Textarea,
  Tooltip, TooltipContent, TooltipProvider, TooltipTrigger,
  ConfirmationDialog,
  DataTable,
  LoadingOverlay,
  PageHeader,
  PremiumSpinner,
  SkeletonCard,
  EditableCell, // DEFINITIVE ADDITION
};

```

## 📄 .tmp_backups/ui/src/page-header.jsx.bak
*Lines: 22, Size: 666 Bytes*

```
// src/app/_components/page-header.jsx (version 1.1)
'use client'

import { motion } from 'framer-motion'

export default function PageHeader({ title, description, children }) {
  return (
    <motion.div
      initial={{ opacity: 0, y: -20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.4, ease: 'easeInOut' }}
      className="flex-shrink-0 flex justify-between items-start"
    >
      <div>
        <h1 className="text-4xl font-bold tracking-tighter">{title}</h1>
        <p className="text-muted-foreground mt-1">{description}</p>
      </div>
      {children && <div className="flex-shrink-0">{children}</div>}
    </motion.div>
  )
}

```

## 📄 .tmp_backups/utils/src/server.js.bak
*Lines: 31, Size: 925 Bytes*

```
// packages/utils/src/server.js (version 5.1.0)
// This file is the server-only entrypoint for the utils package.
// It uses explicit imports and exports for maximum compatibility.

import { cn, truncateString, escapeHtml, sleep, groupItemsByCountry } from './client-helpers.js';
import { safeExecute, smartStripHtml } from './server-helpers.js';
import { getCountryFlag, COMMON_COUNTRIES } from './countries.js';
import { languageList, languageMap } from './languages.js';
import { logger, initializeLogger, reinitializeLogger } from './logger.js';
import { tokenTracker } from './tokenTracker.js';
import { apiCallTracker } from './apiCallTracker.js';

export {
  languageList,
  languageMap,
  cn,
  truncateString,
  escapeHtml,
  sleep,
  groupItemsByCountry,
  safeExecute,
  smartStripHtml,
  getCountryFlag,
  COMMON_COUNTRIES,
  logger,
  initializeLogger,
  reinitializeLogger,
  tokenTracker,
  apiCallTracker,
};

```

## 📄 headlines-monorepo@1.0.0
*Lines: 1, Size: 0 Bytes*

```

```

## 📄 jest.config.js
*Lines: 10, Size: 217 Bytes*

```javascript
// apps/pipeline/jest.config.js (version 1.0.0)
/** @type {import('jest').Config} */
const config = {
  verbose: true,
  // This is necessary to handle ES Modules correctly
  transform: {},
};

export default config;

```

## 📄 norway.mjs
*Lines: 321, Size: 11 KB*

```
import fs from 'fs/promises'
import path from 'path'
import puppeteer from 'puppeteer' // <-- Import Puppeteer
import * as cheerio from 'cheerio'
import * as readline from 'readline/promises'
import { stdin as input, stdout as output } from 'process'

// --- Configuration ---
const DATA_FILE_PATH = path.join(process.cwd(), 'data', 'norway.json')
const AUTOPILOT_DELAY = 2000 // 2-second delay between requests in autopilot mode

// --- ANSI Colors for better console logging ---
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
}

/**
 * Loads and parses the JSON data from the file.
 * @returns {Promise<object>} The parsed data object.
 */
const loadData = async () => {
  try {
    const fileContent = await fs.readFile(DATA_FILE_PATH, 'utf-8')
    return JSON.parse(fileContent)
  } catch (error) {
    console.error(`${colors.red}Error loading data file: ${error.message}${colors.reset}`)
    process.exit(1)
  }
}

/**
 * Saves the updated data object back to the JSON file.
 * @param {object} data - The data object to save.
 */
const saveData = async (data) => {
  await fs.writeFile(DATA_FILE_PATH, JSON.stringify(data, null, 2))
}

/**
 * Extracts all available structured and unstructured data from the profile's HTML content.
 * Handles both "modern" and "legacy" page layouts.
 * @param {string} html - The HTML content of the profile page.
 * @returns {object} The scraped data.
 */
const extractProfileData = (html) => {
  const $ = cheerio.load(html)
  const scrapedData = {
    page_type: 'unknown',
    date_of_birth: null,
    city: null,
    education: null,
    current_wealth: null,
    wealth_summary: null,
    background_information: null,
    roles: [],
    latest_news: [],
    embedded_article_links: [],
  }

  // --- Helper to clean up text
  const cleanText = (text) => text.trim().replace(/\s\s+/g, ' ')

  // --- Check for "Modern" Layout ---
  if ($('main nav').length > 0) {
    scrapedData.page_type = 'modern'
    const baseUrl = 'https://www.finansavisen.no'

    // Key-value data
    $('h2:contains("Bakgrunn")')
      .parent()
      .find('div.font-medium.text-gray-500')
      .each((i, el) => {
        const key = $(el).text().trim().toLowerCase()
        const value = $(el).next('.font-semibold').text().trim()
        if (value) {
          if (key === 'født') scrapedData.date_of_birth = value
          if (key === 'bosted') scrapedData.city = value
          if (key === 'utdannelse') scrapedData.education = value
        }
      })

    // Background text and embedded links
    const backgroundProse = $('h2:contains("Bakgrunn")').parent().find('.prose')
    scrapedData.background_information = cleanText(backgroundProse.text())
    backgroundProse.find('a').each((i, el) => {
      const link = $(el).attr('href')
      if (link) {
        scrapedData.embedded_article_links.push({
          text: cleanText($(el).text()),
          url: new URL(link, baseUrl).href,
        })
      }
    })

    // Wealth summary text
    scrapedData.wealth_summary = cleanText($('div.scrollbar-hide > div > p').text())

    // Business Roles
    $('h2:contains("Roller i norsk næringsliv")')
      .parent()
      .find('h3')
      .each((i, el) => {
        const roleType = cleanText($(el).text())
        $(el)
          .next('ul')
          .find('li a')
          .each((j, linkEl) => {
            scrapedData.roles.push({
              role: roleType,
              company: cleanText($(linkEl).text()),
              url: $(linkEl).attr('href'),
            })
          })
      })

    // Latest News
    $('hegnar-market-news[title="Siste nytt"]')
      .find('div.divide-y > a')
      .each((i, el) => {
        const relativeUrl = $(el).attr('href')
        const headline = cleanText($(el).find('h3').text())
        if (relativeUrl && headline) {
          scrapedData.latest_news.push({
            headline,
            url: new URL(relativeUrl, baseUrl).href,
          })
        }
      })
  }
  // --- Check for "Legacy" Layout ---
  else if ($('.c-kapital-index-profile__main').length > 0) {
    scrapedData.page_type = 'legacy'
    const baseUrl = 'https://www.kapital.no'

    // Key-value data
    $('.c-kapital-index-profile__higlights__item').each((i, el) => {
      const label = $(el).find('.label').text().trim().toLowerCase()
      const value = $(el).find('.value').text().trim()
      if (label === 'født') scrapedData.date_of_birth = value
      if (label === 'bosted') scrapedData.city = value
      if (label === 'utdannelse') scrapedData.education = value
    })

    // Current Wealth Figure
    const wealthText = cleanText(
      $('.c-kapital-index-profile__status:contains("mrd formue")').text()
    )
    if (wealthText) scrapedData.current_wealth = wealthText

    // Background text and embedded links
    const listInfo = cleanText($('.c-kapital-index-profile__list-info').text())
    const bodyInfoEl = $('h4:contains("Bakgrunn")').next('.c-kapital-index-profile__body')
    const bodyInfoText = cleanText(bodyInfoEl.text())
    scrapedData.background_information = [listInfo, bodyInfoText].filter(Boolean).join('\n\n')
    bodyInfoEl.find('a').each((i, el) => {
      const link = $(el).attr('href')
      if (link) {
        scrapedData.embedded_article_links.push({
          text: cleanText($(el).text()),
          url: new URL(link, baseUrl).href,
        })
      }
    })

    // Latest News
    $('.c-kapital-index-profile__articles article.c-teaser').each((i, el) => {
      const linkEl = $(el).find('a.c-teaser__content__title__link')
      const relativeUrl = linkEl.attr('href')
      const headline = cleanText(linkEl.text())
      if (relativeUrl && headline) {
        scrapedData.latest_news.push({
          headline,
          url: new URL(relativeUrl, baseUrl).href,
        })
      }
    })
  } else {
    throw new Error('Could not identify page layout. Neither modern nor legacy structure found.')
  }

  return scrapedData
}

/**
 * The main function to orchestrate the scraping process.
 */
const runScraper = async () => {
  const rl = readline.createInterface({ input, output })
  const data = await loadData()
  const individuals = data.individuals
  const total = individuals.length
  const counts = { processed: 0, skipped: 0, error: 0 }

  console.clear()
  console.log(`${colors.bright}${colors.blue}--- Scraper Initialized ---${colors.reset}`)

  const browser = await puppeteer.launch()
  const page = await browser.newPage()
  await page.setUserAgent(
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'
  )

  let currentIndex = 0
  let isAutopilotMode = false

  try {
    while (currentIndex >= 0 && currentIndex < total) {
      const individual = individuals[currentIndex]
      const progress = `[${currentIndex + 1}/${total}]`
      let choice = ''

      if (isAutopilotMode) {
        if (individual.scraped_data) {
          console.log(
            `${colors.dim}${progress} Skipping ${individual.name} (already scraped).${colors.reset}`
          )
          counts.skipped++
          currentIndex++
          await new Promise((resolve) => setTimeout(resolve, 50))
          continue
        } else {
          console.log(`${progress} Scraping ${individual.name}...`)
          choice = 'p'
        }
      } else {
        const summary = `(Processed: ${colors.green}${counts.processed}${colors.reset}, Skipped: ${colors.yellow}${counts.skipped}${colors.reset}, Errors: ${colors.red}${counts.error}${colors.reset})`
        console.clear()
        console.log(
          `${colors.bright}${progress} Processing: ${individual.name} (Rank: ${individual.rank}) ${summary}${colors.reset}`
        )
        if (individual.scraped_data) {
          console.log(
            `${colors.yellow}Status: Already scraped (page type: ${individual.scraped_data.page_type}).${colors.reset}`
          )
        } else if (individual.scrape_error) {
          console.log(
            `${colors.red}Status: Last attempt failed: ${individual.scrape_error}${colors.reset}`
          )
        }
        console.log(`URL: ${colors.dim}${individual.profile_url}${colors.reset}\n`)
        choice = (
          await rl.question(
            `${colors.cyan}Action: (p)roceed, (r)e-scrape, (s)kip, (b)ack, [rank #], (a)ll, (e)xit -> ${colors.reset}`
          )
        ).toLowerCase()
      }

      const rankJump = parseInt(choice, 10)

      if (choice === 'e') break
      if (choice === 'a') {
        isAutopilotMode = true
        console.log(`\n${colors.bright}${colors.blue}--- Autopilot Mode Activated ---${colors.reset}`)
        await new Promise((resolve) => setTimeout(resolve, 1500))
        continue
      }
      if (!isNaN(rankJump)) {
        const targetIndex = individuals.findIndex((p) => p.rank === rankJump)
        if (targetIndex !== -1) currentIndex = targetIndex
        else {
          console.log(`${colors.red}Rank ${rankJump} not found. Press ENTER.${colors.reset}`)
          await rl.question('')
        }
        continue
      }
      if (choice === 'b') {
        currentIndex = Math.max(0, currentIndex - 1)
        continue
      }
      if (choice === 's' || ((choice === 'p' || choice === '') && individual.scraped_data)) {
        counts.skipped++
        currentIndex++
        continue
      }

      try {
        if (individual.scrape_error) delete individual.scrape_error
        if (!isAutopilotMode) console.log(`${colors.dim}Navigating to page...${colors.reset}`)
        await page.goto(individual.profile_url, { waitUntil: 'networkidle0', timeout: 60000 })
        const html = await page.content()
        const scrapedData = extractProfileData(html)
        individual.scraped_data = scrapedData
        counts.processed++
        const summary = `(Layout: ${scrapedData.page_type}, Roles: ${scrapedData.roles.length}, News: ${scrapedData.latest_news.length}, Embedded Links: ${scrapedData.embedded_article_links.length})`
        console.log(`${isAutopilotMode ? '' : '\n'}${colors.green}SUCCESS: Scraped ${individual.name} ${summary}${colors.reset}`)
      } catch (error) {
        console.error(
          `\n${colors.red}ERROR: Could not process ${individual.name}. Reason: ${error.message}${colors.reset}`
        )
        individual.scrape_error = error.message
        counts.error++
      }

      await saveData(data)
      if (!isAutopilotMode) {
        console.log(`${colors.green}Progress saved to norway.json.${colors.reset}`)
        await rl.question(`${colors.dim}Press ENTER to continue...${colors.reset}`)
      } else {
        await new Promise((resolve) => setTimeout(resolve, AUTOPILOT_DELAY))
      }
      currentIndex++
    }
  } finally {
    await browser.close()
    rl.close()
  }

  console.log(`\n${colors.bright}${colors.blue}--- Scraping Process Finished ---${colors.reset}`)
  console.log(`Successfully processed: ${colors.green}${counts.processed}${colors.reset}`)
  console.log(`Skipped (already done/user): ${colors.yellow}${counts.skipped}${colors.reset}`)
  console.log(`Failed attempts: ${colors.red}${counts.error}${colors.reset}`)
}

runScraper()
```

## 📄 npm
*Lines: 1, Size: 0 Bytes*

```

```

## 📄 package.json
*Lines: 56, Size: 2.53 KB*

```json
{
  "name": "headlines-monorepo",
  "version": "1.2.2",
  "private": true,
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "//--- APP DEVELOPMENT ---//": "---",
    "admin": "node --env-file=./.env ./node_modules/next/dist/bin/next dev apps/admin -p 3000",
    "client": "node --env-file=./.env ./node_modules/next/dist/bin/next dev apps/client -p 3001",
    "//--- PIPELINE EXECUTION ---//": "---",
    "pipeline:test": "npm run pipeline:test -w @headlines/pipeline",
    "//--- DATABASE SEEDING ---//": "---",
    "seed": "npm run db:seed:all -w @headlines/pipeline",
    "seed:admin": "npm run db:seed:admin -w @headlines/pipeline",
    "seed:countries": "npm run db:seed:countries -w @headlines/pipeline",
    "seed:settings": "npm run db:seed:settings -w @headlines/pipeline",
    "//--- DATA MANAGEMENT ---//": "---",
    "maintenance:delete-today": "npm run maintenance:delete-today -w @headlines/pipeline --",
    "results:list-events": "npm run results:list-events -w @headlines/pipeline",
    "results:send-last-events": "npm run results:send-last-events -w @headlines/pipeline --",
    "subscribers:list": "npm run subscribers:list -w @headlines/pipeline",
    "subscribers:update": "npm run subscribers:update -w @headlines/pipeline --",
    "watchlist:list": "npm run watchlist:list -w @headlines/pipeline --",
    "watchlist:add-term": "npm run watchlist:add-term -w @headlines/pipeline --",
    "//--- SOURCE MANAGEMENT ---//": "---",
    "sources:list": "npm run sources:list -w @headlines/pipeline --",
    "sources:scrape-one": "npm run sources:scrape-one -w @headlines/pipeline --",
    "sources:scrape-many": "npm run sources:scrape-many -w @headlines/pipeline --",
    "sources:discover": "npm run sources:discover -w @headlines/pipeline --",
    "sources:optimize": "npm run sources:optimize -w @headlines/pipeline --",
    "sources:maintain": "npm run sources:maintain -w @headlines/pipeline --",
    "sources:update": "npm run sources:update -w @headlines/pipeline --",
    "sources:browse": "npm run sources:browse -w @headlines/pipeline --",
    "//--- MONOREPO UTILITIES ---//": "---",
    "cli": "npm run cli:help -w @headlines/pipeline",
    "build": "npm run build -ws --if-present",
    "lint": "npm run lint -ws --if-present"
  },
  "dependencies": {
    "@upstash/redis": "^1.35.3",
    "moment": "^2.30.1",
    "moment-duration-format": "^2.3.2",
    "nodemailer": "^7.0.6",
    "pino": "^9.9.5",
    "puppeteer": "^24.22.0",
    "yargs": "^18.0.0"
  },
  "devDependencies": {
    "dotenv": "^17.2.2"
  },
  "type": "module"
}

```

## 📄 run.sh
*Lines: 21, Size: 880 Bytes*

```bash
#!/bin/bash
# This script executes the pipeline directly from the monorepo root
# using the npm workspace command for reliability.

# Get the directory of this script to reliably find the monorepo root.
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
# Navigate up two directories from apps/pipeline to the monorepo root
MONOREPO_ROOT="$(dirname "$(dirname "$SCRIPT_DIR")")"

# Change to the monorepo root directory. This is crucial for npm workspaces.
cd "$MONOREPO_ROOT"

echo "Executing pipeline from monorepo root: $(pwd)"
echo "---"

# DEFINITIVE FIX: Execute the pipeline using the npm workspace command.
# This ensures that the correct Node.js version (if managed by nvm/volta)
# and all dependencies are correctly resolved by npm.
# "$@" passes all arguments from this script to the npm command.
npm run pipeline -w @headlines/pipeline -- "$@"

```

## 📄 scripts/infrastructure/setFlySecrets.sh
*Lines: 88, Size: 2.23 KB*

```bash
#!/bin/bash
# scripts/setFlySecrets.sh (version 1.0)

# A script to read a .env file and set the variables as Fly.io secrets.
# It builds a single command to set all secrets at once for efficiency.

# --- Configuration ---
ENV_FILE=".env"

# --- Pre-flight Checks ---

# Check for .env file
if [ ! -f "$ENV_FILE" ]; then
    echo "Error: .env file not found in the current directory."
    exit 1
fi

# Check for flyctl command
if ! command -v fly &> /dev/null
then
    echo "Error: 'fly' command-line tool not found."
    exit 1
fi

if [ ! -f "fly.toml" ]; then
    echo "Error: No fly.toml file found in this directory."
    echo "Please run 'fly launch' first."
    exit 1
fi

APP_NAME=$(grep '^app = ' fly.toml | cut -d "'" -f 2)
if [ -z "$APP_NAME" ]; then
    echo "Error: Could not determine app name from fly.toml."
    exit 1
fi

echo "Reading secrets from '$ENV_FILE' for app '$APP_NAME'..."

# --- Main Logic ---
secrets_args=()
while IFS= read -r line || [ -n "$line" ]; do
    # Skip comments and empty lines
    if [[ "$line" =~ ^#.* ]] || [[ -z "$line" ]]; then
        continue
    fi
    # Handle carriage return for Windows-edited .env files
    line=$(echo "$line" | tr -d '\r')
    key=$(echo "$line" | cut -d '=' -f 1)
    # Correctly extract value, even if it contains '='
    value=$(echo "$line" | sed -e "s/^$key=//")
    if [ -z "$key" ]; then
        continue
    fi
    # Use printf for robust quoting to handle special characters
    secrets_args+=("$(printf "%s=%s" "$key" "$value")")
    echo "  - Found secret: $key"
done < "$ENV_FILE"

if [ ${#secrets_args[@]} -eq 0 ]; then
    echo "No secrets to set were found in '$ENV_FILE'."
    exit 0
fi

echo ""
echo "The following secrets will be set for the app '$APP_NAME':"
for arg in "${secrets_args[@]}"; do
    key=$(echo "$arg" | cut -d '=' -f 1)
    echo "  - $key"
done
echo ""

read -p "Are you sure you want to proceed? (y/N) " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]
then
    echo "Operation cancelled by user."
    exit 1
fi

echo "Setting secrets on Fly.io..."
fly secrets set --stage "${secrets_args[@]}"

if [ $? -eq 0 ]; then
    echo "✅ Successfully set ${#secrets_args[@]} secrets. A new release is being created."
else
    echo "❌ An error occurred while setting secrets."
    exit 1
fi
```

## 📄 scripts/maintenance/backfill-event-classifications.js
*Lines: 130, Size: 4.84 KB*

```javascript
// apps/pipeline/scripts/maintenance/backfill-event-classifications.js
'use server'

import mongoose from 'mongoose'
import { SynthesizedEvent } from '../../../../packages/models/src/index.js'
import { initializeScriptEnv } from '../seed/lib/script-init.js'
import { logger } from '../../../../packages/utils/src/server.js'
import { callLanguageModel } from '../../../../packages/ai-services/src/index.js'
import colors from 'ansi-colors'
import cliProgress from 'cli-progress'
import pLimit from 'p-limit'

// Concurrency limit to avoid overwhelming the AI API
const CONCURRENCY_LIMIT = 5

const getClassificationPrompt =
  () => `You are a sharp, succinct financial analyst. Your sole task is to classify a synthesized news event into one of the predefined categories based on its headline and summary.

**Categories & Definitions:**
- **"New Wealth"**: A direct, confirmed liquidity event (e.g., company sale, M&A, exit).
- **"Future Wealth"**: A high-probability future liquidity event (e.g., confirmed IPO plans, seeking a buyer).
- **"Wealth Mentioned"**: A profile of existing significant wealth (e.g., "Rich List" feature, an article detailing a family's large fortune).
- **"Legal/Dispute"**: A significant legal or financial dispute involving a high-net-worth entity.
- **"Background"**: Important contextual information (e.g., philanthropic donation, succession changes, major personal investments).
- **"Other"**: Any relevant event that does not fit the above categories.

You will be given the event's headline and summary. You MUST respond ONLY with a valid JSON object with a single key "classification".

Example Input:
"Headline: EQT acquires Swedish AI firm Sana for $1.1 billion
Summary: The acquisition delivers a major liquidity event to the founders of Sana..."

Example JSON Response:
{ "classification": "New Wealth" }`

async function main() {
  await initializeScriptEnv()
  const startTime = Date.now()
  logger.info('🚀 Starting backfill of `eventClassification` for past events...')

  try {
    const eventsToUpdate = await SynthesizedEvent.find({
      eventClassification: { $exists: false },
    })
      .select('_id synthesized_headline synthesized_summary')
      .lean()

    if (eventsToUpdate.length === 0) {
      logger.info(
        '✅ No events found that need classification. All items are up to date.'
      )
      return
    }

    logger.info(
      `Found ${eventsToUpdate.length} events to classify. Processing in parallel (limit: ${CONCURRENCY_LIMIT})...`
    )
    const progressBar = new cliProgress.SingleBar({
      format: `Classifying | ${colors.cyan('{bar}')} | {percentage}% || {value}/{total} Events`,
      barCompleteChar: '\u2588',
      barIncompleteChar: '\u2591',
      hideCursor: true,
    })
    progressBar.start(eventsToUpdate.length, 0)

    const limit = pLimit(CONCURRENCY_LIMIT)
    const bulkOps = []

    const processingPromises = eventsToUpdate.map((event) =>
      limit(async () => {
        try {
          const userContent = `Headline: ${event.synthesized_headline}\nSummary: ${event.synthesized_summary}`
          const result = await callLanguageModel({
            modelName: process.env.LLM_MODEL_UTILITY || 'gpt-5-nano',
            systemPrompt: getClassificationPrompt(),
            userContent,
            isJson: true,
          })

          if (result && !result.error && result.classification) {
            bulkOps.push({
              updateOne: {
                filter: { _id: event._id },
                update: { $set: { eventClassification: result.classification } },
              },
            })
            logger.trace(
              `Classification for "${event.synthesized_headline.substring(0, 50)}...": ${result.classification}`
            )
          } else {
            logger.warn(`Failed to get a valid classification for event ID ${event._id}.`)
          }
        } catch (error) {
          logger.error({ err: error }, `Error processing event ID ${event._id}`)
        } finally {
          progressBar.increment()
        }
      })
    )

    await Promise.all(processingPromises)
    progressBar.stop()

    if (bulkOps.length > 0) {
      logger.info(
        `Applying ${bulkOps.length} updates to the database in a single bulk operation...`
      )
      const updateResult = await SynthesizedEvent.bulkWrite(bulkOps)
      const duration = ((Date.now() - startTime) / 1000).toFixed(2)
      logger.info(
        colors.green(
          `✅ Backfill complete in ${duration}s. Successfully updated ${updateResult.modifiedCount} events.`
        )
      )
    } else {
      logger.warn(
        'Backfill process finished, but no successful classifications were generated.'
      )
    }
  } catch (error) {
    logger.error({ err: error }, 'A critical error occurred during the backfill process.')
  } finally {
    if (mongoose.connection.readyState === 1) {
      await mongoose.disconnect()
    }
  }
}

main()

```

## 📄 scripts/maintenance/backfill-suggestion-terms.js
*Lines: 107, Size: 4.82 KB*

```javascript
// apps/pipeline/scripts/maintenance/backfill-suggestion-terms.js
'use server'

import mongoose from 'mongoose';
import { WatchlistSuggestion } from '../../../../packages/models/src/index.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import { initializeScriptEnv } from '../seed/lib/script-init.js';
import { logger } from '../../../../packages/utils/src/server.js';
import { callLanguageModel } from '../../../../packages/ai-services/src/index.js';
import colors from 'ansi-colors';
import cliProgress from 'cli-progress';
import pLimit from 'p-limit';

const CONCURRENCY_LIMIT = 5;

const getSearchTermPrompt = () => `
You are a search query generation expert for a financial intelligence firm. Your task is to analyze an entity's name, type, and context to generate a list of likely search terms (or "crums") that would identify this entity in news headlines.
**CRITICAL Instructions:**
1.  Analyze the Input: You will receive the entity's formal name, its type (person, family, company), and a brief rationale.
2.  Generate Aliases and Keywords: Think of common abbreviations, alternative spellings, key individuals, or related company names.
3.  Return a List: Your output MUST be an array of 2-4 lowercase strings.
4.  Simplicity is Key: The terms should be simple and likely to appear in text. Good examples: 'haugland', 'syversen', 'nordic capital'. Bad examples: 'the', 'capital', 'family'.
5.  Your response MUST be a valid JSON object with the following structure: { "searchTerms": ["term1", "term2"] }
`;

async function main() {
    await initializeScriptEnv();
    logger.info('🚀 Starting one-off backfill of search terms for watchlist suggestions...');

    try {
        const suggestionsToUpdate = await WatchlistSuggestion.find({
            status: 'candidate',
            $or: [
                { searchTerms: { $exists: false } },
                { searchTerms: { $size: 0 } }
            ]
        }).lean();

        if (suggestionsToUpdate.length === 0) {
            logger.info('✅ No suggestions found that need backfilling. All items are up to date.');
            return;
        }

        logger.info(`Found ${suggestionsToUpdate.length} suggestions to update. Processing in parallel...`);
        const progressBar = new cliProgress.SingleBar({
            format: `Backfilling | ${colors.cyan('{bar}')} | {percentage}% || {value}/{total} Suggestions`,
            barCompleteChar: '\u2588',
            barIncompleteChar: '\u2591',
            hideCursor: true,
        });
        progressBar.start(suggestionsToUpdate.length, 0);

        const limit = pLimit(CONCURRENCY_LIMIT);
        const bulkOps = [];

        const processingPromises = suggestionsToUpdate.map(suggestion => 
            limit(async () => {
                try {
                    const userContent = `Entity Name: ${suggestion.name}\nEntity Type: ${suggestion.type}\nRationale: ${suggestion.rationale}`;
                    const result = await callLanguageModel({
                        modelName: process.env.LLM_MODEL_UTILITY || 'gpt-5-nano',
                        systemPrompt: getSearchTermPrompt(),
                        userContent,
                        isJson: true
                    });
                    
                    if (result && !result.error && result.searchTerms) {
                        bulkOps.push({
                            updateOne: {
                                filter: { _id: suggestion._id },
                                update: { $set: { searchTerms: result.searchTerms } }
                            }
                        });
                        logger.trace(`Generated terms for "${suggestion.name}": ${result.searchTerms.join(', ')}`);
                    } else {
                        logger.warn(`Failed to generate terms for "${suggestion.name}".`);
                    }
                } catch (error) {
                     logger.error({ err: error }, `Error processing suggestion ${suggestion.name}`);
                } finally {
                    progressBar.increment();
                }
            })
        );

        await Promise.all(processingPromises);
        progressBar.stop();
        
        if (bulkOps.length > 0) {
            logger.info(`Applying ${bulkOps.length} updates to the database...`);
            const updateResult = await WatchlistSuggestion.bulkWrite(bulkOps);
            logger.info(colors.green(`✅ Backfill complete. Successfully updated ${updateResult.modifiedCount} suggestions.`));
        } else {
            logger.warn('Backfill process finished, but no successful updates were generated.');
        }

    } catch (error) {
        logger.error({ err: error }, 'A critical error occurred during the backfill process.');
    } finally {
        if (mongoose.connection.readyState === 1) {
            await mongoose.disconnect();
        }
    }
}

main();

```

## 📄 scripts/maintenance/clean-e24-headlines.js
*Lines: 57, Size: 2 KB*

```javascript
// apps/pipeline/scripts/maintenance/clean-e24-headlines.js
'use server'

import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import { Article } from '../../../../packages/models/src/index.js';
import { logger, reinitializeLogger } from '../../../../packages/utils/src/server.js';
import path from 'path';
import mongoose from 'mongoose';

reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'));

async function cleanE24Headlines() {
    await dbConnect();
    logger.info("🚀 Starting E24 headline cleanup...");

    try {
        // This regex is more robust and captures multiple patterns of CSS gibberish.
        const articlesToClean = await Article.find({
            newspaper: 'E24',
            headline: { $regex: /(#title-.*)|(span \{ font-weight)/ }
        });

        if (articlesToClean.length === 0) {
            logger.info("✅ No E24 articles with CSS gibberish found. Database is clean.");
            return;
        }

        logger.info(`Found ${articlesToClean.length} E24 articles to clean. Preparing bulk update...`);

        const bulkOps = articlesToClean.map(article => {
            // Use a more robust regex to remove the CSS part.
            const cleanedHeadline = article.headline
                .replace(/#title-.*?span \{.*?\}/g, '') // Removes the entire CSS block
                .replace(/#title-.*/, '') // Fallback for simpler cases
                .trim();
            return {
                updateOne: {
                    filter: { _id: article._id },
                    update: { $set: { headline: cleanedHeadline } }
                }
            };
        });

        const result = await Article.bulkWrite(bulkOps);
        logger.info(`✅ Cleanup complete. Modified ${result.modifiedCount} articles.`);

    } catch (error) {
        logger.error({ err: error }, '❌ E24 headline cleanup failed.');
    } finally {
        if (mongoose.connection.readyState === 1) {
            await mongoose.disconnect();
        }
    }
}

cleanE24Headlines();

```

## 📄 scripts/maintenance/delete-today.js
*Lines: 62, Size: 2.2 KB*

```javascript
// apps/pipeline/scripts/maintenance/delete-today.js (version 2.2.0)
undefined
import { logger } from '../../../../packages/utils/src/server.js';
import mongoose from 'mongoose';
import { Article, SynthesizedEvent, Opportunity, RunVerdict } from '../../../../packages/models/src/index.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';

export async function deleteTodaysDocuments(confirm = false) {
  try {
    const today = new Date();
    today.setUTCHours(0, 0, 0, 0);
    const query = { createdAt: { $gte: today } };
    const modelsToDelete = { Articles: Article, 'Synthesized Events': SynthesizedEvent, Opportunities: Opportunity, 'Run Verdicts': RunVerdict };
    let totalCount = 0;
    
    // [[ Log All Deleted Documents ]] - First, count documents for each model
    const counts = {};
    for (const [modelName, model] of Object.entries(modelsToDelete)) {
      const count = await model.countDocuments(query);
      if (count > 0) {
        counts[modelName] = count;
        totalCount += count;
      }
    }

    if (totalCount === 0) {
      logger.info('✅ No documents created today were found to delete.');
      return;
    }
    
    if (!confirm) {
      logger.warn(`${totalCount} documents found from today. Run with --delete-today or --yes to delete.`);
      return;
    }

    logger.info(`Deleting ${totalCount} documents from today...`);
    for (const [modelName, model] of Object.entries(modelsToDelete)) {
        if (counts[modelName] > 0) {
             const { deletedCount } = await model.deleteMany(query);
             logger.info(`  ✅ Deleted ${deletedCount} ${modelName}.`);
        }
    }
  } catch (error) {
    logger.error({ err: error }, 'Deletion failed.');
    throw error;
  }
}

// Allow script to be run standalone
if (import.meta.url.endsWith(process.argv[1])) {
  (async () => {
    const { initializeLogger } = await import('@headlines/utils');
    const path = await import('path');
    initializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'));
    
    await dbConnect();
    const confirm = process.argv.includes('--yes');
    await deleteTodaysDocuments(confirm);
    if (mongoose.connection.readyState === 1) await mongoose.disconnect();
  })();
}

```

## 📄 scripts/maintenance/pipeline-correct-countries.js
*Lines: 82, Size: 3.11 KB*

```javascript
// apps/pipeline/scripts/maintenance/pipeline-correct-countries.js (version 1.0)
'use server'

import mongoose from 'mongoose';
import { Opportunity } from '../../../../packages/models/src/index.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import { logger, reinitializeLogger } from '../../../../packages/utils/src/server.js';
import { countryCorrectionChain } from '../../../../packages/ai-services/src/index.js';
import { initializeScriptEnv } from '../seed/lib/script-init.js';
import colors from 'ansi-colors';
import cliProgress from 'cli-progress';
import path from 'path';

reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'));

async function main() {
  await initializeScriptEnv();
  logger.info('🚀 Starting Retrospective Country Data Cleanup (Efficient Mode)...');

  try {
    const allBasedInValues = await Opportunity.distinct('basedIn');
    
    if (allBasedInValues.length === 0) {
        logger.info('✅ No opportunities with country data found to scan.');
        return;
    }
    
    // Filter down to only values that look incorrect, to save on AI calls
    const invalidValues = allBasedInValues.filter(v => v && (v.includes('(') || v.includes('/') || v.length > 30 || !/^[a-zA-Z\s]+$/.test(v) ));

    if (invalidValues.length === 0) {
        logger.info('✅ No invalid-looking country names found. Data appears clean.');
        return;
    }

    logger.info(`Found ${invalidValues.length} unique potentially invalid 'basedIn' values to correct...`);
    
    const bulkOps = [];
    const progressBar = new cliProgress.SingleBar({
        format: `Correcting | ${colors.cyan('{bar}')} | {percentage}% || {value}/{total} Unique Locations`,
        barCompleteChar: '\u2588',
        barIncompleteChar: '\u2591',
        hideCursor: true,
    });
    progressBar.start(invalidValues.length, 0);

    for (const originalCountry of invalidValues) {
        // DEFINITIVE FIX: Call the chain as an async function.
        const result = await countryCorrectionChain({ location_string: originalCountry });

        if (result && !result.error && result.country && result.country !== originalCountry) {
            logger.info(`Correction found: "${originalCountry}" -> "${result.country}"`);
            bulkOps.push({
                updateMany: {
                    filter: { basedIn: originalCountry },
                    update: { $set: { basedIn: result.country } }
                }
            });
        }
        progressBar.increment();
    }
    progressBar.stop();

    if (bulkOps.length > 0) {
        logger.info(`Found ${bulkOps.length} unique corrections to apply. Applying bulk update...`);
        const result = await Opportunity.bulkWrite(bulkOps);
        logger.info(colors.green(`✅ Cleanup complete. Modified ${result.modifiedCount} opportunity documents.`));
    } else {
        logger.info('✅ No country corrections were needed.');
    }

  } catch (error) {
    logger.error({ err: error }, 'An error occurred during the country cleanup process.');
  } finally {
    if (mongoose.connection.readyState === 1){
        await mongoose.disconnect();
    }
  }
}

main();

```

## 📄 scripts/maintenance/recalculate-analytics.js
*Lines: 74, Size: 3.04 KB*

```javascript
// apps/pipeline/scripts/maintenance/recalculate-analytics.js (version 1.0.0)
import mongoose from 'mongoose';
import { Source } from '../../../../packages/models/src/index.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import { reinitializeLogger, logger } from '../../../../packages/utils/src/server.js';
import path from 'path';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';

reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'));

async function recalculateAnalytics() {
    const argv = yargs(hideBin(process.argv))
        .option('yes', { type: 'boolean', description: 'Skip confirmation prompt.' })
        .help().argv;
        
    logger.info('🚀 Starting Source Analytics Recalculation...');
    await dbConnect();

    try {
        const sources = await Source.find({}).select('analytics').lean();
        if (sources.length === 0) {
            logger.info('No sources found. Nothing to do.');
            return;
        }

        const bulkOps = sources.map(source => {
            const totalRelevant = source.analytics?.totalRelevant || 0;
            return {
                updateOne: {
                    filter: { _id: source._id },
                    update: {
                        $set: {
                            'analytics.totalRuns': 0,
                            'analytics.totalSuccesses': 0,
                            'analytics.totalFailures': 0,
                            // Set totalScraped to be at least the number of relevant articles.
                            'analytics.totalScraped': Math.max(0, totalRelevant),
                        }
                    }
                }
            };
        });

        logger.warn(`This script will perform the following actions on ${sources.length} sources:`);
        logger.warn(`  1. Correct 'totalScraped' to equal 'totalRelevant' (ensuring no negative relevance %).`);
        logger.warn(`  2. Reset 'totalRuns', 'totalSuccesses', and 'totalFailures' to 0.`);
        logger.warn('This will provide a clean slate for the new, more accurate analytics collection.');
        
        if (!argv.yes) {
            const readline = require('readline').createInterface({ input: process.stdin, output: process.stdout });
            const answer = await new Promise(resolve => readline.question('Are you sure you want to proceed? (yes/no): ', resolve));
            readline.close();
            if (answer.toLowerCase() !== 'yes') {
                logger.info('Operation cancelled by user.');
                return;
            }
        }
        
        logger.info('Applying bulk update to the database...');
        const result = await Source.bulkWrite(bulkOps);
        logger.info(`✅ Analytics reset complete. Modified ${result.modifiedCount} source documents.`);

    } catch (error) {
        logger.fatal({ err: error }, '❌ Failed to recalculate source analytics.');
    } finally {
        if (mongoose.connection.readyState === 1) {
            await mongoose.disconnect();
        }
    }
}

recalculateAnalytics();

```

## 📄 scripts/maintenance/reset-source-analytics.js
*Lines: 37, Size: 1.1 KB*

```javascript
// scripts/database/maintenance/reset-source-analytics.js (version 1.0)
import 'dotenv/config'
import { connectDatabase, disconnectDatabase } from '../../../src/database.js'
import Source from '../../../models/Source.js'
import { logger } from '@headlines/utils/src/logger.js'

async function resetAnalytics() {
  await connectDatabase()
  logger.info('🚀 Resetting all source analytics data...')
  try {
    const result = await Source.updateMany(
      {},
      {
        $set: {
          'analytics.totalRuns': 0,
          'analytics.totalSuccesses': 0,
          'analytics.totalFailures': 0,
          'analytics.totalScraped': 0,
          'analytics.totalRelevant': 0,
          'analytics.lastRunHeadlineCount': 0,
          'analytics.lastRunRelevantCount': 0,
          'analytics.lastRunContentSuccess': false,
        },
      }
    )
    logger.info(
      `✅ Analytics reset complete. Modified ${result.modifiedCount} source documents.`
    )
  } catch (error) {
    logger.fatal({ err: error }, '❌ Failed to reset source analytics.')
  } finally {
    await disconnectDatabase()
  }
}

resetAnalytics()

```

## 📄 scripts/migrations/V1_Fix_Scraper_Selectors.js
*Lines: 115, Size: 2.88 KB*

```javascript
// scripts/migrations/V1_Fix_Scraper_Selectors.js (version 1.0)
import 'dotenv/config'
import { connectDatabase, disconnectDatabase } from '../../src/database.js'
import Source from '../../models/Source.js'
import { logger } from '@headlines/utils/src/logger.js'

const MIGRATION_NAME = 'V1_Fix_Scraper_Selectors'

const UPDATES = [
  // Fix Content Scraper Failures
  {
    name: 'Økonomisk Ugebrev',
    update: { articleSelector: 'div.elementor-widget-theme-post-content' },
  },
  { name: 'NRK', update: { articleSelector: 'div.article-body' } },
  {
    name: 'Dagens Næringsliv',
    update: { articleSelector: 'div[class*="content"] p, .dn-article-body' },
  },

  // Fix Headline Scraper Failures for PE Firms by switching to the enhanced dynamic extractor
  {
    name: 'Maj Invest',
    update: {
      extractionMethod: 'declarative',
      headlineSelector: 'div.news-item',
      linkSelector: 'a',
      headlineTextSelector: 'h3',
    },
  },
  {
    name: 'PAI Partners',
    update: {
      extractionMethod: 'declarative',
      headlineSelector: 'a.news-list__item',
      linkSelector: null, // Link is on the main element
      headlineTextSelector: 'h3',
    },
  },
  {
    name: 'IK Partners',
    update: {
      extractionMethod: 'declarative',
      headlineSelector: 'a.news-card',
      linkSelector: null,
      headlineTextSelector: 'h4',
    },
  },
  {
    name: 'Triton Partners',
    update: {
      extractionMethod: 'declarative',
      headlineSelector: 'div.news-card',
      linkSelector: 'a',
      headlineTextSelector: 'h3.news-card__title',
    },
  },
  {
    name: 'Hg Capital',
    update: {
      extractionMethod: 'declarative',
      headlineSelector: 'div.insights-card__content',
      linkSelector: 'a',
      headlineTextSelector: 'h3',
    },
  },
  {
    name: 'CVC Capital Partners',
    update: {
      extractionMethod: 'declarative',
      headlineSelector: 'a.news-listing-item__container',
      linkSelector: null,
      headlineTextSelector: 'h2',
    },
  },
  {
    name: 'Mergermarket',
    update: {
      extractionMethod: 'declarative',
      headlineSelector: 'div.teasers > a',
      linkSelector: null,
      headlineTextSelector: 'div.title',
    },
  },
]

async function runMigration() {
  logger.info(`🚀 Starting migration: ${MIGRATION_NAME}...`)
  await connectDatabase()

  try {
    const bulkOps = UPDATES.map(({ name, update }) => ({
      updateOne: {
        filter: { name },
        update: { $set: update },
      },
    }))

    if (bulkOps.length > 0) {
      const result = await Source.bulkWrite(bulkOps)
      logger.info(
        `Migration complete. Matched: ${result.matchedCount}, Modified: ${result.modifiedCount}.`
      )
    } else {
      logger.info('No updates to perform.')
    }
  } catch (error) {
    logger.fatal({ err: error }, `❌ Migration ${MIGRATION_NAME} failed!`)
  } finally {
    await disconnectDatabase()
  }
}

runMigration()

```

## 📄 scripts/migrations/V2_Clean_Opportunity_Reasons.js
*Lines: 60, Size: 2.27 KB*

```javascript
// apps/pipeline/scripts/migrations/V2_Clean_Opportunity_Reasons.js (version 1.1.0)
import mongoose from 'mongoose';
import { Opportunity } from '../../../../packages/models/src/index.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import { reinitializeLogger, logger } from '../../../../packages/utils/src/server.js';
import path from 'path';

reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'));

async function cleanOpportunityReasons() {
    logger.info('🚀 Starting V2 Migration: Clean Opportunity `whyContact` field...');
    await dbConnect();

    try {
        // Find documents where whyContact is a string OR is an array containing strings with the date pattern.
        const opportunitiesToMigrate = await Opportunity.find({ 
            $or: [
                { whyContact: { $type: 'string' } },
                { whyContact: { $regex: /\(as of.*\)$/ } }
            ]
        });
        
        if (opportunitiesToMigrate.length === 0) {
            logger.info('✅ No documents need migration. Schema is up to date.');
            return;
        }

        logger.info(`Found ${opportunitiesToMigrate.length} opportunities to migrate...`);
        const bulkOps = [];
        for (const opp of opportunitiesToMigrate) {
            let reasons = Array.isArray(opp.whyContact) ? opp.whyContact : [opp.whyContact];
            
            // Clean each reason in the array
            const cleanedReasons = reasons
                .filter(r => typeof r === 'string') // Ensure we only process strings
                .map(r => r.replace(/\s\(as of.*\)$/, ''));

            bulkOps.push({
                updateOne: {
                    filter: { _id: opp._id },
                    update: { $set: { whyContact: cleanedReasons } } // Set the cleaned array
                }
            });
        }

        if (bulkOps.length > 0) {
            const result = await Opportunity.bulkWrite(bulkOps);
            logger.info(`✅ Migration successful. Modified ${result.modifiedCount} documents.`);
        }
    } catch (error) {
        logger.fatal({ err: error }, '❌ Migration V2 failed!');
    } finally {
        if (mongoose.connection.readyState === 1) {
            await mongoose.disconnect();
        }
    }
}

cleanOpportunityReasons();

```

## 📄 scripts/migrations/V3_Fix_E24_Scraper.js
*Lines: 40, Size: 1.33 KB*

```javascript
// apps/pipeline/scripts/migrations/V3_Fix_E24_Scraper.js
'use server'

import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import { Source } from '../../../../packages/models/src/index.js';
import { logger, reinitializeLogger } from '../../../../packages/utils/src/server.js';
import path from 'path';

reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'));

async function runMigration() {
    await dbConnect();
    logger.info("🚀 Running migration V3: Fix E24 Scraper Selector...");

    try {
        const sourceToUpdate = await Source.findOne({ name: 'E24' });

        if (!sourceToUpdate) {
            logger.warn("Source 'E24' not found. Skipping migration.");
            return;
        }

        // The old selector was too broad and picked up style tags.
        // This new selector specifically targets the headline text within the link.
        const newHeadlineTextSelector = 'h3[class^="css-"]';
        
        sourceToUpdate.headlineTextSelector = newHeadlineTextSelector;
        await sourceToUpdate.save();

        logger.info("✅ Successfully updated 'E24' source with new headlineTextSelector:", newHeadlineTextSelector);

    } catch (error) {
        logger.error({ err: error }, '❌ Migration V3 failed.');
    } finally {
        await mongoose.disconnect();
    }
}

runMigration();

```

## 📄 scripts/migrations/V4_Fix_E24_Scraper_Definitive.js
*Lines: 45, Size: 1.39 KB*

```javascript
// apps/pipeline/scripts/migrations/V4_Fix_E24_Scraper_Definitive.js
'use server'

import dbConnect from '../../../../packages/data-access/src/dbConnect.js'
import { Source } from '../../../../packages/models/src/index.js'
import { logger, reinitializeLogger } from '../../../../packages/utils/src/server.js'
import path from 'path'
import mongoose from 'mongoose'

reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'))

async function runMigration() {
  await dbConnect()
  logger.info('🚀 Running migration V4: Definitive Fix for E24 Scraper Selector...')

  try {
    const sourceToUpdate = await Source.findOne({ name: 'E24' })

    if (!sourceToUpdate) {
      logger.warn("Source 'E24' not found. Skipping migration.")
      return
    }

    // DEFINITIVE FIX: This selector targets the specific span inside the h3,
    // which contains the headline text, explicitly excluding the style information.
    const newHeadlineTextSelector = 'h3[id^="title-"] > span'

    sourceToUpdate.headlineTextSelector = newHeadlineTextSelector
    await sourceToUpdate.save()

    logger.info(
      "✅ Successfully updated 'E24' source with new headlineTextSelector:",
      newHeadlineTextSelector
    )
  } catch (error) {
    logger.error({ err: error }, '❌ Migration V4 failed.')
  } finally {
    if (mongoose.connection.readyState === 1) {
      await mongoose.disconnect()
    }
  }
}

runMigration()

```

## 📄 scripts/mongo-backup.sh
*Lines: 56, Size: 1.31 KB*

```bash
#!/bin/bash
# mongo-backup.sh (version 1.0)
# This script dumps all relevant collections to a timestamped directory.

# --- Configuration ---
BACKUP_DIR="apps/pipeline/backup"
TIMESTAMP=$(date +"%Y-%m-%dT%H-%M-%S")
TARGET_DIR="$BACKUP_DIR/$TIMESTAMP"

# Load MONGO_URI from the root .env file
if [ -f "./.env" ]; then
    export $(grep -v '^#' .env | xargs)
else
    echo "❌ Error: .env file not found in the monorepo root."
    exit 1
fi

if [ -z "$MONGO_URI" ]; then
    echo "❌ Error: MONGO_URI is not set in your .env file."
    exit 1
fi

# --- Main Logic ---
echo "🚀 Starting MongoDB backup..."
echo "Target directory: $TARGET_DIR"

mkdir -p "$TARGET_DIR"

# List of collections to back up
COLLECTIONS=(
    "articles"
    "countries"
    "opportunities"
    "push_subscriptions"
    "run_verdicts"
    "settings"
    "sources"
    "source_suggestions"
    "subscribers"
    "synthesized_events"
    "watchlist_entities"
    "watchlist_suggestions"
)

for collection in "${COLLECTIONS[@]}"; do
    echo "  -> Backing up collection: $collection..."
    mongodump --uri="$MONGO_URI" --collection="$collection" --out="$TARGET_DIR" --gzip
    if [ $? -ne 0 ]; then
        echo "❌ Error backing up collection $collection. Aborting."
        exit 1
    fi
done

echo "✅ Backup complete. All collections saved to $TARGET_DIR"
exit 0

```

## 📄 scripts/mongo-restore.sh
*Lines: 61, Size: 1.53 KB*

```bash
#!/bin/bash
# mongo-restore.sh (version 1.0)
# This script restores all collections from a specified backup directory.

# --- Configuration ---
BACKUP_DIR="apps/pipeline/backup"

# Load MONGO_URI from the root .env file
if [ -f "./.env" ]; then
    export $(grep -v '^#' .env | xargs)
else
    echo "❌ Error: .env file not found in the monorepo root."
    exit 1
fi

if [ -z "$MONGO_URI" ]; then
    echo "❌ Error: MONGO_URI is not set in your .env file."
    exit 1
fi

# --- Main Logic ---
echo "🚀 Starting MongoDB restore..."

# Find the latest backup directory if none is specified
if [ -z "$1" ]; then
    LATEST_BACKUP=$(ls -td $BACKUP_DIR/*/ | head -1)
    if [ -z "$LATEST_BACKUP" ]; then
        echo "❌ No backup directories found in $BACKUP_DIR."
        exit 1
    fi
    echo "No directory specified. Using latest backup: $LATEST_BACKUP"
    SOURCE_DIR=$LATEST_BACKUP
else
    SOURCE_DIR="$BACKUP_DIR/$1"
fi

if [ ! -d "$SOURCE_DIR" ]; then
    echo "❌ Backup directory not found: $SOURCE_DIR"
    exit 1
fi

echo "⚠️ This will overwrite data in the target database."
read -p "Are you sure you want to restore from $SOURCE_DIR? (y/N) " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Restore cancelled by user."
    exit 1
fi

echo "Restoring from $SOURCE_DIR..."
# Use --drop to ensure a clean restore of each collection
mongorestore --uri="$MONGO_URI" --dir="$SOURCE_DIR" --drop --gzip

if [ $? -eq 0 ]; then
    echo "✅ Restore complete."
else
    echo "❌ An error occurred during the restore process."
    exit 1
fi
exit 0

```

## 📄 scripts/purge-opportunities.js
*Lines: 47, Size: 1.39 KB*

```javascript
// scripts/purge-opportunities.js (version 1.0)
import 'dotenv/config'
import { connectDatabase, disconnectDatabase } from '../src/database.js'
import Opportunity from '../models/Opportunity.js'

const WEALTH_THRESHOLD = 20 // in millions USD

async function purgeLowValueOpportunities() {
  console.log('Connecting to database to purge low-value opportunities...')
  await connectDatabase()

  try {
    const filter = {
      $or: [
        { likelyMMDollarWealth: { $lt: WEALTH_THRESHOLD } },
        { likelyMMDollarWealth: { $exists: false } },
        { likelyMMDollarWealth: null },
      ],
    }

    console.log(
      `Searching for opportunities with less than $${WEALTH_THRESHOLD}M in estimated wealth or no wealth amount specified...`
    )

    const count = await Opportunity.countDocuments(filter)

    if (count === 0) {
      console.log('✅ No low-value opportunities found to purge. Database is clean.')
      return
    }

    console.log(`Found ${count} opportunities to purge. Proceeding with deletion...`)

    const result = await Opportunity.deleteMany(filter)

    console.log(`✅ Successfully purged ${result.deletedCount} low-value opportunities.`)
  } catch (error) {
    console.error('❌ An error occurred during the purge process:')
    console.error(error)
  } finally {
    await disconnectDatabase()
    console.log('Database connection closed.')
  }
}

purgeLowValueOpportunities()

```

## 📄 scripts/push/send-test-push.js
*Lines: 86, Size: 3.16 KB*

```javascript
// scripts/send-test-push.js (version 1.0)
/**
 * A utility script to send a test push notification to all subscribed users.
 * This is useful for debugging the push notification flow end-to-end.
 *
 * Usage:
 * 1. Ensure your .env file is populated with the correct VAPID keys and MONGO_URI.
 * 2. Run the script from the root of your backend project: `node scripts/send-test-push.js`
 */

import 'dotenv/config';
import webpush from 'web-push';
import mongoose from 'mongoose';
import PushSubscription from '../../models/PushSubscription.js';
import { logger } from '@headlines/utils/src/logger.js';

const { VAPID_SUBJECT, VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY, MONGO_URI } = process.env;

async function run() {
    // --- 1. Validate Configuration ---
    if (!VAPID_PUBLIC_KEY || !VAPID_PRIVATE_KEY || !VAPID_SUBJECT || !MONGO_URI) {
        logger.fatal('Missing required environment variables (VAPID keys and MONGO_URI). Aborting.');
        process.exit(1);
    }
    logger.info('VAPID and MongoDB configuration found.');

    webpush.setVapidDetails(
        VAPID_SUBJECT,
        VAPID_PUBLIC_KEY,
        VAPID_PRIVATE_KEY
    );

    // --- 2. Connect to Database ---
    try {
        await mongoose.connect(MONGO_URI);
        logger.info('✅ Successfully connected to MongoDB.');
    } catch (error) {
        logger.fatal({ err: error }, '❌ Failed to connect to MongoDB. Aborting.');
        process.exit(1);
    }

    // --- 3. Fetch Subscriptions ---
    const subscriptions = await PushSubscription.find().lean();
    if (subscriptions.length === 0) {
        logger.warn('No push subscriptions found in the database. Nothing to do.');
        await mongoose.disconnect();
        process.exit(0);
    }
    logger.info(`Found ${subscriptions.length} subscription(s) to notify.`);

    // --- 4. Prepare and Send Notifications ---
    const notificationPayload = JSON.stringify({
        title: 'Push Notification Test',
        body: `This is a test message sent at ${new Date().toLocaleTimeString('en-US')}.`,
        url: '/',
        icon: '/icons/icon-192x192.png',
    });

    const promises = subscriptions.map(subscription =>
        webpush.sendNotification(subscription, notificationPayload)
            .then(() => {
                logger.info(`✅ Successfully sent notification to endpoint: ...${subscription.endpoint.slice(-20)}`);
            })
            .catch(error => {
                if (error.statusCode === 410 || error.statusCode === 404) {
                    logger.warn(`Subscription expired. Deleting: ...${subscription.endpoint.slice(-20)}`);
                    return PushSubscription.deleteOne({ _id: subscription._id });
                } else {
                    logger.error({ err: error }, `❌ Failed to send notification to endpoint: ...${subscription.endpoint.slice(-20)}`);
                }
            })
    );

    await Promise.all(promises);
    logger.info('🚀 Test push notification process completed.');

    // --- 5. Disconnect ---
    await mongoose.disconnect();
    logger.info('MongoDB connection closed.');
    process.exit(0);
}

run().catch(err => {
    logger.fatal({ err }, 'An unhandled error occurred in the script.');
    process.exit(1);
});
```

## 📄 scripts/reset-admin-password.js
*Lines: 61, Size: 2.83 KB*

```javascript
// scripts/reset-admin-password.js (version 4.0 - Quote Stripping)
const dotenv = require('dotenv');
const path = require('path');
const mongoose = require('mongoose');
const { subtle, getRandomValues } = require('node:crypto');

dotenv.config({ path: path.resolve(__dirname, '../.env') });

const { MONGO_URI, NEXT_PUBLIC_ADMIN_EMAIL, NEXT_PUBLIC_ADMIN_PASSWORD } = process.env;
const encoder = new TextEncoder();

// Manually define the Subscriber model to avoid dependency issues
const { Schema } = mongoose;
const SubscriberSchema = new Schema({ email: { type: String, required: true, unique: true }, password: { type: String, required: true }, firstName: { type: String, required: true }, role: { type: String, default: 'user' }, isActive: { type: Boolean, default: true }, }, { timestamps: true, collection: 'subscribers' });
const Subscriber = mongoose.models.Subscriber || mongoose.model('Subscriber', SubscriberSchema);

async function hashPassword(password) {
    const salt = getRandomValues(new Uint8Array(16));
    const keyMaterial = await subtle.importKey('raw', encoder.encode(password), { name: 'PBKDF2' }, false, ['deriveBits']);
    const derivedBits = await subtle.deriveBits({ name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' }, keyMaterial, 256);
    const hash = Buffer.from(derivedBits);
    return `${Buffer.from(salt).toString('hex')}:${hash.toString('hex')}`;
}

async function run() {
    if (!MONGO_URI || !NEXT_PUBLIC_ADMIN_EMAIL || !NEXT_PUBLIC_ADMIN_PASSWORD) {
        console.error('❌ ERROR: MONGO_URI, NEXT_PUBLIC_ADMIN_EMAIL, and NEXT_PUBLIC_ADMIN_PASSWORD must be set in your .env file.');
        process.exit(1);
    }
    
    // DEFINITIVE FIX: Strip quotes from the password read from .env
    const cleanPassword = NEXT_PUBLIC_ADMIN_PASSWORD.replace(/^"|"$/g, '');

    let connection;
    try {
        console.log('Connecting to MongoDB...');
        connection = await mongoose.connect(MONGO_URI);
        console.log('✅ MongoDB connection successful.');

        await Subscriber.deleteOne({ email: NEXT_PUBLIC_ADMIN_EMAIL });
        console.log(`✓ Previous user record for ${NEXT_PUBLIC_ADMIN_EMAIL} deleted.`);

        console.log(`Hashing password "${cleanPassword}" for ${NEXT_PUBLIC_ADMIN_EMAIL}...`);
        const hashedPassword = await hashPassword(cleanPassword);
        console.log(`✓ Password hashed successfully.`);

        const newUser = await Subscriber.create({ email: NEXT_PUBLIC_ADMIN_EMAIL, password: hashedPassword, firstName: 'Admin', role: 'admin', isActive: true });
        console.log(`✅ SUCCESS: Admin user has been created/reset with ID: ${newUser._id}`);

    } catch (error) {
        console.error('❌ CRITICAL FAILURE:', error);
    } finally {
        if (connection) {
            await mongoose.disconnect();
            console.log('Database connection closed.');
        }
    }
}

run();

```

## 📄 scripts/results/list-events.js
*Lines: 30, Size: 1.13 KB*

```javascript
// apps/pipeline/scripts/results/list-events.js (version 2.0)
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import { SynthesizedEvent } from '../../../../packages/models/src/index.js';
import mongoose from 'mongoose';
import { formatDistanceToNow } from 'date-fns';

async function main() {
    await dbConnect();
    try {
        const events = await SynthesizedEvent.find({}).sort({ createdAt: -1 }).limit(10).lean();
        if (events.length === 0) {
            console.log('No recent events found.');
        } else {
            console.log('\n--- Last 10 Synthesized Events ---');
            console.table(events.map(e => ({
                Headline: e.synthesized_headline.substring(0, 80),
                Score: e.highest_relevance_score,
                Country: e.country,
                'Key Individuals': (e.key_individuals || []).map(k => k.name).join(', '),
                Created: `${formatDistanceToNow(new Date(e.createdAt))} ago`,
            })));
        }
    } catch (error) {
        console.error('Failed to list events:', error);
    } finally {
        await mongoose.disconnect();
    }
}
main();

```

## 📄 scripts/results/send-last-events.js
*Lines: 56, Size: 1.92 KB*

```javascript
// apps/pipeline/scripts/results/send-last-events.js (version 2.1.0)
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import { initializeSettings } from '../../../../packages/config/src/server.js';
import { logger } from '../../../../packages/utils/src/server.js';
import { Subscriber, SynthesizedEvent } from '../../../../packages/models/src/index.js';
import { sendNotifications } from '../../src/modules/notifications/index.js';
import { refreshConfig } from '../../src/config/dynamicConfig.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import mongoose from 'mongoose';

async function main() {
  const argv = yargs(hideBin(process.argv))
    .option('limit', {
      alias: 'l',
      type: 'number',
      description: 'Number of recent, unsent events to dispatch.',
      default: 10,
    })
    .help().argv;

  await dbConnect();
  logger.info('🚀 Starting Manual Event Dispatcher...');

  logger.info('Initializing dynamic configuration and settings...');
  await initializeSettings();
  await refreshConfig();
  logger.info('Configuration loaded.');

  try {
    const eventsToSend = await SynthesizedEvent.find({ emailed: false })
      .sort({ createdAt: -1 })
      .limit(argv.limit)
      .lean();

    if (eventsToSend.length === 0) {
      logger.info('✅ No un-emailed events found. All notifications are up to date.');
      return;
    }
    logger.info(`Found ${eventsToSend.length} recent, un-emailed event(s) to dispatch.`);

    // The sendNotifications function is designed to handle dispatch to all relevant users
    // based on their country subscriptions. It's the perfect tool for the job.
    await sendNotifications(eventsToSend, []);
    
  } catch (error) {
    logger.fatal({ err: error }, 'A critical error occurred during the manual dispatch process.');
  } finally {
    if (mongoose.connection.readyState === 1) {
        await mongoose.disconnect();
    }
  }
}

main();

```

## 📄 scripts/scripts/list.js
*Lines: 52, Size: 2.95 KB*

```javascript
// apps/pipeline/scripts/scripts/list.js (version 3.1.0)
import fs from 'fs';
import path from 'path';
import colors from 'ansi-colors';

const packageJsonPath = path.resolve(process.cwd(), 'apps/pipeline/package.json');
const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
const scripts = packageJson.scripts;

const scriptDescriptions = {
    "start": "Run the main pipeline. Flags: --country, --source, --isRefreshMode, --deleteToday, --noCommitMode, --useTestPayload.",
    "test": "Run the Jest test suite for the pipeline.",
    "db:seed:all": "Run all seeding scripts (settings, countries, admin user).",
    "db:seed:settings": "Seed or update the pipeline settings in the database.",
    "db:seed:countries": "Seed or update the list of countries from the canonical JSON file.",
    "db:seed:admin": "Seed or update the primary admin user.",
    "sources:list": "List sources. Flags: --country, --status [failing|healthy], --json.",
    "sources:scrape-one": "Scrape a single source for debugging. Flags: --source <SourceName>.",
    "sources:scrape-many": "Scrape multiple sources. Flags: --country <CountryName>.",
    "sources:discover": "Crawl a domain to find new news sections. Flags: --url <BaseURL>.",
    "sources:optimize": "Analyze a URL to suggest optimal CSS selectors. Flags: --url <URL>.",
    "sources:update": "Update a field on a source document. Usage: --source <Name> --key <Field> --value <JSONValue>",
    "sources:browse": "Interactively browse a website to find sections and selectors. Usage: --url <URL>",
    "sources:maintain": "Run the autonomous agent to find, fix, and prune sources.",
    "subscribers:list": "List all subscribers in the database.",
    "subscribers:update": "Update a field for a subscriber. Usage: --email <Email> --key <Field> --value <JSONValue>",
    "watchlist:list": "List watchlist entities. Flags: --q <SearchQuery>",
    "watchlist:add-term": "Add a search term to a watchlist entity. Usage: --name <EntityName> --term <SearchTerm>",
    "results:list-events": "Show the 10 most recently created synthesized events.",
    "maintenance:delete-today": "Delete all data created today. Flags: --yes.",
};

console.log(colors.bold.cyan("\n📘 Headlines Pipeline CLI\n"));
console.log("Usage: npm run <command> -w @headlines/pipeline -- [flags]\n");

const groupedScripts = {};
Object.keys(scripts).forEach(key => {
    if (!scriptDescriptions[key] && !key.startsWith('scripts:')) return;
    const [topic] = key.split(':');
    if (!groupedScripts[topic]) groupedScripts[topic] = [];
    groupedScripts[topic].push(key);
});

for (const topic in groupedScripts) {
    const capitalizedTopic = topic.charAt(0).toUpperCase() + topic.slice(1);
    console.log(colors.bold.yellow(`--- ${topic.charAt(0).toUpperCase() + topic.slice(1)} ---`));
    groupedScripts[topic].sort().forEach(scriptName => {
        console.log(`  ${colors.green(scriptName.padEnd(25))} ${scriptDescriptions[scriptName] || ''}`);
    });
    console.log('');
}

```

## 📄 scripts/seed/data/denmark.json
*Lines: 2081, Size: 112.41 KB*

```json
[
  {
    "rank in rich list": "N/A",
    "full name": "Søren Vestergaard-Poulsen",
    "city": "London",
    "event": "A Senior Managing Partner at CVC Capital Partners, one of the world's largest private equity firms. As a key figure in CVC's global investment committee, the Danish executive has built an immense fortune from his share of the carried interest on dozens of multi-billion-euro buyouts over two decades.",
    "net worth": 650000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Joachim Spänner",
    "city": "London",
    "event": "A Danish Partner at Apollo Global Management, a global private equity behemoth. Based in London, he focuses on the Nordic region and has accumulated significant wealth through his senior role in executing major leveraged buyouts and his share in the firm's lucrative profit-sharing structure.",
    "net worth": 350000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Luv Singh",
    "city": "London",
    "event": "A Danish Partner at the global private equity giant KKR (Kohlberg Kravis Roberts & Co.). His wealth has been generated by leading major European technology and software investments and receiving a significant portion of the carried interest from KKR's highly successful European funds.",
    "net worth": 400000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Christoffer Møller",
    "city": "Copenhagen",
    "event": "A Managing Partner at CVC Capital Partners and head of the firm's Copenhagen office. He is one of the most powerful figures in Nordic private equity, and his personal fortune is a direct result of leading successful buyouts and sharing in the substantial profits generated for CVC's investors.",
    "net worth": 300000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Claus Bülow Christensen",
    "city": "London",
    "event": "A Danish executive who became a Partner at Goldman Sachs in London. Reaching the coveted 'Partner' level at Goldman Sachs is one of the most lucrative achievements in finance, entailing a multi-million dollar salary, substantial bonuses, and a share in the firm's exclusive investment pool, creating an immense personal fortune.",
    "net worth": 200000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Christian Frigast",
    "city": "Copenhagen",
    "event": "Co-founder and Senior Partner of Axcel, one of the most influential private equity firms in the Nordic region. He is a founding father of the Danish PE industry, and his DKK 550 million+ fortune comes from decades of successful fund-raising and profitable exits, including Pandora and Vestas.",
    "net worth": 550000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Viggo Mølholm",
    "city": "Copenhagen",
    "event": "Co-founder and was the long-time Managing Partner of Polaris Private Equity. A key figure in the Danish buyout scene, his DKK 400 million+ fortune was built through his share of the firm's carried interest from a long and successful track record of investments in Danish and Swedish mid-market companies.",
    "net worth": 400000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Casper Breum",
    "city": "Frankfurt",
    "event": "A Danish Partner at the pan-European private equity firm Triton Partners. He has played a key role in the firm's industrial and business services investments. His wealth is a result of his senior position and share in the carried interest from Triton's successful funds.",
    "net worth": 225000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Niels de Coninck-Smith",
    "city": "Copenhagen",
    "event": "A Danish Partner at Verdane, a prominent Northern European growth equity firm. He specializes in technology and software investments, and his wealth has been built through his share of the profits from a portfolio of high-growth tech companies.",
    "net worth": 175000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Dan Rasmussen",
    "city": "Boston",
    "event": "A Danish-American investor who founded the asset management firm Verdad Advisers. He previously worked in private equity at Bain Capital. His wealth comes from his successful quantitative investment strategies and his family's prior business success.",
    "net worth": 150000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Mads Ryum Larsen",
    "city": "London",
    "event": "A Danish Partner at the London-based international private equity firm 3i Group. He focuses on investments in the consumer sector, and his personal fortune has been generated through his senior role and share of the profits from successful buyouts and exits.",
    "net worth": 200000000
  },
    {
    "rank in rich list": "N/A",
    "full name": "Esben Østergaard",
    "city": "Odense",
    "event": "A co-founder and the key technical mind behind Universal Robots, the company that pioneered the collaborative robot (cobot) industry. He became exceptionally wealthy after the company was sold to the American firm Teradyne for $285 million in 2015. He is now a prominent investor and mentor in the Danish robotics cluster.",
    "net worth": 175000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Christian Bason",
    "city": "Copenhagen",
    "event": "An influential figure in public sector innovation. While not a traditional industrialist, he built his wealth and influence as the long-serving CEO of the Danish Design Centre. He is a sought-after speaker and advisor, representing a modern form of wealth built on intellectual capital and global influence.",
    "net worth": 50000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "The Kann-Rasmussen Family Office",
    "city": "Copenhagen",
    "event": "While Lars Erik is the named individual, the broader VKR Group (VELUX) fortune is managed through a complex structure of foundations and a family office. Other descendants of founder Villum Kann Rasmussen hold significant, though less public, wealth and influence through their roles in the foundations that ensure the company's long-term continuity.",
    "net worth": 15800000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Thorvald Stauning",
    "city": "Copenhagen",
    "event": "While primarily known as a historic Prime Minister, his descendants have managed a quiet dynastic fortune. This 'old money' wealth, derived from early 20th-century industrial and political influence, represents one of Denmark's more discreet and long-standing affluent families.",
    "net worth": 120000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "The Founders of Momondo",
    "city": "Copenhagen",
    "event": "The group of founders behind the popular travel search engine Momondo became multi-millionaires after selling the company to the American travel technology giant Priceline Group (now Booking Holdings) for $550 million in 2017. This group includes figures like Thorvald Stigsen and other early partners.",
    "net worth": 250000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "The Due-Hansen Family",
    "city": "Farum",
    "event": "Heirs to the founder of A/S C.C. Jensen (CJC), a global leader in industrial oil filtration systems. This 'hidden champion' of Danish industry has been family-owned for generations, creating a quiet but substantial dynastic fortune.",
    "net worth": 300000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Mads Mikkelsen",
    "city": "Mallorca",
    "event": "Denmark's most successful international male actor. His wealth comes from a long career starring in major Hollywood franchises (James Bond, Star Wars, Marvel), European cinema, and lucrative global advertising campaigns for brands like Carlsberg.",
    "net worth": 95000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Lars Dalgaard",
    "city": "Palo Alto",
    "event": "Founded the enterprise software company SuccessFactors in Denmark, later moving it to the US. He became exceptionally wealthy after selling the company to German software giant SAP for $3.4 billion in 2011. He is now a general partner at the venture capital firm Andreessen Horowitz (a16z).",
    "net worth": 600000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Lars Fløe Nielsen",
    "city": "London",
    "event": "Co-founded the private equity firm Silverfleet Capital. His wealth was generated through carried interest and management fees from decades of successful mid-market buyouts across Europe. He is a prominent figure in the Danish community in London.",
    "net worth": 250000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Christian Lanng",
    "city": "San Francisco",
    "event": "Co-founder and former CEO of the fintech unicorn Tradeshift, a global supply chain payments and marketplace platform. His significant on-paper wealth is derived from his large equity stake in the multi-billion dollar company.",
    "net worth": 300000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Michael Seifert",
    "city": "Aarhus",
    "event": "Founder of the e-commerce platform Salling Group (formerly Dansk Supermarked) and a prominent investor. His primary wealth comes from his early online ventures and the subsequent sale of his company, which powered many of Denmark's largest retailers.",
    "net worth": 200000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "John V. H. Hansen",
    "city": "Copenhagen",
    "event": "Co-founder of the video surveillance software company Milestone Systems. He became a multi-millionaire after the company was acquired by Canon Inc. for a reported sum of over DKK 2 billion (approx. $300 million) in 2014.",
    "net worth": 150000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Michael Jonathan Grønager",
    "city": "New York",
    "event": "Co-founder and CEO of Chainalysis, a blockchain analysis unicorn that provides data and software to governments and businesses. The company's multi-billion dollar valuation makes him one of the wealthiest Danes in the cryptocurrency space.",
    "net worth": 500000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Asger Aamund",
    "city": "Copenhagen",
    "event": "A prominent Danish businessman and investor who made his fortune in the biotech industry. He founded and later sold a significant stake in the company Bavarian Nordic, and is a well-known public commentator on business and economics.",
    "net worth": 225000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Ulrik Juul Christensen",
    "city": "Boston",
    "event": "Co-founder of Area9 Lyceum, a world leader in adaptive learning technology. His wealth comes from building and selling previous educational technology companies and his significant stake in the highly successful Area9, which serves major corporations and educational institutions globally.",
    "net worth": 400000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Morten Strunge",
    "city": "Copenhagen",
    "event": "A serial tech entrepreneur who founded the e-book service Mofibo (sold to Storytel) and the mobile operator Onfone (sold to TDC). His fortune comes from these successful exits, and he continues to launch and invest in new ventures, including the podcast platform Podimo.",
    "net worth": 175000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Lars Thrane",
    "city": "Copenhagen",
    "event": "Founder of Thrane & Thrane, a global leader in satellite communication equipment for the maritime industry. He made his fortune when the company was acquired by the British firm Cobham plc for $432 million in 2012.",
    "net worth": 275000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Michael Andersen",
    "city": "Copenhagen",
    "event": "Co-founder of the website content management system company Sitecore. The company was sold to the private equity firm EQT for €1 billion in 2016, a landmark deal that created substantial wealth for its five founders.",
    "net worth": 200000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Christian Kirk Rasmussen",
    "city": "Copenhagen",
    "event": "Founder of the cloud data backup service Keepit. The company has achieved a significant private valuation following major investment rounds from leading venture firms, creating a substantial on-paper fortune for the founder.",
    "net worth": 150000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "René Rechtman",
    "city": "London",
    "event": "CEO of Moonbug Entertainment, the company behind the children's entertainment phenomenon CoComelon. He became exceptionally wealthy after leading the sale of the company to Blackstone-backed Candle Media for $3 billion in 2021.",
    "net worth": 400000000
  },
    {
    "rank in rich list": "N/A",
    "full name": "Christian Frigast",
    "city": "Copenhagen",
    "event": "A godfather of the Nordic private equity scene. He co-founded Axcel, one of Denmark's largest and most successful private equity firms, in 1994. His immense wealth was built over decades through management fees and, most importantly, the carried interest from dozens of successful buyouts and exits, including Pandora and Vestas.",
    "net worth": 550000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Viggo Mølholm",
    "city": "Copenhagen",
    "event": "Co-founder and was the long-time managing partner of Polaris Private Equity, another major Danish PE firm. Like his counterparts at Axcel, his fortune comes from a long and successful track record of acquiring, growing, and selling Nordic companies, generating significant carried interest.",
    "net worth": 400000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Søren Vestergaard-Poulsen",
    "city": "London",
    "event": "One of the most successful Danes in international private equity. He built his fortune as a senior managing partner at the global buyout giant CVC Capital Partners in London, where he led numerous multi-billion-euro deals. His wealth is derived from his share of the firm's carried interest.",
    "net worth": 650000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Luv Singh",
    "city": "London",
    "event": "A Danish executive who reached the top tier of global finance as a Partner at KKR (Kohlberg Kravis Roberts & Co.) in London, one of the world's most powerful private equity firms. His wealth was built through his involvement in major European buyouts and his share of the firm's profits.",
    "net worth": 400000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Mikkel Hippe Brun",
    "city": "San Francisco",
    "event": "A co-founder of the fintech unicorn Tradeshift, alongside Christian Lanng. As a key architect of the company's technology, his significant equity stake represents a substantial on-paper fortune based on the company's multi-billion dollar private valuation.",
    "net worth": 275000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Gert Sylvest",
    "city": "San Francisco",
    "event": "The third co-founder of the supply-chain fintech platform Tradeshift. His foundational role and equity position in the company contribute to a large personal fortune, reflecting the unicorn's success in attracting major venture capital and corporate clients.",
    "net worth": 275000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Niels Bjørn Christiansen",
    "city": "Nordborg",
    "event": "The current CEO of The LEGO Group, brought in as the first non-family member to hold the top post. His significant wealth comes from his previous role as CEO of Danfoss and is now being substantially augmented by one of the largest executive compensation and long-term incentive packages in corporate Denmark.",
    "net worth": 150000000
  },
  {
    "rank in rich list": 27,
    "full name": "Niels Due Jensen",
    "city": "Bjerringbro",
    "event": "Son of the founder and the man who globalized the pump manufacturer Grundfos, serving as its leader for decades. Although he passed control to his son Poul Due Jensen, he remains the family patriarch and holds a major part of the family's DKK 7.9 billion personal stake.",
    "net worth": 1106000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "The Heering Family",
    "city": "Copenhagen",
    "event": "Heirs to the iconic Cherry Heering liqueur brand, a company founded in 1818 that was 'Purveyor to the Royal Danish Court'. While the brand has been sold, the family retains a dynastic fortune built over nearly two centuries, now managed through family offices and other investments.",
    "net worth": 300000000
  },
  {
    "rank in rich list": 7,
    "full name": "André Kasprzak",
    "city": "Bredebro",
    "event": "Son of Hanni Toosbuy Kasprzak and heir to the ECCO footwear empire. As a member of the board and a professional golfer, he is part of the next generation poised to take over the DKK 24.3 billion family-owned global company.",
    "net worth": 3402000000
  },
  {
    "rank in rich list": 7,
    "full name": "Anna Toosbuy Rasch",
    "city": "Bredebro",
    "event": "Daughter of Hanni Toosbuy Kasprzak and designated heir to the ECCO fortune. She is active on the company's board, representing the family's next generation in the leadership of the DKK 24.3 billion global shoe manufacturer.",
    "net worth": 3402000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Heidi Rix",
    "city": "Aarhus",
    "event": "Co-founder of Plenti, a low-cost mobile operator. She and her co-founders became wealthy after selling the company to the telecom giant TDC for DKK 74 million just over a year after its launch, a notable Danish startup exit.",
    "net worth": 20000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "The Fisker & Nielsen Families",
    "city": "Copenhagen",
    "event": "Founding families of Nilfisk, a global leader in professional cleaning equipment founded in 1906. While the company is now publicly listed, the descendants of the founders retain a quiet dynastic fortune from their historical ownership.",
    "net worth": 400000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "The Foss Widell Family",
    "city": "Copenhagen",
    "event": "Heirs to the founder of the global industrial conglomerate F.L. Smidth & Co., a leader in the cement and mining industries. Though the family's direct control has diminished, their dynastic wealth, built over more than a century, is managed through various foundations and investment vehicles.",
    "net worth": 750000000
  },
    {
    "rank in rich list": "N/A",
    "full name": "Michael Seifert",
    "city": "Copenhagen",
    "event": "Co-founder and was the long-time CEO of Sitecore, the content management system company. Alongside his four co-founders, he became exceptionally wealthy from the landmark €1 billion sale of the company to the private equity firm EQT in 2016.",
    "net worth": 200000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Ole Vestergaard Rasmussen",
    "city": "Copenhagen",
    "event": "A key technical co-founder of Sitecore. As one of the five founders, he shared in the substantial proceeds from the €1 billion acquisition by EQT, securing a personal fortune in the hundreds of millions of DKK.",
    "net worth": 180000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Thomas Albert",
    "city": "Copenhagen",
    "event": "A co-founder of Sitecore. His foundational role in the company's development and his equity stake resulted in a major personal windfall from the 2016 sale to EQT, making him one of Denmark's quiet tech millionaires.",
    "net worth": 180000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Jesper Balser",
    "city": "Copenhagen",
    "event": "A co-founder of PC&C, the company that merged with Damgaard Data to form Navision. He became immensely wealthy following the subsequent sale of Navision to Microsoft for $1.45 billion in 2002, one of the most significant exits in Danish tech history.",
    "net worth": 400000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Torben Wind",
    "city": "Copenhagen",
    "event": "A co-founder of PC&C, the precursor to the enterprise software giant Navision. The $1.45 billion acquisition by Microsoft made him and his partners, Erik and Preben Damgaard, Jesper Balser, and Peter Bang, some of Denmark's most successful tech entrepreneurs.",
    "net worth": 400000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Peter Bang (Navision)",
    "city": "Copenhagen",
    "event": "A co-founder of PC&C, which merged to create Navision. His share of the proceeds from the blockbuster $1.45 billion sale to Microsoft established his significant personal fortune. He is distinct from the B&O founder's heir of the same name.",
    "net worth": 400000000
  },
  {
    "rank in rich list": 8,
    "full name": "Jacob Kjær",
    "city": "Låsby",
    "event": "Son of Niels Aage Kjær and a key figure in the next generation of the AVK Group. He is a Group Director and co-owner of the DKK 18 billion valve and hydrant manufacturing empire, personally owning a significant estate transferred from his father.",
    "net worth": 2520000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Jørgen Vig Knudstorp",
    "city": "Copenhagen",
    "event": "The former CEO credited with orchestrating the legendary turnaround of The LEGO Group from near-bankruptcy to record profitability. His wealth was built through substantial executive compensation and bonus packages and he now serves as Chairman of the LEGO Brand Group.",
    "net worth": 350000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Lars Tvede",
    "city": "Zug",
    "event": "A well-known Danish investor, serial entrepreneur, and author based in Switzerland. He built his fortune over several decades through successful financial market trading, derivatives, and early-stage investments in technology and biotech companies.",
    "net worth": 200000000
  },
  {
    "rank in rich list": 43,
    "full name": "Steen Hessel",
    "city": "Brande",
    "event": "One of the four brothers who own and run the Ejner Hessel A/S car dealership group. The family shares in the DKK 4.6 billion fortune generated by one of Denmark's largest automotive retailers.",
    "net worth": 644000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Torkil Hviid",
    "city": "Zug",
    "event": "A Danish executive in the commodities sector. He became wealthy as a key partner and trader at the global oil trading giant Glencore, benefiting from the company's highly lucrative IPO. He now resides in Switzerland.",
    "net worth": 275000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Niels Zibrandtsen",
    "city": "Copenhagen",
    "event": "Founder of the global web hosting company Zibra. He made his fortune after selling the company and has since become a prominent investor in technology and a notable art collector, establishing the Zibrandtsen Collection.",
    "net worth": 150000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Tue Mantoni",
    "city": "London",
    "event": "A Danish executive who built his fortune in the UK. He served as the CEO of the luxury motorcycle brand Triumph, leading it through a period of significant growth. He was previously a director at the private equity firm McKinsey and now invests in startups.",
    "net worth": 125000000
  },
    {
    "rank in rich list": "N/A",
    "full name": "Matthias Kamprad",
    "city": "London",
    "event": "Swedish son of IKEA founder Ingvar Kamprad, but grew up in Denmark and is a Danish speaker. His immense wealth derives from inheriting a major portion of the IKEA empire, specifically Ikano Group, the family's private DKK 100+ billion entity focused on finance, real estate, and retail, which he now chairs.",
    "net worth": 13500000000
  },
  {
    "rank in rich list": 2,
    "full name": "Niels Holch Povlsen",
    "city": "Aarhus",
    "event": "Brother of Anders Holch Povlsen. He holds a significant minority stake in the Bestseller fashion group, which underpins his personal fortune of DKK 0.6 billion (approx. $84 million) as detailed in the provided document.",
    "net worth": 84000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Lars Rasmussen",
    "city": "Sydney",
    "event": "A key Danish figure in global tech. He co-founded Where 2 Technologies, the company that became Google Maps after its acquisition by Google in 2004. His fortune was built on the acquisition proceeds and a long, high-ranking tenure at Google, where he also co-created Google Wave. He is now a prominent angel investor.",
    "net worth": 450000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Jesper Buch",
    "city": "Marbella",
    "event": "Founder of the online food delivery service Just Eat. After the company's multi-billion-pound success, he sold his stake and relocated to Spain. He is now one of Denmark's most high-profile angel investors, known for his role on the TV show 'Løvens Hule' (Dragons' Den).",
    "net worth": 350000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Jens Bjørn Andersen",
    "city": "Copenhagen",
    "event": "Former Group CEO of the global transport and logistics giant DSV. He accumulated a very significant fortune through long-term incentive programs and exercising stock options during a period where DSV's market value grew exponentially under his leadership.",
    "net worth": 250000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Camilla Færch",
    "city": "Holstebro",
    "event": "An heir to the Færch dynasty (tobacco, plastics). While family infighting and strategic missteps caused the family to drop from the top of the rich lists, individual members like Camilla retain hundreds of millions of DKK from the original sale of Skandinavisk Tobakskompagni and Færch Plast.",
    "net worth": 200000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Alexander Lacik",
    "city": "Copenhagen",
    "event": "While Swedish, he is a key figure in a major Danish company as the CEO of the jewelry giant Pandora. He has amassed a significant fortune through his executive compensation and substantial stock option packages tied to the company's successful turnaround and growth.",
    "net worth": 120000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Bo Kroll",
    "city": "San Francisco",
    "event": "A Danish technologist who became wealthy as an early and pivotal engineer at Salesforce during its formative years. His fortune was built on stock options that became extremely valuable as Salesforce grew into a global software-as-a-service behemoth.",
    "net worth": 100000000
  },
  {
    "rank in rich list": 14,
    "full name": "Søren Erik Westermann",
    "city": "Espergærde",
    "event": "Part of the family that owned the hearing aid manufacturer Widex. He shares in the family's significant stake in WS Audiology, formed after the merger with Sivantos, and owns a valuable portfolio of private real estate.",
    "net worth": 1988000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "The Due-Hansen Family",
    "city": "Farum",
    "event": "Heirs to the founder of A/S C.C. Jensen (CJC), a global leader in industrial oil filtration systems. This 'hidden champion' of Danish industry has been family-owned for generations, creating a quiet but substantial dynastic fortune.",
    "net worth": 300000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Mads Mikkelsen",
    "city": "Mallorca",
    "event": "Denmark's most successful international male actor. His wealth comes from a long career starring in major Hollywood franchises (James Bond, Star Wars, Marvel), European cinema, and lucrative global advertising campaigns for brands like Carlsberg.",
    "net worth": 95000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Lars Dalgaard",
    "city": "Palo Alto",
    "event": "Founded the enterprise software company SuccessFactors in Denmark, later moving it to the US. He became exceptionally wealthy after selling the company to German software giant SAP for $3.4 billion in 2011. He is now a general partner at the venture capital firm Andreessen Horowitz (a16z).",
    "net worth": 600000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Lars Fløe Nielsen",
    "city": "London",
    "event": "Co-founded the private equity firm Silverfleet Capital. His wealth was generated through carried interest and management fees from decades of successful mid-market buyouts across Europe. He is a prominent figure in the Danish community in London.",
    "net worth": 250000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Christian Lanng",
    "city": "San Francisco",
    "event": "Co-founder and former CEO of the fintech unicorn Tradeshift, a global supply chain payments and marketplace platform. His significant on-paper wealth is derived from his large equity stake in the multi-billion dollar company.",
    "net worth": 300000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Michael Seifert",
    "city": "Aarhus",
    "event": "Founder of the e-commerce platform Salling Group (formerly Dansk Supermarked) and a prominent investor. His primary wealth comes from his early online ventures and the subsequent sale of his company, which powered many of Denmark's largest retailers.",
    "net worth": 200000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "John V. H. Hansen",
    "city": "Copenhagen",
    "event": "Co-founder of the video surveillance software company Milestone Systems. He became a multi-millionaire after the company was acquired by Canon Inc. for a reported sum of over DKK 2 billion (approx. $300 million) in 2014.",
    "net worth": 150000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Michael Jonathan Grønager",
    "city": "New York",
    "event": "Co-founder and CEO of Chainalysis, a blockchain analysis unicorn that provides data and software to governments and businesses. The company's multi-billion dollar valuation makes him one of the wealthiest Danes in the cryptocurrency space.",
    "net worth": 500000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Asger Aamund",
    "city": "Copenhagen",
    "event": "A prominent Danish businessman and investor who made his fortune in the biotech industry. He founded and later sold a significant stake in the company Bavarian Nordic, and is a well-known public commentator on business and economics.",
    "net worth": 225000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Ulrik Juul Christensen",
    "city": "Boston",
    "event": "Co-founder of Area9 Lyceum, a world leader in adaptive learning technology. His wealth comes from building and selling previous educational technology companies and his significant stake in the highly successful Area9, which serves major corporations and educational institutions globally.",
    "net worth": 400000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Morten Strunge",
    "city": "Copenhagen",
    "event": "A serial tech entrepreneur who founded the e-book service Mofibo (sold to Storytel) and the mobile operator Onfone (sold to TDC). His fortune comes from these successful exits, and he continues to launch and invest in new ventures, including the podcast platform Podimo.",
    "net worth": 175000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Lars Thrane",
    "city": "Copenhagen",
    "event": "Founder of Thrane & Thrane, a global leader in satellite communication equipment for the maritime industry. He made his fortune when the company was acquired by the British firm Cobham plc for $432 million in 2012.",
    "net worth": 275000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Michael Andersen",
    "city": "Copenhagen",
    "event": "Co-founder of the website content management system company Sitecore. The company was sold to the private equity firm EQT for €1 billion in 2016, a landmark deal that created substantial wealth for its five founders.",
    "net worth": 200000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Christian Kirk Rasmussen",
    "city": "Copenhagen",
    "event": "Founder of the cloud data backup service Keepit. The company has achieved a significant private valuation following major investment rounds from leading venture firms, creating a substantial on-paper fortune for the founder.",
    "net worth": 150000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "René Rechtman",
    "city": "London",
    "event": "CEO of Moonbug Entertainment, the company behind the children's entertainment phenomenon CoComelon. He became exceptionally wealthy after leading the sale of the company to Blackstone-backed Candle Media for $3 billion in 2021.",
    "net worth": 400000000
  },
    {
    "rank in rich list": "N/A",
    "full name": "Lars Fjeldsoe-Nielsen",
    "city": "London",
    "event": "A key Danish figure in the global tech scene, often called 'Mr. Mobile'. He built his fortune as an early executive at unicorn startups, serving as Head of Mobile for both Dropbox and Uber during their critical hyper-growth phases leading up to their IPOs. He is now a General Partner at the London-based venture capital firm Balderton Capital, investing in the next wave of European tech companies.",
    "net worth": 150000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Hans Christian Bødker Jensen",
    "city": "Copenhagen",
    "event": "A veteran of the Danish financial sector. He accumulated his significant wealth during his long and influential tenure as the CEO of FIH Erhvervsbank, one of Denmark's major corporate and investment banks. His fortune is the result of decades of top-tier executive compensation, bonuses, and pension schemes.",
    "net worth": 75000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Carsten Dilling",
    "city": "Copenhagen",
    "event": "A high-profile Danish corporate leader who has served as CEO for some of the country's largest companies. His wealth was primarily built during his time as CEO of the national telecom giant TDC (now Nuuday) and through other C-suite and board positions at major corporations like SAS, NNIT, and Telia.",
    "net worth": 90000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Jim Hagemann Snabe",
    "city": "Copenhagen",
    "event": "A globally recognized business executive. He built his fortune as the co-CEO of the German software giant SAP. He has since held the prestigious dual chairmanships of Siemens AG in Germany and A.P. Moller-Maersk in Denmark, making him one of the most influential Danish figures in global business.",
    "net worth": 200000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Morten Lund",
    "city": "Copenhagen",
    "event": "A prolific and often-controversial Danish angel investor and entrepreneur. He made his first major fortune as an early investor in Skype, which he exited before the eBay sale. He has since invested in over 100 startups, experiencing both huge successes and high-profile bankruptcies, but remains a very wealthy figure in the tech scene.",
    "net worth": 80000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Kasper Rørsted",
    "city": "Munich",
    "event": "A top-tier Danish executive who has led major German corporations. He built a substantial fortune as the CEO of the chemical giant Henkel and later as the CEO of the global sportswear brand Adidas, commanding multi-million euro annual compensation packages.",
    "net worth": 175000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Niklas Östberg",
    "city": "Berlin",
    "event": "While Swedish, his wealth is deeply connected to the Danish ecosystem as the co-founder and CEO of Delivery Hero, which acquired the major Danish food delivery service hungry.dk. As a billionaire founder of a major European tech company with a strong Danish presence, he is a relevant figure.",
    "net worth": 1100000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Peter Bang",
    "city": "Copenhagen",
    "event": "An heir to the Bang & Olufsen fortune, a company co-founded by his grandfather, Peter Boas Bang. While the family no longer controls the company, the inherited wealth from its golden era has sustained a significant fortune for the descendants.",
    "net worth": 100000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Erik Damgaard",
    "city": "Copenhagen",
    "event": "An IT entrepreneur who, with his brother Preben, founded Damgaard Data, which later became Navision. He became immensely wealthy after the company was sold to Microsoft for $1.45 billion in 2002. He has since been an active investor in tech, real estate, and restaurants.",
    "net worth": 450000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Preben Damgaard",
    "city": "Copenhagen",
    "event": "Co-founder of Damgaard Data (later Navision). The landmark sale of the company to Microsoft in 2002 for $1.45 billion cemented his place as one of Denmark's wealthiest tech entrepreneurs. He remained an influential board member and investor in the Danish tech scene until his passing in 2022.",
    "net worth": 450000000
  },
    {
    "rank in rich list": "N/A",
    "full name": "Lars Dalgaard",
    "city": "Palo Alto",
    "event": "Founded the enterprise software company SuccessFactors in Denmark, later moving it to the US. He became exceptionally wealthy after selling the company to German software giant SAP for $3.4 billion in 2011. He is now a general partner at the venture capital firm Andreessen Horowitz (a16z).",
    "net worth": 600000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Lars Fløe Nielsen",
    "city": "London",
    "event": "Co-founded the private equity firm Silverfleet Capital. His wealth was generated through carried interest and management fees from decades of successful mid-market buyouts across Europe. He is a prominent figure in the Danish community in London.",
    "net worth": 250000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Christian Lanng",
    "city": "San Francisco",
    "event": "Co-founder and former CEO of the fintech unicorn Tradeshift, a global supply chain payments and marketplace platform. His significant on-paper wealth is derived from his large equity stake in the multi-billion dollar company.",
    "net worth": 300000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Michael Seifert",
    "city": "Aarhus",
    "event": "Founder of the e-commerce platform Salling Group (formerly Dansk Supermarked) and a prominent investor. His primary wealth comes from his early online ventures and the subsequent sale of his company, which powered many of Denmark's largest retailers.",
    "net worth": 200000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "John V. H. Hansen",
    "city": "Copenhagen",
    "event": "Co-founder of the video surveillance software company Milestone Systems. He became a multi-millionaire after the company was acquired by Canon Inc. for a reported sum of over DKK 2 billion (approx. $300 million) in 2014.",
    "net worth": 150000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Michael Jonathan Grønager",
    "city": "New York",
    "event": "Co-founder and CEO of Chainalysis, a blockchain analysis unicorn that provides data and software to governments and businesses. The company's multi-billion dollar valuation makes him one of the wealthiest Danes in the cryptocurrency space.",
    "net worth": 500000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Asger Aamund",
    "city": "Copenhagen",
    "event": "A prominent Danish businessman and investor who made his fortune in the biotech industry. He founded and later sold a significant stake in the company Bavarian Nordic, and is a well-known public commentator on business and economics.",
    "net worth": 225000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Ulrik Juul Christensen",
    "city": "Boston",
    "event": "Co-founder of Area9 Lyceum, a world leader in adaptive learning technology. His wealth comes from building and selling previous educational technology companies and his significant stake in the highly successful Area9, which serves major corporations and educational institutions globally.",
    "net worth": 400000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Morten Strunge",
    "city": "Copenhagen",
    "event": "A serial tech entrepreneur who founded the e-book service Mofibo (sold to Storytel) and the mobile operator Onfone (sold to TDC). His fortune comes from these successful exits, and he continues to launch and invest in new ventures, including the podcast platform Podimo.",
    "net worth": 175000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Lars Thrane",
    "city": "Copenhagen",
    "event": "Founder of Thrane & Thrane, a global leader in satellite communication equipment for the maritime industry. He made his fortune when the company was acquired by the British firm Cobham plc for $432 million in 2012.",
    "net worth": 275000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Michael Andersen",
    "city": "Copenhagen",
    "event": "Co-founder of the website content management system company Sitecore. The company was sold to the private equity firm EQT for €1 billion in 2016, a landmark deal that created substantial wealth for its five founders.",
    "net worth": 200000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Christian Kirk Rasmussen",
    "city": "Copenhagen",
    "event": "Founder of the cloud data backup service Keepit. The company has achieved a significant private valuation following major investment rounds from leading venture firms, creating a substantial on-paper fortune for the founder.",
    "net worth": 150000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "René Rechtman",
    "city": "London",
    "event": "CEO of Moonbug Entertainment, the company behind the children's entertainment phenomenon CoComelon. He became exceptionally wealthy after leading the sale of the company to Blackstone-backed Candle Media for $3 billion in 2021.",
    "net worth": 400000000
  },
    {
    "rank in rich list": "N/A",
    "full name": "Mads Faurholt-Jørgensen",
    "city": "Copenhagen",
    "event": "A serial entrepreneur and co-founder of Nova Founders Capital. He has built and sold numerous companies globally, including the e-commerce giant Lazada (sold to Alibaba). His wealth comes from a string of successful exits and ongoing venture capital activities.",
    "net worth": 300000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Bjarne Riis",
    "city": "Lugano",
    "event": "Former professional cyclist who won the 1996 Tour de France. He accumulated his wealth by founding and later selling the professional cycling team Riis Cycling (formerly Team CSC and Tinkoff-Saxo). He now resides in Switzerland.",
    "net worth": 90000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Claus Meyer",
    "city": "New York",
    "event": "Co-founder of the world-renowned restaurant Noma and a key figure in the New Nordic Cuisine movement. His fortune derives from a vast culinary empire that includes restaurants, bakeries, cookbooks, and the sale of his stake in the Meyer Group.",
    "net worth": 125000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Caroline Wozniacki",
    "city": "Monte Carlo",
    "event": "Former World No. 1 professional tennis player. She amassed a significant fortune through career prize money, lucrative endorsements with brands like Adidas and Rolex, and various business investments.",
    "net worth": 150000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Henrik Fisker",
    "city": "Los Angeles",
    "event": "A luxury car designer and entrepreneur known for designing iconic cars like the BMW Z8 and Aston Martin DB9. His wealth is tied to his ventures in the electric vehicle space, most notably Fisker Inc., which went public via a SPAC merger.",
    "net worth": 200000000
  },
  {
    "rank in rich list": 10,
    "full name": "Leise Mærsk Mc-Kinney Møller",
    "city": "Copenhagen",
    "event": "Eldest daughter of shipping magnate Mærsk Mc-Kinney Møller and sister to Ane Uggla. She holds a significant, though less public, share in the family's vast fortune derived from the A.P. Moller-Maersk conglomerate.",
    "net worth": 2296000000
  },
  {
    "rank in rich list": 10,
    "full name": "Kirsten Mærsk Mc-Kinney Olufsen",
    "city": "Copenhagen",
    "event": "Youngest daughter of Mærsk Mc-Kinney Møller. Like her sisters, she inherited a substantial part of the Mærsk family's wealth, managed through the family's foundational and holding company structures.",
    "net worth": 2296000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Casper von Koskull",
    "city": "London",
    "event": "A prominent Danish executive in international finance. He served as the CEO of Nordea, the largest financial services group in the Nordic region, and previously held senior roles at Goldman Sachs, accumulating a significant personal fortune.",
    "net worth": 100000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Søren Skou",
    "city": "Copenhagen",
    "event": "Former CEO of A.P. Moller-Maersk. He led the company through its historic transformation from a diversified conglomerate into an integrated logistics company. His compensation and stock holdings during this period resulted in a very large personal fortune.",
    "net worth": 150000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Stine Bjerregaard",
    "city": "London",
    "event": "Co-founder of the London-based private equity firm Nordic Capital's Copenhagen office and a key figure in European finance. Her successful career and carried interest from numerous major deals have made her one of Denmark's wealthiest female executives.",
    "net worth": 250000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Frederik Tuxen",
    "city": "Vedbæk",
    "event": "Co-founder and the original inventor behind the golf technology company Trackman. While the Eldrup-Jørgensen brothers are the majority owners, Tuxen retains a 15% stake in the company, valued at nearly DKK 1 billion (approx. $140 million).",
    "net worth": 140000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Niklas Zennström",
    "city": "London",
    "event": "While Swedish, he co-founded the Danish-born global success Skype with Janus Friis. The sale of Skype to eBay for $2.6 billion made both founders billionaires and pivotal figures in the Nordic tech scene. He now runs the venture capital firm Atomico.",
    "net worth": 1200000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Janus Friis",
    "city": "London",
    "event": "A Danish entrepreneur who co-founded a series of disruptive tech companies, including KaZaA, Skype (sold to eBay), and Joost. His sale of Skype secured his status as a billionaire, and he continues to invest in technology startups.",
    "net worth": 1200000000
  },
    {
    "rank in rich list": "N/A",
    "full name": "David Helgason",
    "city": "Reykjavik",
    "event": "Co-founded the video game engine giant Unity Technologies in Copenhagen. His immense wealth was realized through the company's 2020 IPO, making him a central figure in Denmark's largest modern tech success story, though he is of Icelandic origin.",
    "net worth": 900000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Lars Ulrich",
    "city": "San Francisco",
    "event": "Co-founder and drummer of the iconic heavy metal band Metallica. Born in Denmark, his substantial wealth comes from decades of record sales, global tours, and royalties from one of the most commercially successful bands in history.",
    "net worth": 350000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Jan Bech Andersen",
    "city": "Monaco",
    "event": "An investor who made a significant fortune in asset management and private equity. He is well-known in Denmark for his past majority ownership and chairmanship of the football club Brøndby IF and now resides in Monaco.",
    "net worth": 450000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Jeppe Rindom",
    "city": "Copenhagen",
    "event": "Co-founder and CEO of the fintech unicorn Pleo, a company that provides smart company cards and expense management solutions. The company's multi-billion dollar valuation has created a significant personal fortune for him on paper.",
    "net worth": 250000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Tommy Ahlers",
    "city": "Copenhagen",
    "event": "An entrepreneur and venture capitalist who made his first fortune selling his mobile social networking site ZYB to Vodafone. He has since been a prominent investor, a 'Dragon' on the Danish version of Dragons' Den ('Løvens Hule'), and served as a government minister.",
    "net worth": 1500000000
  },
  {
    "rank in rich list": 20,
    "full name": "Casper Kirk Johansen",
    "city": "Vejle",
    "event": "Grandson of the LEGO founder and brother of Anders Kirk Johansen. He co-manages the family's DKK 9.1 billion investment firm, Kirk Kapital, which was established from the family's 2007 spin-off from the main LEGO holding company.",
    "net worth": 1708000000
  },
  {
    "rank in rich list": 3,
    "full name": "Mads-Peter Clausen",
    "city": "Nordborg",
    "event": "Third-generation heir to the Danfoss fortune. As a member of the company's board of directors, he represents the family's continued strategic involvement in the DKK 211 billion industrial giant.",
    "net worth": 11858000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Jacob Risgaard",
    "city": "Nørresundby",
    "event": "Co-founder of Coolshop, one of Denmark's largest online retailers. He gained national fame as an investor on 'Løvens Hule' and has built a significant fortune from his e-commerce and investment activities.",
    "net worth": 175000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Mia Wagner",
    "city": "Viborg",
    "event": "Co-founder of the Nordic Female Founders group and former investor on 'Løvens Hule'. Her wealth stems from her family's company, Wagner Holding, and her own successful career in law and venture capital.",
    "net worth": 120000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Malene Birger",
    "city": "London",
    "event": "A highly successful fashion designer who founded the eponymous brand By Malene Birger. She made her fortune after selling a majority stake in her company to the IC Group (now part of IC Companys), a transaction mentioned in the document in relation to the Martinsen family.",
    "net worth": 100000000
  },
  {
    "rank in rich list": 10,
    "full name": "Robert Mærsk Uggla",
    "city": "Copenhagen",
    "event": "Grandson of Mærsk Mc-Kinney Møller and current Chairman of A.P. Moller-Maersk. As the family's designated leader for the next generation, he oversees the strategic direction of the shipping and logistics giant.",
    "net worth": 2296000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Lone Færch",
    "city": "Holstebro",
    "event": "A key figure in the Færch dynasty, which founded a major tobacco and plastics empire. Although the family has since dropped off the top lists due to internal disputes that eroded the fortune, she and other members remain individually wealthy from the original inheritance.",
    "net worth": 200000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Nikolaj Coster-Waldau",
    "city": "Copenhagen",
    "event": "A globally recognized Danish actor who accumulated a significant personal fortune primarily from his leading role as Jaime Lannister in the immensely popular HBO series 'Game of Thrones', supplemented by numerous film roles and endorsements.",
    "net worth": 80000000
  },
    {
    "rank in rich list": 2,
    "full name": "Troels Holch Povlsen",
    "city": "Brande",
    "event": "Father of Anders Holch Povlsen and founder of the Bestseller fashion group. While Anders owns the majority, Troels retains a personal fortune valued at DKK 2.2 billion (approx. $308 million) through his own holding company.",
    "net worth": 308000000
  },
  {
    "rank in rich list": 4,
    "full name": "Benedicte Find",
    "city": "Humlebæk",
    "event": "Sister of Niels Peter Louis-Hansen and co-heir to the Coloplast fortune. She shares in the family's controlling stake of the medical device company.",
    "net worth": 10458000000
  },
  {
    "rank in rich list": 5,
    "full name": "Mette Brunsborg",
    "city": "Silkeborg",
    "event": "Daughter of Lars Larsen and sister of Jacob Brunsborg. She is a co-heir to the Lars Larsen Group (Jysk) and holds a 16.5% stake in the family's DKK 43.6 billion retail empire.",
    "net worth": 6104000000
  },
  {
    "rank in rich list": 6,
    "full name": "Nina Østergaard Borris",
    "city": "Middelfart",
    "event": "Daughter of Torben Østergaard-Nielsen and CEO of United Shipping & Trading Company (USTC). She is a designated heir and active leader in the family's DKK 43.6 billion global conglomerate.",
    "net worth": 6104000000
  },
  {
    "rank in rich list": 6,
    "full name": "Mia Østergaard Nielsen",
    "city": "Middelfart",
    "event": "Daughter of Torben Østergaard-Nielsen and Chief Governance Officer at USTC. She shares in the ownership and strategic leadership of the DKK 43.6 billion family business.",
    "net worth": 6104000000
  },
  {
    "rank in rich list": 30,
    "full name": "Susie Grosbøl",
    "city": "Tisvildeleje",
    "event": "Daughter of Mascot International founder John Grosbøl and sister of CEO Michael Grosbøl. She is a co-owner of the highly profitable workwear manufacturer.",
    "net worth": 896000000
  },
  {
    "rank in rich list": "N/A (Formerly 93)",
    "full name": "Kent Arentoft",
    "city": "Copenhagen",
    "event": "Co-owner of the investment firm DSVM Invest alongside Peter Korsholm. His personal fortune declined significantly from DKK 2.0 billion to DKK 750 million due to a downturn in the firm's core businesses, causing him to exit the top 100 list.",
    "net worth": 105000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Mikkel Svane",
    "city": "San Francisco",
    "event": "Co-founder and former CEO of the customer service software company Zendesk. He became a billionaire after leading the company through its IPO and subsequent $10.2 billion acquisition by a private equity consortium in 2022.",
    "net worth": 1300000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Morten Primdahl",
    "city": "Lisbon",
    "event": "Co-founder of Zendesk. He shared in the significant wealth creation from the company's public listing and eventual $10.2 billion sale, securing his status as a billionaire.",
    "net worth": 1100000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Alexander Aghassipour",
    "city": "San Francisco",
    "event": "Co-founder of Zendesk. His stake in the company, from its inception to its $10.2 billion take-private deal, resulted in a personal fortune well over the billion-dollar mark.",
    "net worth": 1100000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Jan van de Winkel",
    "city": "Utrecht",
    "event": "Co-founder and CEO of the Danish biotech giant Genmab. While he is Dutch, he founded the company in Copenhagen, and his significant ownership stake in the highly successful antibody therapeutics firm makes him a billionaire figure central to the Danish biotech scene.",
    "net worth": 1400000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Jesper Buch",
    "city": "Copenhagen",
    "event": "Founder of the online food ordering service Just Eat. He made his fortune from the company's international expansion and eventual multi-billion-pound merger with Takeaway.com. He is now a prominent venture capitalist and media personality in Denmark.",
    "net worth": 350000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Lennart Lajboschitz",
    "city": "Copenhagen",
    "event": "Founder of the popular variety store chain Flying Tiger Copenhagen. In 2012, he sold a 70% stake to the private equity firm EQT for a sum that made him a multi-millionaire, and has since invested heavily in real estate and social projects.",
    "net worth": 650000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Peter Holten Mühlmann",
    "city": "Copenhagen",
    "event": "Founder and CEO of the global consumer review platform Trustpilot. He retained a significant stake in the company after its IPO on the London Stock Exchange in 2021, creating a personal fortune valued in the hundreds of millions of dollars.",
    "net worth": 300000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Christian Enevoldsen",
    "city": "Singapore",
    "event": "Son of Pandora co-founders Per Enevoldsen and Winnie Liljeborg. He is actively involved in managing the family's vast fortune through their Singapore-based family office, North-East Group.",
    "net worth": 1500000000
  },
    {
    "rank in rich list": 28,
    "full name": "Erling Daell",
    "city": "Copenhagen",
    "event": "Co-owner and heir to the Harald Nyborg and Jem & Fix retail empire. He shares control of the DKK 7.8 billion company with his father, Kurt Daell, and his brother, Njal Daell, and has taken over as chairman.",
    "net worth": 1092000000
  },
  {
    "rank in rich list": 28,
    "full name": "Njal Daell",
    "city": "Odense",
    "event": "Co-owner and heir to the Harald Nyborg and Jem & Fix retail empire. He is active in the family business, sharing ownership of the DKK 7.8 billion group with his father, Kurt, and brother, Erling.",
    "net worth": 1092000000
  },
  {
    "rank in rich list": 37,
    "full name": "Jacob Kunøe",
    "city": "Copenhagen",
    "event": "Son of investor Ib Kunøe and co-owner of the family's DKK 5.2 billion holding company, Consolidated Holdings, which has major stakes in IT firms Atea and Columbus.",
    "net worth": 728000000
  },
  {
    "rank in rich list": 48,
    "full name": "Camilla Barfoed",
    "city": "Odense",
    "event": "Co-owner of the Barfoed Group, a major real estate company in Odense with a portfolio valued at DKK 4.2 billion. She shares ownership and control with her brother, Frederik Barfoed.",
    "net worth": 588000000
  },
  {
    "rank in rich list": 67,
    "full name": "Alexandra Husted-Andersen",
    "city": "Copenhagen",
    "event": "One of three sisters who inherited a DKK 3.5 billion fortune from their father, Stig Husted-Andersen, comprising the medical device firm Codan Medical and a significant, debt-free portfolio of prime real estate.",
    "net worth": 490000000
  },
  {
    "rank in rich list": 67,
    "full name": "Deirdre Husted-Andersen",
    "city": "Copenhagen",
    "event": "The eldest of three sisters who inherited the DKK 3.5 billion Codan Medical and real estate empire from their father, Stig Husted-Andersen.",
    "net worth": 490000000
  },
  {
    "rank in rich list": 81,
    "full name": "Dorte Lund Kaack",
    "city": "Odense",
    "event": "Daughter of Bente Lis and the late Carl Christian Nielsen, co-founder of Micro Matic. She is a board member and co-inheritor of the family's 50% stake in the DKK 5 billion beverage-dispensing equipment company.",
    "net worth": 350000000
  },
  {
    "rank in rich list": 89,
    "full name": "Per Tollestrup Nielsen",
    "city": "Balling",
    "event": "Co-owner of N.C. Nielsen Gruppen, a leading Scandinavian supplier of gaffeltrucks and heavy machinery. He shares ownership of the DKK 2.4 billion company with his brother, Poul Byriel Nielsen.",
    "net worth": 336000000
  },
  {
    "rank in rich list": "N/A (Formerly 94)",
    "full name": "Hans-Bo Hyldig",
    "city": "Copenhagen",
    "event": "Owner of the property development firm FB Gruppen. He fell off the Top 100 list in 2024, with his fortune estimated just below the DKK 2.0 billion threshold, following a downturn in the real estate transaction market.",
    "net worth": 280000000
  },
  {
    "rank in rich list": "N/A (Formerly 89)",
    "full name": "Kaare Danielsen",
    "city": "Copenhagen",
    "event": "Founder and owner of the job portal Jobindex. He dropped off the Top 100 list in 2024 after taking the company private and seeing its valuation fall to DKK 1.9 billion.",
    "net worth": 266000000
  },
  {
    "rank in rich list": "N/A (Formerly 72)",
    "full name": "Morten K. Larsen",
    "city": "Copenhagen",
    "event": "Owner of the steel wholesaler Euro Steel. His family's fortune dropped from DKK 2.5 billion to DKK 1.4 billion due to falling steel prices and market uncertainty, causing him to fall off the Top 100 list.",
    "net worth": 196000000
  },
  {
    "rank in rich list": "N/A (Formerly 82)",
    "full name": "Peter Korsholm",
    "city": "Copenhagen",
    "event": "Co-owner of the investment firm DSVM Invest. His personal fortune fell sharply from DKK 2.3 billion to DKK 1.25 billion following a significant downturn in the firm's transport and raw materials businesses.",
    "net worth": 175000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Per Enevoldsen",
    "city": "Bangkok",
    "event": "Co-founded the global jewelry giant Pandora with his then-wife, Winnie Liljeborg. After the company's IPO, he relocated to Thailand and retains an immense fortune estimated to be in the billions of dollars.",
    "net worth": 1500000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Gunhild Kirk Johansen",
    "city": "Vejle",
    "event": "Sister of Kjeld Kirk Kristiansen and an heir to the LEGO fortune. She received a DKK 7.5 billion spin-off from the main family holding in 2007, which became the basis for the investment company Kirk Kapital, now run by her sons Anders and Casper.",
    "net worth": 1708000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Lars Rebien Sørensen",
    "city": "Copenhagen",
    "event": "Former CEO of the pharmaceutical giant Novo Nordisk. During his tenure, he was frequently named one of the world's best-performing CEOs and accumulated a personal fortune estimated to be in the hundreds of millions of dollars through salary and stock options.",
    "net worth": 500000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Niels-Jørgen Nielsen",
    "city": "Aalborg",
    "event": "Co-founder of the successful retail chain Normal. After selling a majority stake to Bestseller owner Anders Holch Povlsen, he retained a significant minority share, making him a multi-millionaire.",
    "net worth": 400000000
  },
    {
    "rank in rich list": 1,
    "full name": "Kjeld Kirk Kristiansen",
    "city": "Billund",
    "event": "Third-generation owner of LEGO Group. His portion of the family's wealth is primarily held through Kirkbi A/S, the main investment and holding company of the Kirk Kristiansen family. While he has passed on operational control and chairmanship to his son Thomas, he retains a significant ownership stake.",
    "net worth": 11774000000
  },
  {
    "rank in rich list": 1,
    "full name": "Thomas Kirk Kristiansen",
    "city": "Ullerslev",
    "event": "Fourth-generation owner and Chairman of LEGO Group. He holds a 26.15% stake in the family's holding company, Kirkbi A/S, and is actively leading the brand's strategic direction and governance across all its entities, including the LEGO Foundation.",
    "net worth": 13468000000
  },
  {
    "rank in rich list": 1,
    "full name": "Agnete Kirk Thinggaard",
    "city": "Billund",
    "event": "Fourth-generation owner of LEGO Group, holding a 26.00% stake in Kirkbi A/S. She serves as the vice-chair of the holding company and is an accomplished dressage rider.",
    "net worth": 13412000000
  },
  {
    "rank in rich list": 1,
    "full name": "Sofie Kirk Kristiansen",
    "city": "Billund",
    "event": "Fourth-generation owner of LEGO Group. In 2023, she sold a 2% stake in Kirkbi A/S back to the company for DKK 6.3 billion (approx. $900 million) to fund her personal investments in nature conservation and rewilding projects, while retaining a 23.36% ownership stake.",
    "net worth": 12978000000
  },
  {
    "rank in rich list": 2,
    "full name": "Anders Holch Povlsen",
    "city": "Brande",
    "event": "Sole owner of the Bestseller fashion group (including brands like Jack & Jones, Vero Moda) and the Normal retail chain. He is also a major investor in companies like Zalando and ASOS, and is the largest private landowner in Scotland.",
    "net worth": 12026000000
  },
  {
    "rank in rich list": 3,
    "full name": "Jørgen Mads Clausen",
    "city": "Nordborg",
    "event": "Son of Mads Clausen, the founder of the global industrial giant Danfoss. The family retains approximately 40% ownership of the company, which specializes in climate and energy solutions. In 2022, he stepped down as chairman, passing leadership to an external successor.",
    "net worth": 11858000000
  },
  {
    "rank in rich list": 4,
    "full name": "Niels Peter Louis-Hansen",
    "city": "Vedbæk",
    "event": "Son of the founders of Coloplast, a global medical device company. His fortune, primarily derived from a controlling 31.4% stake in Coloplast and a significant holding in Ambu, increased by DKK 18 billion in the past year due to strong share price performance.",
    "net worth": 10458000000
  },
  {
    "rank in rich list": 5,
    "full name": "Jacob Brunsborg",
    "city": "Silkeborg",
    "event": "Inherited the Lars Larsen Group from his father, Lars Larsen, founder of the JYSK retail empire. As chairman, he oversees the group's diverse investments, which include retail, furniture, and a significant golf resort.",
    "net worth": 6104000000
  },
  {
    "rank in rich list": 6,
    "full name": "Torben Østergaard-Nielsen",
    "city": "Middelfart",
    "event": "Founder and owner of United Shipping & Trading Company (USTC), a global conglomerate primarily focused on bunker fuel trading (Bunker Holding), shipping, and logistics. His wealth has been impacted by a DKK 334 million write-down related to the controversial bankruptcy of his subsidiary, Nordic Waste.",
    "net worth": 6104000000
  },
  {
    "rank in rich list": 7,
    "full name": "Hanni Merete Toosbuy Kasprzak",
    "city": "Bredebro",
    "event": "Owner of the global footwear brand ECCO, which she inherited from her father, Karl Toosbuy. Despite public criticism, her decision to maintain operations in Russia following the 2022 invasion has contributed to stable financial performance.",
    "net worth": 3402000000
  },
  {
    "rank in rich list": 8,
    "full name": "Niels Aage Kjær",
    "city": "Galten",
    "event": "Founder of AVK Group, a leading international manufacturer of valves, hydrants, and industrial fittings. He has recently transferred the majority of ownership to his four children, who are all active in the family business.",
    "net worth": 2520000000
  },
  {
    "rank in rich list": 9,
    "full name": "Knud Erik Andersen",
    "city": "Søborg",
    "event": "Founder and majority shareholder of European Energy, a major developer of wind and solar power projects. In 2024, he sold a 20% stake in the company to Mitsubishi HC Capital for DKK 5.2 billion (approx. $740 million), crystallizing a significant portion of his wealth.",
    "net worth": 2380000000
  },
  {
    "rank in rich list": 10,
    "full name": "Ane Mærsk Mc-Kinney Uggla",
    "city": "Copenhagen",
    "event": "Daughter of shipping magnate Mærsk Mc-Kinney Møller and a key figure in the Mærsk family. She chairs the A.P. Møller Foundation, which controls the A.P. Moller-Maersk group. The family's fortune declined by DKK 2.2 billion due to a downturn in the container shipping market.",
    "net worth": 2296000000
  },
  {
    "rank in rich list": 11,
    "full name": "Tais Clausen",
    "city": "Copenhagen",
    "event": "Co-founder of 3Shape, a global leader in 3D scanners and software for the dental industry. A significant portion of his wealth comes from a partial sale of the company to private equity firm EQT and a DKK 753 million dividend distribution in 2024.",
    "net worth": 2254000000
  },
  {
    "rank in rich list": 12,
    "full name": "Ib Nymark Hegelund",
    "city": "Lugano",
    "event": "A reclusive billionaire who sold his enzyme technology company in 2010. He subsequently multiplied his fortune 16-fold through a highly successful, long-term investment in a listed company, widely believed to be Novo Nordisk.",
    "net worth": 2240000000
  },
  {
    "rank in rich list": 13,
    "full name": "Lars Erik Kann-Rasmussen",
    "city": "Holte",
    "event": "Heir to the VKR Group, the holding company for VELUX, the world's leading manufacturer of roof windows. The family's fortune is derived from its 18% ownership stake and diversified investments, including a venture fund for sustainable building technologies.",
    "net worth": 2212000000
  },
  {
    "rank in rich list": 14,
    "full name": "Adam Westermann",
    "city": "Holte",
    "event": "Part of the family that owned Widex, a major hearing aid manufacturer. His wealth stems from the 2019 merger of Widex with Sivantos to form WS Audiology, in which the family holds a significant stake. He serves as VP of Global Innovation in the company.",
    "net worth": 1988000000
  },
  {
    "rank in rich list": 15,
    "full name": "Jan Tøpholm",
    "city": "Hørsholm",
    "event": "Co-owner of WS Audiology, one of the world's largest hearing aid manufacturers. The company was formed by the merger of his family's company, Widex, and Sivantos. The family retains 51% ownership of the merged entity and has a large property portfolio.",
    "net worth": 1974000000
  },
  {
    "rank in rich list": 16,
    "full name": "Nikolaj Hoffmann Deichmann",
    "city": "Malmö",
    "event": "Co-founder of the successful dental technology company 3Shape. A resident of Sweden, he recently established DM Family Office to manage his DKK 14.1 billion fortune, which includes his stake in 3Shape and other investments.",
    "net worth": 1974000000
  },
  {
    "rank in rich list": 17,
    "full name": "Bent Jensen",
    "city": "Nordborg",
    "event": "Founder and owner of LINAK, a global leader in electric linear actuator systems used in healthcare, agriculture, and industry. He has placed 10% of the company in a foundation and is developing a DKK 1.5 billion holiday resort.",
    "net worth": 1904000000
  },
  {
    "rank in rich list": 18,
    "full name": "Thomas Kähler",
    "city": "Copenhagen",
    "event": "Part of the family controlling Rockwool International, a global leader in stone wool insulation products. The family's wealth surged by DKK 5.4 billion in the past year, driven by a 75% increase in Rockwool's share price amid demand for energy-efficient building solutions.",
    "net worth": 1778000000
  },
  {
    "rank in rich list": 19,
    "full name": "Peter Foss",
    "city": "Hillerød",
    "event": "Sole owner of FOSS A/S, a leading global provider of high-tech analytical solutions for the food and agricultural industries. The company's consistent growth, including a 7% rise in EBITDA in 2023, underpins his DKK 12.6 billion fortune.",
    "net worth": 1764000000
  },
  {
    "rank in rich list": 20,
    "full name": "Anders Kirk Johansen",
    "city": "Vejle",
    "event": "A descendant of the LEGO founder who received a DKK 7.5 billion spin-off from the family's main holding company in 2007. He now chairs Kirk Kapital, an investment firm that has grown its assets to DKK 9.1 billion by investing in 16 small and medium-sized enterprises.",
    "net worth": 1708000000
  },
  {
    "rank in rich list": 21,
    "full name": "Martin Mourier",
    "city": "Fredensborg",
    "event": "A key figure in the family-owned Semler Gruppen, Denmark's largest automobile importer, representing brands such as Volkswagen, Audi, and Porsche. His wealth grew in the past year following a 27% increase in revenue driven by strong sales.",
    "net worth": 1414000000
  },
  {
    "rank in rich list": 22,
    "full name": "Christian Peter Dyvig",
    "city": "Copenhagen",
    "event": "A former partner at the private equity firm Nordic Capital. His primary asset is his ownership of Kompan, the world's leading manufacturer of playground equipment, which saw its EBITDA grow by 21% in 2023. He sold a minority stake to Kirk Kapital.",
    "net worth": 1246000000
  },
  {
    "rank in rich list": 23,
    "full name": "Henrik Østenkjær Lind",
    "city": "Aarhus",
    "event": "Founder of the energy trading firm Danske Commodities, which he sold to Norway's Equinor in 2018 for approximately DKK 3 billion. He now manages his fortune through his investment company, Lind Invest, and holds a significant stake in the restructured airline SAS.",
    "net worth": 1204000000
  },
  {
    "rank in rich list": 24,
    "full name": "Christian Stadil",
    "city": "Copenhagen",
    "event": "Owner of the Thornico conglomerate, which has diverse interests including the sportswear brand Hummel, packaging company Brdr. Hartmann, and real estate. He recently streamlined the group by divesting its shipping activities.",
    "net worth": 1176000000
  },
  {
    "rank in rich list": 25,
    "full name": "Peter Hellerung Christiansen",
    "city": "Skodsborg",
    "event": "Second-generation owner of the Bygma Group, a leading supplier of timber and building materials in the Nordic region. The family's wealth saw a slight decline as a housing market slump caused a 31% drop in the company's EBITDA.",
    "net worth": 1162000000
  },
  {
    "rank in rich list": 26,
    "full name": "Jakob Haldor Topsøe",
    "city": "Copenhagen",
    "event": "Grandson of the founder and current chairman of Haldor Topsøe A/S, a world leader in catalysis and sustainable energy technologies. The family's fortune increased by DKK 2.6 billion, driven by a 42% surge in EBITDA due to high demand for its green-tech solutions.",
    "net worth": 1148000000
  },
  {
    "rank in rich list": 27,
    "full name": "Poul Due Jensen",
    "city": "Bjerringbro",
    "event": "Grandson of the founder and current CEO of Grundfos, one of the world's largest pump manufacturers. The family holds a 9.6% personal stake in the company, separate from the foundation that owns the majority.",
    "net worth": 1106000000
  },
  {
    "rank in rich list": 28,
    "full name": "Kurt Daell",
    "city": "Charlottenlund",
    "event": "Patriarch of the family that owns the successful retail chains Harald Nyborg (hardware) and Jem & Fix (DIY). He has passed the chairmanship to his son Erling but retains voting control and a 30% equity stake.",
    "net worth": 1092000000
  },
  {
    "rank in rich list": 29,
    "full name": "Martin Møller Nielsen",
    "city": "Lugano",
    "event": "Founder of Nordic Aviation Capital (NAC), once the world's largest regional aircraft lessor. His wealth stems from a timely partial sale of his stake for DKK 6.6 billion, years before the company faced financial collapse during the COVID-19 pandemic.",
    "net worth": 924000000
  },
  {
    "rank in rich list": 30,
    "full name": "Michael Grosbøl",
    "city": "Silkeborg",
    "event": "Owner of Mascot International, a leading European manufacturer of high-quality workwear. The family's wealth has doubled over the past two years, propelled by strong international sales and a 21% growth in EBITDA.",
    "net worth": 896000000
  },
  {
    "rank in rich list": 31,
    "full name": "Hans Carl Bøgh-Sørensen",
    "city": "Odense",
    "event": "Founder of Orifarm, one of Europe's largest parallel importers of pharmaceuticals. His wealth increased in the last year, driven by an 18% rise in EBITDA.",
    "net worth": 896000000
  },
  {
    "rank in rich list": 32,
    "full name": "Hans Frederiksen",
    "city": "Vejleby",
    "event": "Founder of the transport and logistics company HCS A/S. He has completed a generational transfer of ownership to his two sons, Jacob and Mads, who are now active co-owners of the business.",
    "net worth": 896000000
  },
  {
    "rank in rich list": 33,
    "full name": "Ole Fleggaard",
    "city": "Kollund",
    "event": "A key figure in the family-owned Fleggaard Group, a conglomerate best known for its extensive cross-border retail trade between Denmark and Germany. The group also has significant activities in leasing and wholesale.",
    "net worth": 882000000
  },
  {
    "rank in rich list": 34,
    "full name": "Simon Hesse Vangsted Hoffmann",
    "city": "Copenhagen",
    "event": "An heir to Holger Hesse, the co-founder of medical device company Ambu. The family's fortune, managed through various holding companies, surged by DKK 3.1 billion due to a 69% increase in Ambu's share price over the last year.",
    "net worth": 882000000
  },
  {
    "rank in rich list": 35,
    "full name": "Morten Hummelmose",
    "city": "Copenhagen",
    "event": "A partner at the leading global private equity firm EQT. His wealth is primarily tied to his 3.2% stake in the publicly listed firm, whose share price has seen significant appreciation. He recently established a philanthropic foundation with an initial endowment of DKK 50 million.",
    "net worth": 826000000
  },
  {
    "rank in rich list": 36,
    "full name": "Klaus Eldrup-Jørgensen",
    "city": "Rungsted",
    "event": "Co-founder of Trackman, a company that developed revolutionary radar technology for tracking golf ball flight, now widely used in sports analytics. The business has expanded into baseball and other sports.",
    "net worth": 770000000
  },
  {
    "rank in rich list": 37,
    "full name": "Ib Kunøe",
    "city": "Vedbæk",
    "event": "An investor who built his fortune through Consolidated Holdings, which owns a controlling 28% stake in Norwegian IT services company Atea and 60% of the Danish IT company Columbus. His wealth grew by DKK 0.4 billion in the last year due to share price increases.",
    "net worth": 728000000
  },
  {
    "rank in rich list": 38,
    "full name": "Olav de Linde",
    "city": "Risskov",
    "event": "A self-made real estate magnate with a property portfolio valued at DKK 5.2 billion, concentrated primarily in Aarhus. He is known for renovating old industrial buildings into modern commercial and residential spaces.",
    "net worth": 728000000
  },
  {
    "rank in rich list": 39,
    "full name": "Peter Just Karberg",
    "city": "Charlottenlund",
    "event": "Fifth-generation owner of the Hans Just Group, a leading importer and distributor of wine and spirits in the Nordic region. The family's fortune declined from DKK 6.5 billion to DKK 5.2 billion following a 23% drop in EBITDA.",
    "net worth": 728000000
  },
  {
    "rank in rich list": 40,
    "full name": "Jørgen Enggaard",
    "city": "Hals",
    "event": "Founder of A. Enggaard Holding A/S, a major Danish construction and development company. While his sons now run the business, he retains significant assets including the Hals Nørreskov estate.",
    "net worth": 714000000
  },
  {
    "rank in rich list": 41,
    "full name": "Peter Bohnsen",
    "city": "Højbjerg",
    "event": "His fortune originates from the sale of the shipping company Unifeeder in 2007. The DKK 4.9 billion is now managed through two entities: his personal investment vehicle, Webco, and Jabami, which is owned by his four daughters.",
    "net worth": 686000000
  },
  {
    "rank in rich list": 42,
    "full name": "Michael Holm",
    "city": "Risskov",
    "event": "Co-founder and majority owner (60%) of Systematic, an international IT software company that provides critical systems for the defense, healthcare, and public sectors. A 44% growth in EBITDA was tempered by lower valuation multiples in the tech sector.",
    "net worth": 672000000
  },
  {
    "rank in rich list": 43,
    "full name": "Bjarne Hessel",
    "city": "Brande",
    "event": "Part of the family that owns Ejner Hessel A/S, one of Denmark's largest car dealerships, specializing in brands like Mercedes-Benz. A challenging market with higher interest rates and inventory costs led to an 11% drop in EBITDA, reducing the family's net worth.",
    "net worth": 644000000
  },
  {
    "rank in rich list": 44,
    "full name": "Jens Poulsen",
    "city": "Ikast",
    "event": "Founder of DK Company, a major European fashion group that owns 26 brands. A 21% decline in EBITDA, attributed to a difficult retail market, resulted in his fortune decreasing from DKK 6.0 billion to DKK 4.5 billion.",
    "net worth": 630000000
  },
  {
    "rank in rich list": 45,
    "full name": "Claus Bagger-Sørensen",
    "city": "Vejle",
    "event": "His wealth originates from the family's successful sales of the chewing gum company Dandy (to Cadbury) and the pharmaceutical firm Fertin Pharma (to Philip Morris). The proceeds are now managed by a family office that invests in health-tech startups.",
    "net worth": 588000000
  },
  {
    "rank in rich list": 46,
    "full name": "Lars Sidelmann Christensen",
    "city": "Roskilde",
    "event": "His family controls Pharmacosmos, a pharmaceutical company specializing in treatments for iron deficiency. The company achieved a record profit of DKK 689 million last year, establishing the family as new entrants on the rich list with a valuation of DKK 4.3 billion.",
    "net worth": 602000000
  },
  {
    "rank in rich list": 47,
    "full name": "Winnie Liljeborg",
    "city": "Roskilde",
    "event": "Co-founder of the global jewelry brand Pandora. After selling her stake, she established the Liljeborg Group to manage her DKK 4.3 billion fortune, which includes significant investments and a philanthropic foundation focused on supporting vulnerable children and youth.",
    "net worth": 602000000
  },
  {
    "rank in rich list": 48,
    "full name": "Frederik Barfoed",
    "city": "Odense",
    "event": "A key figure in the family-owned Barfoed Group, a significant real estate company in Odense. The family's net worth saw a slight decrease to DKK 4.2 billion due to negative property revaluations in a higher interest rate environment.",
    "net worth": 588000000
  },
  {
    "rank in rich list": 49,
    "full name": "Anders Østergaard",
    "city": "Dubai",
    "event": "Founder and owner of Monjasa, a global leader in bunker fuel trading. His fortune fell from DKK 7.7 billion to DKK 4.2 billion as earnings normalized after a record-breaking year in 2022 driven by market volatility.",
    "net worth": 588000000
  },
  {
    "rank in rich list": 50,
    "full name": "Kim Fournais",
    "city": "Nærum",
    "event": "Co-founder and CEO of the online multi-asset trading and investment platform Saxo Bank. He holds a 28% stake in the company and is also developing a luxury apartment complex on a prime waterfront site in Charlottenlund.",
    "net worth": 588000000
  },
  {
    "rank in rich list": 51,
    "full name": "Sune Simonsen",
    "city": "Copenhagen",
    "event": "Heir to the Scan-Group shipping and logistics empire, founded by his late father, Arne Simonsen. The family's fortune plummeted from DKK 10.2 billion to DKK 4.2 billion as a sharp drop in global freight rates caused an 80% collapse in the company's EBITDA.",
    "net worth": 588000000
  },
  {
    "rank in rich list": 52,
    "full name": "Henrik Lindberg",
    "city": "Risskov",
    "event": "His family's wealth comes from the 2021 sale of their high-end eyewear brand, Lindberg Optik, to the French-Italian multinational EssilorLuxottica. The DKK 4.1 billion proceeds are now managed through a family office.",
    "net worth": 574000000
  },
  {
    "rank in rich list": 53,
    "full name": "Jørn Tækker",
    "city": "Aarhus",
    "event": "A property developer known for the ambitious urban development project 'Nye,' a new town being built north of Aarhus planned to house 13,500 residents. His DKK 4.0 billion fortune is anchored in his extensive land bank and low-cost financing.",
    "net worth": 560000000
  },
  {
    "rank in rich list": 54,
    "full name": "Peter Stubkjær Sørensen",
    "city": "Brande",
    "event": "Made his fortune from the sale of wind turbine manufacturer Bonus Energi to Siemens in 2004. He has since reinvested the proceeds into a diversified portfolio of securities and real estate, including a 230-hectare forest estate.",
    "net worth": 546000000
  },
  {
    "rank in rich list": 55,
    "full name": "Mikael Goldschmidt",
    "city": "Kokkedal",
    "event": "A prominent real estate investor and owner of the Imerco homeware retail chain and the historic Kokkedal Castle. Negative property revaluations in 2023 caused his net worth to decrease slightly to DKK 3.9 billion.",
    "net worth": 546000000
  },
  {
    "rank in rich list": 56,
    "full name": "Mogens de Linde",
    "city": "Hornslet",
    "event": "A major property owner in Aarhus and brother of fellow real estate billionaire Olav de Linde. He transferred his DKK 3.7 billion portfolio, including a 95-hectare estate, to his children while remaining as chairman.",
    "net worth": 518000000
  },
  {
    "rank in rich list": 57,
    "full name": "Birger Arp-Hansen",
    "city": "Hellerup",
    "event": "Co-owner of the Arp-Hansen Hotel Group, the largest hotel operator in Copenhagen with 12 hotels and over 5,000 rooms. The family's wealth increased to DKK 3.5 billion following a strong post-pandemic recovery in tourism.",
    "net worth": 490000000
  },
  {
    "rank in rich list": 58,
    "full name": "Johan Regin Jacobsen",
    "city": "Fuglafjørður",
    "event": "CEO of the Faroese salmon farming company Bakkafrost. The family's 15.6% stake in the publicly listed company underpins their DKK 3.4 billion fortune, which saw an increase in the last year due to a rebound in the share price.",
    "net worth": 476000000
  },
  {
    "rank in rich list": 59,
    "full name": "Thorkil Stæhr Andersen",
    "city": "Samsø",
    "event": "Owner of the transport company TA-Logistics. Despite a 12% drop in EBITDA, his family's fortune grew by DKK 0.8 billion to DKK 3.2 billion, as the valuation was lifted by a higher trading multiple for comparable companies in the sector.",
    "net worth": 448000000
  },
  {
    "rank in rich list": 60,
    "full name": "Torben Lind",
    "city": "Køge",
    "event": "Patriarch of the family that owns Lind & Risør, a major builder of single-family homes in Denmark. The company's valuation was significantly lifted by a re-rating of its EBITDA multiple from 6.9x to 14.8x, pushing the family's fortune up by over DKK 1 billion.",
    "net worth": 448000000
  },
  {
    "rank in rich list": 61,
    "full name": "Anders Eikemo Thorgaard",
    "city": "Faaborg",
    "event": "Co-owner of Kivi-Tex, one of Denmark's largest industrial laundry service providers. The family's DKK 3.2 billion fortune is also supported by ownership of the historic Steensgaard Herregård estate.",
    "net worth": 448000000
  },
  {
    "rank in rich list": 62,
    "full name": "Niels Fennet",
    "city": "Taarbæk",
    "event": "Founder of the successful budget hotel chain CABINN. His DKK 3.2 billion fortune is derived from his portfolio of 12 hotels and other real estate, including the historic Store Kro inn in Fredensborg.",
    "net worth": 448000000
  },
  {
    "rank in rich list": 63,
    "full name": "Bent Jensen",
    "city": "Fredericia",
    "event": "Founder of the retail chain tHansen, which specializes in auto parts, accessories, and scooters. A strong financial performance in 2023, with a 42% jump in EBITDA, restored his fortune to DKK 3.1 billion after a dip the previous year.",
    "net worth": 434000000
  },
  {
    "rank in rich list": 64,
    "full name": "Rolf Stuhr Petersen",
    "city": "Copenhagen",
    "event": "Inherited the City Apartment real estate group from his father, Svend. The DKK 3.1 billion portfolio comprises 469 properties, primarily in Copenhagen, and is expanding with a new 64-unit development in Helsinge.",
    "net worth": 434000000
  },
  {
    "rank in rich list": 65,
    "full name": "Preben Terp-Nielsen",
    "city": "Aabenraa",
    "event": "Patriarch of the family that owns Abena, a global manufacturer and wholesaler of healthcare products. The family's fortune was nearly halved, dropping from DKK 6.0 billion to DKK 3.1 billion, after the company posted a record loss due to soaring raw material costs.",
    "net worth": 434000000
  },
  {
    "rank in rich list": 66,
    "full name": "Svend Møller Hansen",
    "city": "Hobro",
    "event": "Founder of DS Gruppen, a leading supplier of steel and concrete solutions. His fortune was crystallized by the sale of a majority stake to the German company Goldbeck in 2023, leaving the family with DKK 3.1 billion in cash and real estate.",
    "net worth": 434000000
  },
  {
    "rank in rich list": 67,
    "full name": "Stefanie Husted-Andersen",
    "city": "Copenhagen",
    "event": "One of three sisters who inherited a significant fortune from their father, Stig Husted-Andersen. The DKK 3.5 billion estate includes the medical device company Codan Medical and a portfolio of prime, debt-free real estate in Copenhagen and North Zealand.",
    "net worth": 490000000
  },
  {
    "rank in rich list": 68,
    "full name": "Nicholas Peter Francis",
    "city": "Copenhagen",
    "event": "Co-founder of the video game software development company Unity Technologies. A significant portion of his wealth was realized from the company's 2020 IPO, with the proceeds now managed through a family fund that invests in private equity and real estate.",
    "net worth": 392000000
  },
  {
    "rank in rich list": 69,
    "full name": "Christian Georg Peter Moltke",
    "city": "Haslev",
    "event": "His family's fortune was created by the sale of their solar park developer, BeGreen, to the Norwegian energy giant Equinor for DKK 2.35 billion in late 2022. The proceeds were largely distributed, leaving DKK 2.8 billion in the family's holding company.",
    "net worth": 392000000
  },
  {
    "rank in rich list": 70,
    "full name": "Mikael Dystrup Pedersen",
    "city": "Køge",
    "event": "An early investor and co-owner of the renewable energy company European Energy. After the company sold a 20% stake to Mitsubishi, his remaining 10% stake is valued at DKK 2.7 billion.",
    "net worth": 378000000
  },
  {
    "rank in rich list": 71,
    "full name": "Alan Nissen",
    "city": "Juelsminde",
    "event": "His family's wealth stems from the 2021 sale of a majority stake in their company, Nissens Cooling Solutions, to A.P. Møller Holding. They retained a minority stake and now manage a DKK 1.9 billion portfolio of securities.",
    "net worth": 378000000
  },
  {
    "rank in rich list": 72,
    "full name": "Claus Hommelhoff",
    "city": "Aarhus",
    "event": "Founder of Formuepleje, one of Denmark's largest independent asset managers. The family sold a majority stake to the Lars Larsen Group but retains a significant minority interest and other investments valued at DKK 2.6 billion.",
    "net worth": 364000000
  },
  {
    "rank in rich list": 73,
    "full name": "Karsten Buchhave",
    "city": "Skanderborg",
    "event": "His fortune originates from the 2021 sale of a 49.9% stake in his biogas plant construction company, Bigadan, to an English private equity fund. A downturn in the biogas sector has since reduced the value of his remaining stake, cutting his fortune by DKK 1 billion.",
    "net worth": 364000000
  },
  {
    "rank in rich list": 74,
    "full name": "Svend-Aage Nielsen",
    "city": "Odense",
    "event": "Co-owner of Micro Matic, a global leader in beverage dispensing equipment, particularly for draft beer. The company, which he took over with a partner in the 1970s, is now being passed to the next generation.",
    "net worth": 364000000
  },
  {
    "rank in rich list": 75,
    "full name": "Christian Bach",
    "city": "Hinnerup",
    "event": "Co-founder of the energy trading powerhouse In Commodities. A normalization of the energy markets after the extreme volatility of 2022 led to lower, though still substantial, profits, with his share of the company's equity valued at DKK 2.5 billion.",
    "net worth": 364000000
  },
  {
    "rank in rich list": 76,
    "full name": "Jeppe Bülow Højgaard",
    "city": "Løgten",
    "event": "Co-founder of the energy trading company In Commodities. His DKK 2.5 billion fortune is his one-third share of the company's equity, which was built up significantly from record profits during the 2022 energy crisis.",
    "net worth": 350000000
  },
  {
    "rank in rich list": 77,
    "full name": "Morten Ebbesen",
    "city": "Copenhagen",
    "event": "His wealth was generated from the 2019 sale of a majority stake in his software company, Siteimprove, to the private equity firm Nordic Capital. He has reinvested the DKK 2.5 billion proceeds into a portfolio of tech stocks and startups.",
    "net worth": 350000000
  },
  {
    "rank in rich list": 78,
    "full name": "Jesper Severin Johanson",
    "city": "Zug",
    "event": "Co-founder of the energy trading firm In Commodities. Now a resident of Switzerland, his DKK 2.5 billion fortune represents his one-third ownership of the highly profitable company.",
    "net worth": 350000000
  },
  {
    "rank in rich list": 79,
    "full name": "Karsten Bill Rasmussen",
    "city": "Odense",
    "event": "A major real estate investor in Odense, with a DKK 2.5 billion fortune spread across a complex structure of seven different property companies. His portfolio includes commercial, residential, and industrial properties.",
    "net worth": 350000000
  },
  {
    "rank in rich list": 80,
    "full name": "Sophie Bensimon Rossing",
    "city": "Hellerup",
    "event": "Co-created her fortune from the sale of the Fitness World gym chain. She reinvested the proceeds into a successful new venture, the car wash chain World Wash, and a DKK 1.4 billion portfolio of listed stocks.",
    "net worth": 350000000
  },
  {
    "rank in rich list": 81,
    "full name": "Bente Lis Nielsen",
    "city": "Tommerup",
    "event": "Widow of Carl Christian Nielsen, co-owner of Micro Matic, a leading global supplier of draft beverage equipment. Her family inherited his 50% stake in the DKK 5 billion company.",
    "net worth": 350000000
  },
  {
    "rank in rich list": 82,
    "full name": "Bettina Antitsch Mortensen",
    "city": "Aarhus",
    "event": "Inherited the extensive property group M+ Invest and homebuilder Hybel from her late husband, Michael Antitsch Mortensen. She now runs the DKK 2.5 billion company, which has a significant portfolio of residential and commercial real estate.",
    "net worth": 350000000
  },
  {
    "rank in rich list": 83,
    "full name": "Anneli Gjørup",
    "city": "Roskilde",
    "event": "Her family's wealth originates from the toy retailer Fætter BR and the Top-Toy group. Following the group's sale and subsequent bankruptcy, the remaining DKK 2.5 billion fortune is managed through various family investment vehicles.",
    "net worth": 350000000
  },
  {
    "rank in rich list": 84,
    "full name": "Henning Kjeldsen",
    "city": "Skagen",
    "event": "Formerly known as Denmark's 'quota king' for his vast fishing rights. He sold the majority of his quotas and fleet in 2022 and has since reinvested the DKK 2.4 billion proceeds into acquiring four hotels and other properties in Skagen.",
    "net worth": 336000000
  },
  {
    "rank in rich list": 85,
    "full name": "Johan Ernst Wedell-Wedellsborg",
    "city": "Vedbæk",
    "event": "Owner of the Weco shipping group. His DKK 2.4 billion fortune was bolstered by record earnings in the product tanker market and his DKK 150 million purchase of a historic estate in Hørsholm for a new residence.",
    "net worth": 336000000
  },
  {
    "rank in rich list": 86,
    "full name": "Peter Rosholm",
    "city": "Copenhagen",
    "event": "A former executive at Novozymes. He made his fortune by leading a management buyout of its spin-off, Albumedix, and subsequently selling it to the German company Sartorius for nearly DKK 4 billion, netting him personally DKK 2.4 billion.",
    "net worth": 336000000
  },
  {
    "rank in rich list": 87,
    "full name": "Niels Thorborg",
    "city": "Odense",
    "event": "Founder of L'easy, a company specializing in the rental of consumer electronics and appliances. His 3C Groups holding company now has diverse interests, including property, the struggling Facit Bank, and the Odense Boldklub football team.",
    "net worth": 336000000
  },
  {
    "rank in rich list": 88,
    "full name": "Thomas Wilkens Andersen",
    "city": "Kerteminde",
    "event": "Third-generation owner of the Fayard shipyard in Munkebo, one of Northern Europe's largest ship repair and conversion facilities. His family's fortune grew by DKK 0.4 billion to DKK 2.4 billion, driven by a 23% increase in EBITDA.",
    "net worth": 336000000
  },
  {
    "rank in rich list": 89,
    "full name": "Poul Byriel Nielsen",
    "city": "Spøttrup",
    "event": "Co-owner of N.C. Nielsen Gruppen, a leading Scandinavian supplier of forklifts and heavy machinery. A 10% increase in EBITDA pushed the family's net worth to DKK 2.4 billion.",
    "net worth": 336000000
  },
  {
    "rank in rich list": 90,
    "full name": "Lars Seier Christensen",
    "city": "Zug",
    "event": "Co-founder of Saxo Bank. After selling his stake for a substantial sum, he moved to Switzerland and now manages his DKK 2.3 billion fortune through Seier Capital. His investments include a 22.5% stake in Parken Sport & Entertainment.",
    "net worth": 322000000
  },
  {
    "rank in rich list": 91,
    "full name": "Erik Bank Lauridsen",
    "city": "Esbjerg",
    "event": "His family holds a 25% stake in the IT company Systematic, a share valued at DKK 2.3 billion. The family firm, with roots dating back to 1886, also has investments in finance and property.",
    "net worth": 322000000
  },
  {
    "rank in rich list": 92,
    "full name": "Niels Erik Martinsen",
    "city": "Hørsholm",
    "event": "His family's wealth originates from the fashion conglomerate IC Companys (now IC Group). Their holding company, Friheden Invest, manages a DKK 2.2 billion portfolio that includes property and a large agricultural estate.",
    "net worth": 308000000
  },
  {
    "rank in rich list": 93,
    "full name": "Fleming Grunnet",
    "city": "Copenhagen",
    "event": "Patriarch of the family that owns Inter Primo, a global plastics extrusion company founded in 1959. A 36% drop in EBITDA reduced the family's net worth to DKK 2.2 billion.",
    "net worth": 308000000
  },
  {
    "rank in rich list": 94,
    "full name": "Claus Henrik Christiansen",
    "city": "Zug",
    "event": "His DKK 2.2 billion fortune is derived from the family's ownership of Nordic Bioscience, a biotech company. A significant drop in the company's valuation caused the family's wealth to fall from DKK 3.8 billion.",
    "net worth": 308000000
  },
  {
    "rank in rich list": 95,
    "full name": "Aage Søndergaard Nielsen",
    "city": "Kolding",
    "event": "Made his fortune from the 2016 sale of his industrial company, Sondex, to Danfoss for DKK 1.6 billion. A subsequent legal dispute over the final payment was resolved, and the family's wealth has since grown to DKK 2.2 billion through investments.",
    "net worth": 308000000
  },
  {
    "rank in rich list": 96,
    "full name": "Henrik Sørensen",
    "city": "Vadum",
    "event": "His family's wealth comes from selling a 64% stake in their pump manufacturing company, Desmi, to a private equity fund. They retained a 21% share, and the total family fortune from the deal and other assets is DKK 2.1 billion.",
    "net worth": 294000000
  },
  {
    "rank in rich list": 97,
    "full name": "Joachim Ante",
    "city": "Copenhagen",
    "event": "A co-founder of the video game software giant Unity Technologies. The sharp and sustained decline in Unity's share price on the Nasdaq has cut his fortune in half over the past year, from DKK 4.3 billion to DKK 2.1 billion.",
    "net worth": 294000000
  },
  {
    "rank in rich list": 98,
    "full name": "Hans Wilhelm Schur",
    "city": "Horsens",
    "event": "Fifth-generation owner of Schur International, one of the world's oldest family-owned packaging companies, founded in 1846. His DKK 2.1 billion fortune was boosted by a 59% rise in the share price of his listed investment, SP Group.",
    "net worth": 294000000
  },
  {
    "rank in rich list": 99,
    "full name": "Kim Dencher Johansen",
    "city": "Frederiksværk",
    "event": "A property developer who built a DKK 2.0 billion real estate empire, primarily in and around his hometown of Frederiksværk. His holding company's equity value crossed the DKK 2 billion mark in 2023.",
    "net worth": 280000000
  },
  {
    "rank in rich list": 100,
    "full name": "Birthe Marianne Christiansen",
    "city": "Kolding",
    "event": "Matriarch of the family that owns the Nic. Christiansen Gruppen, a major importer of cars including Hyundai, Jaguar, and Land Rover. Despite a 13% drop in EBITDA, the family's fortune is valued at DKK 2.0 billion.",
    "net worth": 280000000
  },
    {
    "rank in rich list": 60,
    "full name": "Rikke Lind",
    "city": "Køge",
    "event": "Daughter of Torben Lind and a key heir to the Lind & Risør construction fortune. She shares in the family's DKK 3.2 billion wealth and personally owns a summer house in the exclusive Tisvildeleje area, purchased for DKK 3.2 million.",
    "net worth": 448000000
  },
  {
    "rank in rich list": 60,
    "full name": "Jesper Lind",
    "city": "Køge",
    "event": "Son of Torben Lind and co-heir to the Lind & Risør house-building empire. As a part of the family ownership, he shares in the DKK 3.2 billion fortune, which saw a significant re-rating in its valuation in the past year.",
    "net worth": 448000000
  },
  {
    "rank in rich list": 60,
    "full name": "Carsten Lind",
    "city": "Lellinge",
    "event": "Son of Torben Lind and co-heir to the DKK 3.2 billion Lind & Risør family fortune. He personally owns a 21-hectare agricultural estate in Lellinge, near Køge, which is part of his share in the family's wealth.",
    "net worth": 448000000
  },
  {
    "rank in rich list": "N/A",
    "full name": "Pernille Lindberg",
    "city": "Beder",
    "event": "Co-owner of the proceeds from the 2021 sale of the eyewear brand Lindberg to EssilorLuxottica. She manages her share of the DKK 4.1 billion family fortune through the family office PAM and the Lindberg Optik retail chain.",
    "net worth": 574000000
  },
  {
    "rank in rich list": 14,
    "full name": "Anders Westermann",
    "city": "Holte",
    "event": "Brother of Søren Erik Westermann and part of the family that owned Widex. His personal fortune is tied to his significant stake in the merged hearing aid giant WS Audiology and an extensive private property portfolio.",
    "net worth": 1988000000
  },
    {
    "rank in rich list": "22 (in 2021)",
    "full name": "David Helgason",
    "city": "Copenhagen",
    "event": "A co-founder of the video game technology giant Unity Technologies. He became a billionaire following the company's highly successful IPO on the New York Stock Exchange in September 2020. His wealth in 2021 was based on his significant remaining stake in the multi-billion dollar company.",
    "net worth": 1270000000
  },
  {
    "rank in rich list": "35 (in 2021)",
    "full name": "Nicholas Peter Francis",
    "city": "Copenhagen",
    "event": "A co-founder of Unity Technologies alongside David Helgason and Joachim Ante. His fortune was crystallized by the 2020 IPO. As one of the three key founders, his equity stake in the company was valued at DKK 5.0 billion in 2021.",
    "net worth": 794000000
  },
  {
    "rank in rich list": "44 (in 2021)",
    "full name": "Kent Arentoft",
    "city": "Copenhagen",
    "event": "A former executive who, with his partner Peter Korsholm, acquired the environmental services company DSVM Invest for a nominal sum. They successfully turned the company around, creating a highly profitable business and a personal fortune valued at DKK 4.2 billion in 2021.",
    "net worth": 667000000
  },
  {
    "rank in rich list": "60 (in 2021)",
    "full name": "Per Tejs Knudsen",
    "city": "Copenhagen",
    "event": "Founder and majority owner of the software company cBrain. His fortune surged dramatically as the company's share price on the stock exchange increased seven-fold in 2020, driven by high demand for its F2 standard software platform for public administration.",
    "net worth": 476000000
  },
  {
    "rank in rich list": "66 (in 2021)",
    "full name": "Rolf Svend Petersen",
    "city": "Copenhagen",
    "event": "Heir to and CEO of the family-owned property group City Apartment. The company owns and rents out approximately 2,000 furnished apartments in Copenhagen. His DKK 2.8 billion fortune was significantly boosted by a major revaluation of the property portfolio in 2020.",
    "net worth": 444000000
  },
  {
    "rank in rich list": "67 (in 2021)",
    "full name": "Michael Antitsch Mortensen",
    "city": "Aarhus",
    "event": "A serial entrepreneur in the construction and real estate sector. He made his fortune by founding and selling successful companies like HusCompagniet and CASA A/S to private equity. In 2021, his wealth was valued at DKK 2.7 billion following a new investment in the paint company Flügger.",
    "net worth": 429000000
  },
  {
    "rank in rich list": "75 (in 2021)",
    "full name": "Gullak Arngrimsson Madsen",
    "city": "Hirtshals",
    "event": "Owner of the major fishing company GTM Holding and the super-trawler 'Ruth'. His DKK 2.6 billion fortune was built on highly profitable fishing operations in the North Atlantic and the strategic sale of valuable fishing quotas.",
    "net worth": 413000000
  },
  {
    "rank in rich list": "88 (in 2021)",
    "full name": "Jørgen Hansen",
    "city": "Copenhagen",
    "event": "Founder of Nordic Transport Group (NTG). He and his family retained a 17% stake in the logistics company after taking it public via a reverse takeover. The company's share price more than sextupled post-listing, creating the family's DKK 2.2 billion fortune.",
    "net worth": 349000000
  },
  {
    "rank in rich list": "90 (in 2021)",
    "full name": "Inge & Anders Blicher Petersen",
    "city": "Odense",
    "event": "The family owns Newtec, a successful Fyn-based company that manufactures high-tech sorting and packaging machinery for the global food industry. The DKK 2.1 billion fortune was built on consistent profitability and international expansion.",
    "net worth": 333000000
  },
  {
    "rank in rich list": "97 (in 2021)",
    "full name": "Familien Bylling (Bylling Family)",
    "city": "Christiansfeld",
    "event": "The family owns Aller Aqua, a leading global producer of environmentally friendly fish feed. Their DKK 1.8 billion fortune was built on successful expansion into emerging aquaculture markets in China, Africa, and the Balkans.",
    "net worth": 286000000
  },
  {
    "rank in rich list": "99 (in 2021)",
    "full name": "Familien efter Johan Schrøder (Heirs of Johan Schrøder)",
    "city": "Copenhagen",
    "event": "The family's DKK 1.7 billion fortune was created from the sale of the med-tech company Radiometer in 2003. The proceeds have since been managed through a family holding company, J.S.R., which primarily invests in securities and real estate like the Aggersvold estate.",
    "net worth": 270000000
  },
    {
    "rank in rich list": "3 (in 2017)",
    "full name": "Lars Larsen",
    "city": "Silkeborg",
    "event": "Founder of the JYSK retail empire, a global chain with several thousand stores. He built a DKK 28.8 billion fortune from scratch, starting with one store in Aarhus in 1979. Besides JYSK, his holdings included Bolia.com, Ilva, Idémøbler, and the furniture producer Actona. He passed away in 2019.",
    "net worth": 4299000000
  },
  {
    "rank in rich list": "4 (in 2017)",
    "full name": "Mads Clausen",
    "city": "Nordborg",
    "event": "Founder of the industrial giant Danfoss in 1933. While he passed away in 1966, his legacy is the foundation of the Clausen family's DKK 28.5 billion fortune. The family retains nearly half of the company's shares, with the rest held by a foundation and employees.",
    "net worth": 4254000000
  },
  {
    "rank in rich list": "5 (in 2017)",
    "full name": "Aage Louis-Hansen",
    "city": "Humlebæk",
    "event": "Co-founder of the global medical device company Coloplast. He and his wife, Johanne, established the company based on a nurse's idea for a disposable stomipose. The company's success is the origin of the Louis-Hansen family's DKK 27.8 billion fortune.",
    "net worth": 4149000000
  },
  {
    "rank in rich list": "5 (in 2017)",
    "full name": "Johanne Louis-Hansen",
    "city": "Humlebæk",
    "event": "Co-founder of Coloplast alongside her husband, Aage Louis-Hansen. As a nurse herself, she saw the potential in the initial product idea and was instrumental in persuading her husband to start the company, which led to the family's vast fortune.",
    "net worth": 4149000000
  },
  {
    "rank in rich list": "6 (in 2017)",
    "full name": "Dieter Kasprzak",
    "city": "Bredebro",
    "event": "Former CEO of the ECCO shoe company and husband of the owner, Hanni Toosbuy Kasprzak. He stepped down from the CEO role in 2017, passing the leadership to Steen Borgholm, after a long and successful tenure leading the company's global expansion.",
    "net worth": 1866000000
  },
  {
    "rank in rich list": "8 (in 2017)",
    "full name": "Nils Foss",
    "city": "Hillerød",
    "event": "Founder of FOSS A/S in 1959, a world-leading company in analytical instruments for the food and agricultural industries. The company remains in family ownership, with his son Peter Foss serving as chairman.",
    "net worth": 1612000000
  },
  {
    "rank in rich list": "9 (in 2017)",
    "full name": "Villum Kann-Rasmussen",
    "city": "Copenhagen",
    "event": "Founder of VELUX and the VKR Group. Although he passed away in 1993, his innovations in roof windows created a global industrial powerhouse and the foundation for the family's DKK 8.8 billion fortune, now managed by his grandson, Mads Kann-Rasmussen.",
    "net worth": 1313000000
  },
  {
    "rank in rich list": "11 (in 2017)",
    "full name": "Jeppe Christiansen",
    "city": "Copenhagen",
    "event": "CEO of the investment firm Maj Invest. He is a key external figure in a family-owned dynasty, serving as the Chairman of the Board for Haldor Topsøe A/S, helping to guide the strategic direction of the highly successful engineering company.",
    "net worth": 1284000000
  },
  {
    "rank in rich list": "15 (in 2017)",
    "full name": "Hans Frede Fleggaard",
    "city": "Padborg",
    "event": "Took over his family's small colonial goods store in 1960 and transformed it into the Fleggaard Group, a massive conglomerate best known for its cross-border retail. The DKK 5.2 billion fortune is now managed by his three children: Ole, Birgitte, and Susanne.",
    "net worth": 776000000
  },
  {
    "rank in rich list": "16 (in 2017)",
    "full name": "Christian Tøpholm",
    "city": "Nærum",
    "event": "Co-founder of the hearing aid manufacturer Widex in 1956. He and his partner, Erik Westermann, built the company from scratch, creating a global player and the foundation for the Tøpholm and Westermann families' multi-billion DKK fortunes.",
    "net worth": 776000000
  },
  {
    "rank in rich list": "16 (in 2017)",
    "full name": "Erik Westermann",
    "city": "Nærum",
    "event": "Co-founder of Widex. His partnership with Christian Tøpholm led to the creation of one of the world's leading hearing aid companies, securing vast wealth for both founding families, now in their third generation of leadership.",
    "net worth": 776000000
  },
  {
    "rank in rich list": "23 (in 2017)",
    "full name": "Tonny Dalhøj Paulsen",
    "city": "Aarhus",
    "event": "Co-founded the container feeder shipping company Unifeeder with his partner, Peter Bohnsen. They sold the company in 2007 for approximately DKK 2 billion, which formed the basis of his subsequent wealth, managed through his family holding company.",
    "net worth": 582000000
  },
  {
    "rank in rich list": "24 (in 2017)",
    "full name": "Mads Frederiksen",
    "city": "Glostrup",
    "event": "Fourth-generation leader and CEO of HCS A/S Transport & Spedition, a large family-owned logistics and environmental services company. He shares ownership of the DKK 3.8 billion business with his father, Hans, and brother, Jacob.",
    "net worth": 567000000
  },
  {
    "rank in rich list": "28 (in 2017)",
    "full name": "Merete Hay",
    "city": "Copenhagen",
    "event": "Co-founder of the Danish design powerhouse HAY, alongside her husband, Rolf Hay. The company's global success is a key part of the investment portfolio of Troels Holch Povlsen (Bestseller founder), who is the majority owner.",
    "net worth": 448000000
  },
  {
    "rank in rich list": "28 (in 2017)",
    "full name": "Rolf Hay",
    "city": "Copenhagen",
    "event": "Co-founder of the internationally acclaimed design company HAY. The firm is a significant holding for Troels Holch Povlsen, who has helped finance its growth into a billion-kroner business.",
    "net worth": 448000000
  },
  {
    "rank in rich list": "29 (in 2017)",
    "full name": "Lykke Martinsen",
    "city": "London",
    "event": "Wife of Niels Martinsen and co-heir to the IC Group fashion fortune. Their daughter, Emilie, is the primary inheritor, though Niels Martinsen retains voting control of the family's DKK 2.5 billion holding company, Friheden Invest.",
    "net worth": 373000000
  }
]
```

## 📄 scripts/seed/ingest-denmark-richlist.js
*Lines: 124, Size: 4.84 KB*

```javascript
// apps/pipeline/scripts/seed/ingest-denmark-richlist.js
import mongoose from 'mongoose'
import path from 'path'
import { reinitializeLogger, logger } from '../../../../packages/utils/src/server.js'
import { initializeScriptEnv } from './lib/script-init.js'
import { loadAndPrepareDenmarkRichlist } from './lib/denmark-richlist-data-loader.js'
import { Opportunity } from '../../../../packages/models/src/index.js'
import { contactFinderChain, performGoogleSearch } from '../../../../packages/ai-services/src/index.js'
import colors from 'ansi-colors'
import pLimit from 'p-limit'

const CONCURRENCY_LIMIT = 5;

async function createOrUpdateOpportunity(person) {
    try {
        const updateResult = await Opportunity.updateOne(
            { reachOutTo: person.name },
            {
                $setOnInsert: {
                    reachOutTo: person.name,
                    basedIn: person.country,
                    city: person.city,
                    likelyMMDollarWealth: person.wealthMillionsUSD,
                    // DEFINITIVE FIX: Always initialize contactDetails as an object on insert.
                    contactDetails: {
                        company: person.primaryCompany,
                    }
                },
                $addToSet: { whyContact: { $each: person.whyContact } }
            },
            { upsert: true }
        );

        if (updateResult.upsertedCount > 0) {
            logger.info(colors.green(`  ✅ Created new Opportunity for: ${person.name}`));
        } else if (updateResult.modifiedCount > 0) {
            logger.info(colors.yellow(`  🔄 Updated existing Opportunity for: ${person.name}`));
        } else {
            logger.info(`  ⚪️ No changes for Opportunity: ${person.name}`);
        }
        return { success: true, name: person.name };
    } catch (error) {
        logger.error({ err: error }, `❌ Failed to create/update opportunity for ${person.name}`);
        return { success: false };
    }
}

async function enrichOpportunityWithContact(name) {
    try {
        const opportunity = await Opportunity.findOne({ reachOutTo: name });
        if (!opportunity || opportunity.contactDetails?.email) {
            logger.trace(`  -> Skipping email search for ${name} (already exists or opp not found).`);
            return { success: true, found: false };
        }

        // DEFINITIVE FIX: If contactDetails somehow doesn't exist, create it.
        if (!opportunity.contactDetails) {
            opportunity.contactDetails = {};
        }

        logger.info(`  -> AI Contact Finder: Searching for email for ${name}...`);
        
        const searchQuery = `"${opportunity.reachOutTo}" "${opportunity.contactDetails?.company || ''}" email contact`;
        const searchResult = await performGoogleSearch(searchQuery);

        if (!searchResult.success || !searchResult.snippets) {
            logger.warn(`  -> Web search failed for ${name}. Cannot find email.`);
            return { success: true, found: false };
        }

        const response = await contactFinderChain({ snippets: searchResult.snippets });

        if (response && !response.error && response.email) {
            opportunity.contactDetails.email = response.email;
            await opportunity.save();
            logger.info(colors.green(`    ✅ Found and saved email for ${name}: ${response.email}`));
            return { success: true, found: true };
        } else {
            logger.warn(`    -> AI could not find an email for ${name}.`);
            return { success: true, found: false };
        }
    } catch (error) {
        logger.error({ err: error }, `❌ Failed during contact enrichment for ${name}`);
        return { success: false };
    }
}

async function main() {
  reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'))
  await initializeScriptEnv()
  logger.info('🚀 Starting Denmark Direct-to-Opportunity Ingestion Script...');

  const { allIndividuals } = await loadAndPrepareDenmarkRichlist()
  
  logger.info(`🔥 Launching concurrent processing for ${allIndividuals.length} individuals with a limit of ${CONCURRENCY_LIMIT}...`);

  const limit = pLimit(CONCURRENCY_LIMIT);
  const processingPromises = allIndividuals.map(person => 
    limit(async () => {
      logger.info(colors.cyan(`\n--- Processing: ${person.name} ---`))
      const createResult = await createOrUpdateOpportunity(person);
      if (createResult.success) {
          await enrichOpportunityWithContact(createResult.name);
      }
    })
  );

  await Promise.all(processingPromises);

  logger.info('\n--- Ingestion Summary ---');
  logger.info(colors.green('✅ Script finished. All individuals processed.'));
}

main()
  .catch((err) =>
    logger.fatal({ err }, 'A critical error occurred in the main script execution.')
  )
  .finally(() => {
    if (mongoose.connection.readyState === 1) {
      mongoose.disconnect()
    }
    process.exit(0)
  })

```

## 📄 scripts/seed/ingest-richlist.js
*Lines: 103, Size: 3.62 KB*

```javascript
// apps/pipeline/scripts/seed/ingest-richlist.js
import mongoose from 'mongoose'
import path from 'path'
import { reinitializeLogger, logger } from '../../../../packages/utils/src/server.js'
import { initializeScriptEnv } from './lib/script-init.js'
import { loadAndPrepareRichlist } from './lib/richlist-data-loader.js'
import { createSyntheticArticle } from './lib/synthetic-article-builder.js'
import { runInjectedPipeline } from './lib/pipeline-injector.js'
import { enrichThinProfile } from './lib/enrich-thin-profile.js'
import { chunkHistoryIntoEvents } from './lib/event-chunker.js'
import colors from 'ansi-colors'

async function main() {
  reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'))
  await initializeScriptEnv()
  logger.info('🚀 Starting Rich List Ingestion Script (Sequential, Verbose Mode)...')

  const { allIndividuals, rawIndividualData } = await loadAndPrepareRichlist()

  logger.info(
    `Preparing to process ${allIndividuals.length} individuals from the ${allIndividuals[0]?.year || 'latest'} rich list...`
  )

  let totalEventsCreated = 0
  let totalOppsCreated = 0

  // DEFINITIVE FIX: Revert to a sequential for...of loop to ensure logs appear in order.
  for (const person of allIndividuals) {
    logger.info(colors.cyan(`\n--- Analyzing: ${person.name} ---`))

    if (person.isThinProfile) {
      logger.info(
        colors.magenta(
          `  📝 Thin profile detected for ${person.name.toUpperCase()}. Triggering AI enrichment...`
        )
      )
      logger.info(
        { raw_data: rawIndividualData.find((p) => p.name === person.name) },
        `Raw JSON data for ${person.name}`
      )
      const enrichedData = await enrichThinProfile(person)
      person.background = enrichedData.generated_background
    }

    const eventChunks = await chunkHistoryIntoEvents(person)

    for (const [index, chunk] of eventChunks.entries()) {
      logger.info(
        colors.bold(
          `  └── Processing event chunk ${index + 1}/${eventChunks.length}: "${chunk.description}"`
        )
      )
      try {
        const syntheticArticle = createSyntheticArticle(person, chunk)

        // The call to this function will now display all its internal logs sequentially.
        const { savedEvents, savedOpportunities } =
          await runInjectedPipeline(syntheticArticle)

        if (savedEvents && savedEvents.length > 0) {
          totalEventsCreated += savedEvents.length
          savedEvents.forEach((event) => {
            logger.info(
              colors.green(`    ✅ Event Created: "${event.synthesized_headline}"`)
            )
          })
        }
        if (savedOpportunities && savedOpportunities.length > 0) {
          totalOppsCreated += savedOpportunities.length
          savedOpportunities.forEach((opp) => {
            logger.info(
              colors.green(
                `    ✅ Opportunity Created: "${opp.reachOutTo}" (~$${opp.likelyMMDollarWealth}M)`
              )
            )
          })
        }
      } catch (error) {
        logger.error(
          { err: error },
          `    ❌ Failed to process event chunk: "${chunk.description}"`
        )
      }
    }
  }

  logger.info('\n--- Ingestion Summary ---')
  logger.info(colors.green(`✅ Successfully created ${totalEventsCreated} events.`))
  logger.info(colors.green(`✅ Successfully created ${totalOppsCreated} opportunities.`))
  logger.info('✅ Script finished.')
}

main()
  .catch((err) =>
    logger.fatal({ err }, 'A critical error occurred in the main script execution.')
  )
  .finally(() => {
    if (mongoose.connection.readyState === 1) {
      mongoose.disconnect()
    }
    process.exit(0)
  })

```

## 📄 scripts/seed/lib/denmark-richlist-data-loader.js
*Lines: 87, Size: 2.96 KB*

```javascript
// apps/pipeline/scripts/seed/lib/denmark-richlist-data-loader.js
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import { Opportunity } from '../../../../../packages/models/src/index.js'
import { logger } from '../../../../../packages/utils/src/server.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const BASE_PATH = path.resolve(__dirname, '../../')
const DKK_TO_USD_RATE = 0.14; // Approximate conversion rate

// DEFINITIVE FIX: Expanded city-to-country mapping to be more comprehensive
const cityToCountryMap = {
  "london": "United Kingdom",
  "geneva": "Switzerland",
  "zug": "Switzerland",
  "dubai": "United Arab Emirates",
  "boston": "United States",
  "palo alto": "United States",
  "san francisco": "United States",
  "new york": "United States",
  "los angeles": "United States",
  "frankfurt": "Germany",
  "munich": "Germany",
  "berlin": "Germany",
  "sydney": "Australia",
  "marbella": "Spain",
  "mallorca": "Spain",
  "monte carlo": "Monaco",
  "lugano": "Switzerland",
  "utrecht": "Netherlands",
  "reykjavik": "Iceland",
  "copenhagen": "Denmark",
  "aarhus": "Denmark",
  "odense": "Denmark",
  "aalborg": "Denmark",
  "esbjerg": "Denmark",
};

function getCountryFromCity(city) {
    if (!city) return 'Denmark';
    const lowerCity = city.toLowerCase();
    return cityToCountryMap[lowerCity] || 'Denmark';
}

export async function loadAndPrepareDenmarkRichlist() {
  const jsonPath = path.join(BASE_PATH, 'seed/data/denmark.json')
  const rawIndividuals = JSON.parse(fs.readFileSync(jsonPath, 'utf8'))
  
  const uniqueIndividuals = Array.from(new Map(rawIndividuals.map(item => [item['full name'], item])).values());
  logger.info(
    `Loaded ${rawIndividuals.length} total individuals from ${path.basename(jsonPath)}, filtered down to ${uniqueIndividuals.length} unique entries.`
  )

  const existingOppNames = (await Opportunity.find({}).select('reachOutTo').lean()).map(
    (o) => o.reachOutTo
  )
  const existingSet = new Set(existingOppNames)

  const preparedIndividuals = uniqueIndividuals.map((person) => {
    const wealthUSD = person['net worth'] * DKK_TO_USD_RATE;
    const wealthMillionsUSD = Math.round(wealthUSD / 1000000);

    const background = `Based in: ${person.city}. Estimated Net Worth: $${wealthMillionsUSD}M USD. Event/History: ${person.event}`;
    const isThinProfile = background.trim().length < 50;

    const preparedPersonObject = {
      name: person['full name'],
      city: person.city,
      country: getCountryFromCity(person.city),
      industry: person.industry || 'Finance',
      wealthMillionsUSD: wealthMillionsUSD,
      background: background,
      wealthSummary: '',
      primaryCompany: 'Private Equity',
      year: new Date().getFullYear(),
      isExisting: existingSet.has(person['full name']),
      isThinProfile,
    };
    
    return preparedPersonObject;
  });

  return { allIndividuals: preparedIndividuals, rawIndividualData: uniqueIndividuals };
}

```

## 📄 scripts/seed/lib/enrich-thin-profile.js
*Lines: 94, Size: 4.85 KB*

```javascript
// apps/pipeline/scripts/seed/lib/enrich-thin-profile.js
import { callLanguageModel } from '../../../../../packages/ai-services/src/index.js';
import { settings } from '../../../../../packages/config/src/server.js';
import { logger } from '../../../../../packages/utils/src/server.js';
import { z } from 'zod';

const verificationSchema = z.object({
  is_significant_figure: z.boolean().describe("True if the person is a known business figure (founder, CEO, major owner)."),
  verification_summary: z.string().describe("A neutral, one-sentence summary of the person's primary role based on general knowledge."),
});

const enrichmentSchema = z.object({
  summary: z.string().min(20).describe("The generated 2-3 sentence background summary."),
});

const createFallbackText = (person) => `This is a wealth profile for ${person.name}, a notable figure in the ${person.industry} sector, primarily associated with the company ${person.primaryCompany}. Their estimated wealth is approximately $${person.wealthMillionsUSD}M USD.`;

/**
 * Uses a robust, two-step AI process to generate a background summary for an individual
 * when no pre-written text is available, minimizing hallucination risk.
 * @param {object} person - A person object from the rich list.
 * @returns {Promise<{generated_background: string}>} The AI-generated or fallback text.
 */
export async function enrichThinProfile(person) {
  logger.info(`  -> AI Enrichment (2-Step): Verifying significance of ${person.name}...`);

  // --- STEP 1: NEUTRAL VERIFICATION ---
  const verificationPrompt = `You are a neutral fact-checker. Based on your general knowledge, is the following person a significant business figure (founder, CEO, major owner, etc.)? Provide a boolean answer and a brief, neutral summary of their primary role.

Respond ONLY with a valid JSON object: {"is_significant_figure": boolean, "verification_summary": "One sentence summary."}`;
  
  const verificationUserContent = `Person: ${person.name}\nCompany / Industry: ${person.primaryCompany}`;

  try {
    const verificationResponse = await callLanguageModel({
        modelName: settings.LLM_MODEL_UTILITY,
        systemPrompt: verificationPrompt,
        userContent: verificationUserContent,
        isJson: true,
    });

    const validation = verificationSchema.safeParse(verificationResponse);
    if (!validation.success || !validation.data.is_significant_figure) {
        logger.warn(`  -> Verification FAILED for ${person.name}. The AI did not recognize them as a significant business figure. Using fallback text.`);
        if(!validation.success) logger.error({ err: validation.error.flatten(), raw_response: verificationResponse }, 'Verification response failed Zod validation.');
        return { generated_background: createFallbackText(person) };
    }
    
    const verifiedSummary = validation.data.verification_summary;
    logger.info(`  -> Verification PASSED for ${person.name}: "${verifiedSummary}"`);

    // --- STEP 2: CONDITIONAL ENRICHMENT ---
    logger.info(`  -> AI Enrichment: Generating full background for verified figure ${person.name}...`);
    const enrichmentPrompt = `You are a financial biographer. You have already verified the subject's identity. Now, synthesize the verified summary with the provided private financial data to write a concise, professional background summary (2-3 sentences) suitable for a rich list publication. Focus on their business history, key achievements, and the source of their wealth.

Respond ONLY with a valid JSON object: {"summary": "Your generated text."}`;

    const enrichmentUserContent = `
        Verified Summary: "${verifiedSummary}"
        
        Private Financial Data:
        - Name: ${person.name}
        - Primary Company / Industry: ${person.primaryCompany} / ${person.industry}
        - Estimated Wealth: $${person.wealthMillionsUSD}M USD
        - Country: ${person.country}
    `;

    const enrichmentResponse = await callLanguageModel({
        modelName: settings.LLM_MODEL_UTILITY,
        systemPrompt: enrichmentPrompt,
        userContent: enrichmentUserContent,
        isJson: true,
    });
    
    const enrichmentValidation = enrichmentSchema.safeParse(enrichmentResponse);

    if (!enrichmentValidation.success) {
      logger.error({ err: enrichmentValidation.error.flatten(), raw_response: enrichmentResponse }, 'Enrichment response failed Zod validation.');
      throw new Error('AI enrichment response failed validation.');
    }

    // DEFINITIVE FIX: Log the final generated background.
    logger.info({ generated_background: enrichmentValidation.data.summary }, `Generated background for ${person.name}`);
    return { generated_background: enrichmentValidation.data.summary };

  } catch (error) {
    logger.error(
      { err: error },
      `Full AI enrichment process failed for ${person.name}. Using fallback text.`
    );
    return { generated_background: createFallbackText(person) };
  }
}

```

## 📄 scripts/seed/lib/event-chunker.js
*Lines: 120, Size: 4.16 KB*

```javascript
// apps/pipeline/scripts/seed/lib/event-chunker.js
import { callLanguageModel } from '../../../../../packages/ai-services/src/index.js'
import { settings } from '../../../../../packages/config/src/server.js'
// DEFINITIVE FIX: Import loggers from the shared utils package
import { logger, auditLogger } from '../../../../../packages/utils/src/server.js'
import { z } from 'zod'

const eventChunkSchema = z.object({
  events: z.array(
    z.object({
      date: z.string().describe('Estimated date of the event in YYYY-MM-DD format.'),
      description: z
        .string()
        .describe('A concise, one-sentence summary of the specific event.'),
      participants: z
        .array(z.string())
        .optional()
        .describe('List of key individuals or companies involved.'),
      type: z
        .string()
        .describe("The type of event (e.g., 'Sale', 'IPO', 'Wealth Profile')."),
    })
  ),
})

// --- REINFORCED PROMPT ---
const PROMPT = `You are a financial historian AI. Your task is to read a long biography of a wealthy individual and break it down into a timeline of distinct, significant wealth events.

**CRITICAL INSTRUCTIONS:**
1.  Read the entire background text provided.
2.  Identify specific, discrete events that impacted the person's wealth (e.g., company sales, major investments, IPOs, inheritance).
3.  For each event, extract the estimated date, a concise description, a list of key participants, and a simple event type string.
4.  If the text is a general profile without specific past events, you MUST create a single "Wealth Profile" event for the current year.
5.  Ignore non-financial events.

**OUTPUT FORMAT (MANDATORY):**
You MUST respond ONLY with a valid JSON object. This object MUST contain a single key called "events".
The value of "events" MUST be an ARRAY of event objects.

**EXAMPLE 1 (Multiple Events):**
{
  "events": [
    {
      "date": "1986-01-01",
      "description": "Faced legal issues regarding oil freight charges, but the case was later dropped.",
      "participants": ["John Fredriksen"],
      "type": "Legal Dispute"
    },
    {
      "date": "2007-01-01",
      "description": "Donated 50 million kroner to the Radium hospital for cancer research.",
      "participants": ["John Fredriksen"],
      "type": "Philanthropy"
    }
  ]
}

**EXAMPLE 2 (Single Event):**
{
  "events": [
    {
      "date": "2024-09-15",
      "description": "General wealth profile for a prominent figure in the Shipping industry.",
      "participants": ["John Fredriksen"],
      "type": "Wealth Profile"
    }
  ]
}

Your entire response must be ONLY the JSON object.`

const createFallbackEvent = (person) => {
  return [
    {
      date: `${person.year}-09-15`,
      description: `Wealth profile for ${person.name}, a prominent figure in the ${person.industry} sector with an estimated fortune of $${person.wealthMillionsUSD}M USD.`,
      participants: [person.name],
      type: 'Wealth Profile',
    },
  ]
}

export async function chunkHistoryIntoEvents(person) {
  logger.info(`  -> AI Event Chunker: Analyzing history for ${person.name}...`)
  try {
    auditLogger.info({ context: { background_text: person.background }}, `Event Chunker Input for ${person.name}`);
    const response = await callLanguageModel({
      modelName: settings.LLM_MODEL_UTILITY,
      systemPrompt: PROMPT,
      userContent: person.background,
      isJson: true,
    })
    auditLogger.info({ context: { llm_response: response }}, `Event Chunker Raw Output for ${person.name}`);

    const validation = eventChunkSchema.safeParse(response)
    if (!validation.success) {
      logger.error(
        { err: validation.error.flatten(), raw_response: response },
        'AI response failed Zod validation.'
      )
      return createFallbackEvent(person)
    }

    if (validation.data.events.length === 0) {
      return createFallbackEvent(person)
    }

    logger.info(
      `  -> AI Event Chunker: Identified ${validation.data.events.length} distinct event(s).`
    )
    return validation.data.events
  } catch (error) {
    logger.error(
      { err: error },
      `Event chunking failed for ${person.name}. Creating a single fallback event.`
    )
    return createFallbackEvent(person)
  }
}

```

## 📄 scripts/seed/lib/pipeline-injector.js
*Lines: 80, Size: 2.77 KB*

```javascript
// apps/pipeline/scripts/seed/lib/pipeline-injector.js
import { runAssessAndEnrich } from '../../../src/pipeline/3_assessAndEnrich.js'
import { runClusterAndSynthesize } from '../../../src/pipeline/4_clusterAndSynthesize.js'
import { judgeAndFilterOutput } from '../../../src/pipeline/submodules/commit/1_judgeOutput.js'
import { saveResultsToDb } from '../../../src/pipeline/submodules/commit/2_saveResults.js'
import { tokenTracker, apiCallTracker, logger } from '../../../../../packages/utils/src/server.js'
import { settings } from '../../../../../packages/config/src/server.js'

const FATAL_JUDGEMENT_QUALITIES = ['Irrelevant', 'Poor']

/**
 * Injects a synthetic article into the pipeline from Stage 3 onwards.
 * @param {object} syntheticArticle - The article object to process.
 * @returns {Promise<{savedEvents: Array, savedOpportunities: Array}>} The final saved data.
 */
export async function runInjectedPipeline(syntheticArticle) {
  tokenTracker.reset()
  apiCallTracker.reset()

  tokenTracker.initializeModels([
    settings.LLM_MODEL_HEADLINE_ASSESSMENT,
    settings.LLM_MODEL_ARTICLE_ASSESSMENT,
    settings.LLM_MODEL_SYNTHESIS,
    settings.LLM_MODEL_UTILITY,
  ])

  let payload = {
    articlesForPipeline: [syntheticArticle],
    runStats: {
      errors: [],
      synthesizedEventsForReport: [],
      enrichmentOutcomes: [],
      headlinesScraped: 0,
      scraperHealth: [],
      validatedHeadlines: 0,
      freshHeadlinesFound: 1,
      headlinesAssessed: 0,
      relevantHeadlines: 0,
      articlesEnriched: 0,
      relevantArticles: 0,
      eventsClustered: 0,
      eventsSynthesized: 0,
      judgeVerdict: null,
      eventsEmailed: 0,
      tokenUsage: {},
      apiCalls: {},
    },
  }

  logger.info('  -> Injecting into Stage 3: Assess & Enrich...')
  payload = (await runAssessAndEnrich(payload)).payload

  if (payload.enrichedArticles?.length > 0) {
    logger.info('  -> Injecting into Stage 4: Cluster & Synthesize...')
    payload = (await runClusterAndSynthesize(payload)).payload
  } else {
    logger.warn('  -> Skipping Stage 4: No articles were successfully enriched.')
  }

  logger.info('  -> Injecting into Stage 5 (Commit): Judging output...')
  const { finalEvents, finalOpportunities } = await judgeAndFilterOutput(
    payload,
    FATAL_JUDGEMENT_QUALITIES
  )

  logger.info('  -> Injecting into Stage 5 (Commit): Saving results to database...')
  const { savedEvents, savedOpportunities } = await saveResultsToDb(
    payload,
    finalEvents,
    finalOpportunities
  )

  // DEFINITIVE FIX: Convert the Mongoose documents to plain JSON before returning.
  // This ensures the calling script can access properties directly.
  return {
    savedEvents: JSON.parse(JSON.stringify(savedEvents)),
    savedOpportunities: JSON.parse(JSON.stringify(savedOpportunities)),
  }
}

```

## 📄 scripts/seed/lib/richlist-data-loader.js
*Lines: 82, Size: 2.74 KB*

```javascript
// apps/pipeline/scripts/seed/lib/richlist-data-loader.js
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import { Opportunity } from '../../../../../packages/models/src/index.js'
import { logger } from '../../../../../packages/utils/src/server.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const BASE_PATH = path.resolve(__dirname, '../../')

const cityToCountryMap = {
  Sveits: 'Switzerland',
  USA: 'United States',
  Kypros: 'Cyprus',
  Storbritannia: 'United Kingdom',
  Belgia: 'Belgium',
  Danmark: 'Denmark',
  Brasil: 'Brazil',
  Italia: 'Italy',
  Monaco: 'Monaco',
  Portugal: 'Portugal',
  Spania: 'Spain',
  Singapore: 'Singapore',
  Østerrike: 'Austria',
}

function getCountry(city) {
  return cityToCountryMap[city] || 'Norway'
}

function parseWealth(wealthStr) {
  if (!wealthStr || typeof wealthStr !== 'string') return 0
  const match = wealthStr.match(/([\d,]+)\s*mrd/)
  if (!match) return 0
  const cleaned = match[1].replace(/,/g, '.')
  const value = parseFloat(cleaned)
  return Math.round(value * 94)
}

export async function loadAndPrepareRichlist() {
  const jsonPath = path.join(BASE_PATH, 'seed/data/norway.json')
  const jsonData = JSON.parse(fs.readFileSync(jsonPath, 'utf8'))
  const allIndividuals = jsonData.individuals
  logger.info(
    `Loaded ${allIndividuals.length} total individuals from ${path.basename(jsonPath)}.`
  )

  const existingOppNames = (await Opportunity.find({}).select('reachOutTo').lean()).map(
    (o) => o.reachOutTo
  )
  const existingSet = new Set(existingOppNames)

  const preparedIndividuals = await Promise.all(allIndividuals.map(async (person) => {
    const background = person.scraped_data.background_information
    const isThinProfile = !background || background.trim().length < 50
    
    if (isThinProfile) {
        let reason = !background ? 'is null/undefined' : `is too short (${background.trim().length} chars)`;
        logger.trace({ person: person.name, reason }, `Identified as thin profile because background_information ${reason}.`);
    }

    const preparedPersonObject = {
      name: person.name,
      city: person.scraped_data.city,
      country: getCountry(person.scraped_data.city),
      industry: person.industry,
      wealthMillionsUSD: parseWealth(person.scraped_data.current_wealth),
      background: isThinProfile ? null : background,
      wealthSummary: person.scraped_data.wealth_summary,
      primaryCompany: person.scraped_data.roles?.[0]?.company || person.industry,
      year: jsonData.list_metadata.year,
      isExisting: existingSet.has(person.name),
      isThinProfile,
    };

    return preparedPersonObject;
  }));

  return { allIndividuals: preparedIndividuals, rawIndividualData: allIndividuals };
}

```

## 📄 scripts/seed/lib/script-init.js
*Lines: 35, Size: 1.39 KB*

```javascript
// apps/pipeline/scripts/lib/script-init.js
import { logger } from '../../../../../packages/utils/src/server.js'
import { configure as configureScraperLogic } from '@headlines/scraper-logic/config.js'
import * as appConfig from '../../../../../packages/config/src/server.js'
import { refreshConfig, configStore } from '../../../src/config/dynamicConfig.js'
import { initializeSettings, settings } from '../../../../../packages/config/src/server.js'
import dbConnect from '../../../../../packages/data-access/src/dbConnect.js'
import * as aiServices from '../../../../../packages/ai-services/src/index.js'

let isInitialized = false

/**
 * Connects to DB, loads static and dynamic config, and configures shared packages.
 * This is the standard initialization routine for any standalone pipeline script.
 */
export async function initializeScriptEnv() {
  if (isInitialized) return

  await dbConnect()
  await initializeSettings()
  await refreshConfig()

  const utilityFunctions = {
    findAlternativeSources: aiServices.findAlternativeSources,
    findNewsApiArticlesForEvent: aiServices.findNewsApiArticlesForEvent,
    performGoogleSearch: aiServices.performGoogleSearch,
    fetchWikipediaSummary: aiServices.fetchWikipediaSummary,
  }

  configureScraperLogic({ ...appConfig, configStore, utilityFunctions, logger, settings })

  isInitialized = true
  logger.info('✅ Script environment initialized successfully.')
}

```

## 📄 scripts/seed/lib/synthetic-article-builder.js
*Lines: 39, Size: 1.51 KB*

```javascript
// apps/pipeline/scripts/seed/lib/synthetic-article-builder.js
import mongoose from 'mongoose'

/**
 * Creates a synthetic article object from a prepared rich list individual and a specific event chunk.
 * @param {object} person - A prepared individual object from the data loader.
 * @param {object} eventChunk - An event chunk from the AI event chunker.
 * @returns {object} A synthetic article object.
 */
export function createSyntheticArticle(person, eventChunk) {
  const headline = `Event Profile: ${eventChunk.type} involving ${eventChunk.participants.join(', ')}`
  // Combine the specific event description with the general background for rich context
  const content = `An analysis of a specific wealth event involving ${person.name}.
Event Type: ${eventChunk.type}
Event Date: ${eventChunk.date}
Event Description: ${eventChunk.description}

General Background Context:
${person.background}
${person.wealthSummary || ''}`

  // Create a unique link based on the person and a hash of the event description
  const eventHash = new mongoose.Types.ObjectId().toString().slice(-6)
  const link = `https://richlist.norway/${person.name.toLowerCase().replace(/\s+/g, '-')}-${eventChunk.date}-${eventHash}`

  return {
    _id: new mongoose.Types.ObjectId(),
    headline,
    link,
    newspaper: `Kapital Rich List ${person.year}`,
    source: 'Richlist Ingestion',
    country: person.country,
    createdAt: new Date(eventChunk.date),
    articleContent: { contents: [content] },
    relevance_headline: 100,
    status: 'scraped',
  }
}

```

## 📄 scripts/seed/lib/user-interact.js
*Lines: 44, Size: 1.23 KB*

```javascript
// apps/pipeline/scripts/seed/lib/user-interact.js
import readline from 'readline'

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

/**
 * Prompts the user for a y/n/a response.
 * @param {string} query - The question to ask the user.
 * @returns {Promise<string>} - A promise that resolves to 'y', 'n', or 'a'.
 */
export function promptUser(query) {
  return new Promise((resolve) => {
    const ask = () => {
      // Use a small timeout to allow any buffered logger output to flush first.
      setTimeout(() => {
        // Clear the current line and move cursor to the beginning before asking.
        readline.clearLine(process.stdout, 0)
        readline.cursorTo(process.stdout, 0)

        rl.question(query, (answer) => {
          const response = answer.trim().toLowerCase()
          if (['y', 'n', 'a'].includes(response)) {
            resolve(response)
          } else {
            console.log('Invalid input. Please enter "y", "n", or "a".')
            ask()
          }
        })
      }, 100) // 100ms delay is usually sufficient.
    }
    ask()
  })
}

/**
 * Closes the readline interface. Should be called when the script is finished.
 */
export function closeReader() {
  rl.close()
}

```

## 📄 scripts/seed/seed-admin-user.js
*Lines: 56, Size: 2.09 KB*

```javascript
// apps/pipeline/scripts/seed/seed-admin-user.js (version 4.0.0 - Model-driven)
import { reinitializeLogger as initializeLogger, logger } from '../../../../packages/utils/src/server.js';
import path from 'path';
import { Subscriber, Country } from '../../../../packages/models/src/index.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import mongoose from 'mongoose';

initializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'));

const ADMIN_EMAIL = process.env.ADMIN_EMAIL;
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD;
const ADMIN_FIRST_NAME = process.env.ADMIN_FIRST_NAME || 'Admin';

async function seedAdminUser() {
  if (!ADMIN_EMAIL || !ADMIN_PASSWORD) {
    logger.fatal('❌ ADMIN_EMAIL and ADMIN_PASSWORD must be set in your .env file.');
    return;
  }

  await dbConnect();
  logger.info(`🚀 Seeding Admin User: ${ADMIN_EMAIL}...`);
  try {
    const existingUser = await Subscriber.findOne({ email: ADMIN_EMAIL });
    const allCountries = await Country.find({ status: 'active' }).select('name').lean();
    const countrySubscriptions = allCountries.map((c) => ({ name: c.name, active: true }));

    if (existingUser) {
      logger.warn('Admin user already exists. Overwriting password and ensuring settings are correct.');
      existingUser.password = ADMIN_PASSWORD; // The pre-save hook will hash this
      await existingUser.save();
      logger.info(`✅ Admin user password has been reset and saved.`);
    } else {
      const newUser = new Subscriber({
        email: ADMIN_EMAIL,
        password: ADMIN_PASSWORD, // The pre-save hook will hash this
        firstName: ADMIN_FIRST_NAME,
        role: 'admin',
        isActive: true,
        countries: countrySubscriptions,
        subscriptionTier: 'enterprise',
        isLifetimeFree: true,
      });
      await newUser.save();
      logger.info(`✅ Admin user created successfully.`);
    }
  } catch (error) {
    logger.fatal({ err: error }, '❌ Admin user seeding failed.');
  } finally {
    if (mongoose.connection.readyState === 1) {
      await mongoose.disconnect();
    }
  }
}

seedAdminUser();

```

## 📄 scripts/seed/seed-countries.js
*Lines: 46, Size: 1.74 KB*

```javascript
// apps/pipeline/scripts/seed/seed-countries.js (version 2.3.0)
import { reinitializeLogger as initializeLogger, logger } from '../../../../packages/utils/src/server.js';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import { Country } from '../../../../packages/models/src/index.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import mongoose from 'mongoose';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
initializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'));

function loadCountriesFromFile() {
    const filePath = path.resolve(__dirname, '../../../../packages/utils/src/data/countries.json');
    const fileContent = fs.readFileSync(filePath, 'utf8');
    const countryData = JSON.parse(fileContent);
    return Object.entries(countryData).map(([name, isoCode]) => ({ name, isoCode }));
}

async function seedCountries() {
  await dbConnect();
  logger.info('🚀 Seeding Countries from canonical JSON file...');
  const countriesToSeed = loadCountriesFromFile();
  try {
    const bulkOps = countriesToSeed.map((country) => ({
      updateOne: {
        filter: { name: country.name },
        update: { $set: { isoCode: country.isoCode.substring(0,2) }, $setOnInsert: { name: country.name, status: 'active' } },
        upsert: true,
      },
    }));

    const result = await Country.bulkWrite(bulkOps);
    logger.info(`✅ Country seeding complete. ${result.upsertedCount} new countries added, ${result.modifiedCount} updated.`);
  } catch (error) {
    logger.fatal({ err: error }, '❌ Country seeding failed.');
  } finally {
    if (mongoose.connection.readyState === 1) {
      await mongoose.disconnect();
    }
  }
}

seedCountries();

```

## 📄 scripts/seed/seed-settings.js
*Lines: 151, Size: 4.44 KB*

```javascript
// apps/pipeline/scripts/seed/seed-settings.js (version 1.8.0)
import { reinitializeLogger, logger } from '../../../../packages/utils/src/server.js'
import path from 'path'
import { Setting } from '../../../../packages/models/src/index.js'
import dbConnect from '../../../../packages/data-access/src/dbConnect.js'
import mongoose from 'mongoose'

// Initialize logger for this specific script run
reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'))

const SETTINGS = [
  {
    key: 'HEADLINES_RELEVANCE_THRESHOLD',
    // DEFINITIVE FIX: Lowered from 35 to 25 to widen the funnel and reduce missed articles.
    value: 25,
    description: 'Minimum score (0-100) for a headline to be considered for enrichment.',
    type: 'number',
  },
  {
    key: 'ARTICLES_RELEVANCE_THRESHOLD',
    // FUNNEL WIDENING: Lowered from 50 to 45 to investigate high drop-off rate.
    value: 45,
    description:
      'Minimum score (0-100) for an enriched article to be considered a valid event signal.',
    type: 'number',
  },
  {
    key: 'EVENT_RELEVANCE_THRESHOLD',
    // FUNNEL WIDENING: Lowered from 59 to 55 to capture more borderline events.
    value: 55,
    description:
      'Minimum score for a synthesized event to be saved and sent in notifications.',
    type: 'number',
  },
  {
    key: 'MINIMUM_EVENT_AMOUNT_USD_MILLIONS',
    value: 20,
    description: 'Events with a detected financial amount below this will be dropped.',
    type: 'number',
  },
  {
    key: 'HIGH_SIGNAL_HEADLINE_THRESHOLD',
    value: 90,
    description:
      'Headlines scoring above this are considered high-signal and trigger special processing if content scraping fails.',
    type: 'number',
  },
  {
    key: 'AGENT_DISAGREEMENT_THRESHOLD',
    value: 50,
    description:
      'If headline score and article score differ by more than this, it is flagged as a disagreement.',
    type: 'number',
  },
  {
    key: 'SINGLETON_RELEVANCE_THRESHOLD',
    value: 85,
    description:
      'An article that does not cluster with others must meet this score to be processed as a standalone event.',
    type: 'number',
  },
  {
    key: 'HIGH_VALUE_DEAL_USD_MM',
    value: 50,
    description:
      'AI Prompt: The dollar amount (in millions) that defines a "high value" M&A deal.',
    type: 'number',
  },
  {
    key: 'SIGNIFICANT_PRIVATE_BENEFICIARY_USD_MM',
    value: 30,
    description:
      'AI Prompt: The wealth threshold (in millions) for extracting an individual as a key contact.',
    type: 'number',
  },
  {
    key: 'WATCHLIST_SCORE_BOOST',
    value: 35,
    description:
      "The number of points to add to a headline's relevance score if it matches a watchlist entity.",
    type: 'number',
  },
  {
    key: 'SUGGESTION_GENERATION_THRESHOLD',
    value: 80,
    description:
      'The minimum event score required to trigger the AI to look for new watchlist suggestions.',
    type: 'number',
  },
  {
    key: 'MIN_ARTICLE_CHARS',
    value: 100,
    description:
      'The minimum number of characters required for scraped article content to be considered valid.',
    type: 'number',
  },
  {
    key: 'LLM_MODEL_HEADLINE_ASSESSMENT',
    value: 'gpt-5-mini',
    description: 'LLM model used for the initial, high-volume headline assessment stage.',
    type: 'string',
  },
  {
    key: 'LLM_MODEL_ARTICLE_ASSESSMENT',
    value: 'gpt-5-mini',
    description: 'LLM model used for full article analysis and enrichment.',
    type: 'string',
  },
  {
    key: 'LLM_MODEL_SYNTHESIS',
    value: 'gpt-5-mini',
    description:
      'LLM model used for clustering, synthesis, and other high-level reasoning tasks.',
    type: 'string',
  },
  {
    key: 'LLM_MODEL_UTILITY',
    value: 'gpt-5-nano',
    description:
      'A smaller, faster model for simple, utility-focused tasks like classification or extraction.',
    type: 'string',
  },
]

async function seedSettings() {
  await dbConnect()
  logger.info('🚀 Seeding Pipeline Settings...')
  try {
    const bulkOps = SETTINGS.map((setting) => ({
      updateOne: {
        filter: { key: setting.key },
        update: { $setOnInsert: setting },
        upsert: true,
      },
    }))

    const result = await Setting.bulkWrite(bulkOps)
    logger.info(
      `✅ Settings seeding complete. ${result.upsertedCount} new settings added.`
    )
  } catch (error) {
    logger.fatal({ err: error }, '❌ Settings seeding failed.')
  } finally {
    if (mongoose.connection.readyState === 1) {
      await mongoose.disconnect()
    }
  }
}

seedSettings()

```

## 📄 scripts/seed/seed-test-user.js
*Lines: 60, Size: 2.49 KB*

```javascript
// apps/pipeline/scripts/seed/seed-test-user.js
import mongoose from 'mongoose';
import bcrypt from 'bcrypt';
import { env } from '../../../../packages/config/src/server.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import { Subscriber } from '../../../../packages/models/src/index.js';
import { logger, reinitializeLogger } from '../../../../packages/utils/src/server.js';
import path from 'path';

reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'));

const TEST_USER_EMAIL = 'casagerardon@gmail.com';
const TEST_USER_PASSWORD = 'Stanley';

async function createTestUser() {
    await dbConnect();
    logger.info(`🚀 Seeding configured test user: ${TEST_USER_EMAIL}...`);
    
    try {
        const countriesForSubscription = ['Norway', 'United States', 'Italy', 'Denmark', 'Sweden', 'Global', 'Scandinavia'];
        const existingUser = await Subscriber.findOne({ email: TEST_USER_EMAIL });

        if (existingUser) {
            logger.warn('🔄 Test user already exists. Ensuring subscriptions and active status are correct...');
            existingUser.isActive = true;
            existingUser.emailNotificationsEnabled = true;
            
            const existingCountries = new Set(existingUser.countries.map(c => c.name));
            countriesForSubscription.forEach(country => {
                if (!existingCountries.has(country)) {
                    existingUser.countries.push({ name: country, active: true });
                }
            });
            await existingUser.save();
            logger.info(`✅ User '${TEST_USER_EMAIL}' updated and is subscribed to all necessary countries.`);
        } else {
            const newUser = new Subscriber({
                email: TEST_USER_EMAIL,
                password: TEST_USER_PASSWORD,
                firstName: 'Test',
                lastName: 'Recipient',
                isActive: true,
                emailNotificationsEnabled: true,
                countries: countriesForSubscription.map(name => ({ name, active: true })),
            });
            await newUser.save();
            logger.info(`✅ New test user '${TEST_USER_EMAIL}' created and subscribed to necessary countries.`);
        }
    } catch (error) {
        logger.error({ err: error }, '❌ Failed to create or update test user.');
    } finally {
        if (mongoose.connection.readyState === 1) {
            await mongoose.disconnect();
            logger.info('Disconnected from MongoDB.');
        }
    }
}

createTestUser();

```

## 📄 scripts/seed/sync-test-user-subscriptions.js
*Lines: 48, Size: 1.79 KB*

```javascript
// apps/pipeline/scripts/seed/sync-test-user-subscriptions.js
import mongoose from 'mongoose';
import { env } from '../../../../packages/config/src/server.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import { Subscriber, Country } from '../../../../packages/models/src/index.js';
import { logger, reinitializeLogger } from '../../../../packages/utils/src/server.js';
import path from 'path';

reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'));

const TEST_USER_EMAIL = 'casagerardon@gmail.com';

async function syncUserSubscriptions() {
    await dbConnect();
    logger.info(`🚀 Syncing subscriptions for test user: ${TEST_USER_EMAIL}...`);
    
    try {
        const user = await Subscriber.findOne({ email: TEST_USER_EMAIL });

        if (!user) {
            logger.error(`❌ User with email '${TEST_USER_EMAIL}' not found. Please run the 'db:seed:test-user' script first.`);
            return;
        }

        const activeCountries = await Country.find({ status: 'active' }).select('name').lean();
        if (activeCountries.length === 0) {
            logger.warn('⚠️ No active countries found in the database.');
            return;
        }

        const activeCountryNames = activeCountries.map(c => c.name);
        user.countries = activeCountryNames.map(name => ({ name, active: true }));

        await user.save();
        logger.info(`✅ User '${TEST_USER_EMAIL}' is now subscribed to all ${activeCountryNames.length} active countries.`);

    } catch (error) {
        logger.error({ err: error }, '❌ Failed to sync user subscriptions.');
    } finally {
        if (mongoose.connection.readyState === 1) {
            await mongoose.disconnect();
            logger.info('Disconnected from MongoDB.');
        }
    }
}

syncUserSubscriptions();

```

## 📄 scripts/sources/analyze-sources.js
*Lines: 93, Size: 3.43 KB*

```javascript
// scripts/sources/analyze-sources.js (version 1.0)
import 'dotenv/config'
import yargs from 'yargs'
import { hideBin } from 'yargs/helpers'
import { logger } from '@headlines/utils/src/logger.js'
import { connectDatabase, disconnectDatabase } from '../../src/database.js'
import { scrapeSiteForHeadlines } from '../../src/modules/scraper/headlineScraper.js'
import { suggestNewSelector } from '../../src/modules/ai/agents/selectorRepairAgent.js'
import Source from '../../models/Source.js'

logger.level = 'warn' // Keep console clean for this focused tool

async function main() {
  const argv = yargs(hideBin(process.argv))
    .usage('Usage: $0 --source <SourceName> [--fix]')
    .option('source', {
      alias: 's',
      type: 'string',
      description: 'The name of the source to analyze and fix.',
      demandOption: true,
    })
    .option('fix', {
      alias: 'f',
      type: 'boolean',
      description: 'Attempt to automatically verify and apply the AI-suggested fix.',
      default: false,
    }).argv

  console.log(`\n🔎 Analyzing source: "${argv.source}"...`)

  try {
    await connectDatabase()
    const source = await Source.findOne({ name: new RegExp(`^${argv.source}$`, 'i') })
    if (!source) {
      console.error(`❌ Source "${argv.source}" not found.`)
      return
    }

    console.log(`- Current headline selector: "${source.headlineSelector}"`)
    const initialScrape = await scrapeSiteForHeadlines(source)

    if (initialScrape.success && initialScrape.resultCount > 0) {
      console.log(`✅ This source appears to be healthy. Found ${initialScrape.resultCount} headlines.`)
      return
    }

    console.log(`\n⚠️ Source is failing. Reason: ${initialScrape.error}`)
    if (!initialScrape.debugHtml) {
      console.error('❌ Cannot proceed with analysis: Failed to retrieve page HTML.')
      return
    }

    console.log('🤖 Asking AI agent to suggest a new selector...')
    const suggestion = await suggestNewSelector(
      source.sectionUrl,
      source.headlineSelector,
      initialScrape.debugHtml
    )

    if (!suggestion || !suggestion.suggested_selector) {
      console.error('❌ AI agent failed to provide a suggestion.')
      return
    }

    console.log(`\n💡 AI Suggestion:`)
    console.log(`   - New Selector: "${suggestion.suggested_selector}"`)
    console.log(`   - Reasoning: "${suggestion.reasoning}"`)

    if (argv.fix) {
      console.log('\n🔧 --fix flag enabled. Verifying and applying the fix...')
      const tempSource = { ...source.toObject(), headlineSelector: suggestion.suggested_selector }
      const verificationScrape = await scrapeSiteForHeadlines(tempSource)

      if (verificationScrape.success && verificationScrape.resultCount > 0) {
        console.log(`   - ✅ Verification successful! Found ${verificationScrape.resultCount} headlines with the new selector.`)
        source.headlineSelector = suggestion.suggested_selector
        await source.save()
        console.log('   - 💾 New selector has been saved to the database.')
      } else {
        console.log(`   - ❌ Verification failed. The suggested selector did not return any headlines.`)
        console.log(`   - Reason: ${verificationScrape.error}`)
      }
    } else {
      console.log('\nRun with the --fix flag to automatically apply and save the new selector.')
    }
  } catch (error) {
    console.error(`💥 A critical error occurred: ${error.message}`)
  } finally {
    await disconnectDatabase()
  }
}

main()
```

## 📄 scripts/sources/browse.js
*Lines: 127, Size: 4.56 KB*

```javascript
// apps/pipeline/scripts/sources/browse.js (version 1.0)
import readline from 'readline';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import * as cheerio from 'cheerio';
import { fetchPageWithPlaywright } from '@headlines/scraper-logic/src/browser.js';
import { heuristicallyFindSelectors } from '@headlines/scraper-logic/src/scraper/selectorOptimizer.js';
import { sectionClassifierAgent } from '@headlines/scraper-logic/src/ai/index.js';
import { logger } from '../../../../packages/utils/src/server.js';
undefined

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const color = {
  reset: "\x1b[0m",
  green: "\x1b[32m",
  cyan: "\x1b[36m",
  yellow: "\x1b[33m",
  magenta: "\x1b[35m",
  gray: "\x1b[90m"
};

let currentUrl = '';
let currentLinks = [];

async function listLinks(url) {
    logger.info(`Crawling ${url}...`);
    const html = await fetchPageWithPlaywright(url, 'SourceBrowser');
    if (!html) {
        logger.error("Failed to fetch page.");
        return;
    }
    const $ = cheerio.load(html);
    const baseUrlObj = new URL(url);
    const linksToClassify = [];
    $('a').each((_, el) => {
        const $el = $(el);
        const href = $el.attr('href');
        const text = $el.text().trim().replace(/\s+/g, ' ');
        if (href && text && !href.startsWith('#') && !href.startsWith('mailto:')) {
            try {
                const fullUrl = new URL(href, baseUrlObj.origin).href;
                linksToClassify.push({ text, href: fullUrl });
            } catch (e) { /* ignore */ }
        }
    });

    const uniqueLinks = [...new Map(linksToClassify.map(item => [item.href, item])).values()];
    logger.info(`Found ${uniqueLinks.length} links. Classifying with AI...`);
    const classifications = await sectionClassifierAgent(uniqueLinks.map(l => ({text: l.text, href: l.href})));
    if (!classifications) {
        logger.error("AI classification failed.");
        currentLinks = [];
        return;
    }

    currentLinks = uniqueLinks.map((link, i) => ({ ...link, type: classifications[i].classification }));
    
    currentLinks.forEach((link, i) => {
        let typeColor = color.gray;
        if (link.type === 'news_section') typeColor = color.yellow;
        if (link.type === 'article_headline') typeColor = color.cyan;
        console.log(`[${i.toString().padStart(2)}] ${typeColor}[${link.type.padEnd(16)}]${color.reset} ${link.text.substring(0, 80)}`);
        console.log(`    ${color.gray}${link.href}${color.reset}`);
    });
}

async function handleCommand(command) {
    const parts = command.trim().split(' ');
    const cmd = parts[0].toLowerCase();
    const arg = parts.slice(1).join(' ');

    switch (cmd) {
        case 'ls':
            await listLinks(currentUrl);
            break;
        case 'cd':
            const newUrl = !isNaN(arg) && currentLinks[parseInt(arg, 10)] ? currentLinks[parseInt(arg, 10)].href : arg;
            if (newUrl) {
                currentUrl = newUrl;
                console.log(`Changed directory to: ${currentUrl}`);
                await listLinks(currentUrl);
            } else {
                console.log("Invalid argument. Use 'cd <url>' or 'cd <index>'.");
            }
            break;
        case 'optimize':
            logger.info(`Optimizing selectors for ${currentUrl}...`);
            const html = await fetchPageWithPlaywright(currentUrl, 'SourceBrowser');
            const suggestions = heuristicallyFindSelectors(html);
            suggestions.forEach((cluster, i) => {
                console.log(`--- Suggestion #${i + 1} (Score: ${cluster.score}) ---`);
                console.log(`Selector: ${color.green}${cluster.selector}${color.reset}`);
                console.log(`Samples:`);
                cluster.samples.slice(0, 3).forEach(sample => console.log(`  - "${sample}"`));
            });
            break;
        case 'help':
            console.log("Commands: ls, cd <url|index>, optimize, exit, help");
            break;
        case 'exit':
            rl.close();
            return;
        default:
            console.log("Unknown command. Type 'help'.");
    }
    prompt();
}

function prompt() {
    const promptPath = new URL(currentUrl).pathname;
    rl.question(`${color.magenta}${promptPath}>${color.reset} `, handleCommand);
}

async function main() {
    const argv = yargs(hideBin(process.argv)).option('url', { type: 'string', demandOption: true }).help().argv;
    currentUrl = argv.url;
    console.log("Welcome to the Interactive Source Browser. Type 'help' for commands.");
    await listLinks(currentUrl);
    prompt();
}

main();

```

## 📄 scripts/sources/check-danish-sources.js
*Lines: 252, Size: 7.16 KB*

```javascript
// scripts/check-danish-sources.js
import fs from 'fs'
import path from 'path'
import Papa from 'papaparse'
import cliProgress from 'cli-progress'
import colors from 'ansi-colors'

const DATA_DIRECTORY = '/mnt/ramdisk'

// GDELT GKG headers
const GKG_HEADERS = [
  'GKGRECORDID',
  'Date',
  'SourceCollectionIdentifier',
  'SourceCommonName',
  'DocumentIdentifier',
  'V1Themes',
  'V2Themes',
  'V1Locations',
  'V2Locations',
  'V1Persons',
  'V2Persons',
  'V1Organizations',
  'V2Organizations',
  'V1_5Tone',
  'V2Tone',
  'Dates',
  'GCAM',
  'SharingImage',
  'RelatedImages',
  'SocialImageEmbeds',
  'SocialVideoEmbeds',
  'Quotations',
  'AllNames',
  'Amounts',
  'TranslationInfo',
  'Extras',
]

// Specific Danish sources we're looking for
const TARGET_DANISH_SOURCES = [
  'detelegraaf',
  'berlingske.dk',
  'finans.dk',
  'politiken.dk',
  'dr.dk',
  'tv2.dk',
  'bt.dk',
  'eb.dk',
  'jyllands-posten.dk',
  'information.dk',
  'kristeligt-dagblad.dk',
  'weekendavisen.dk',
]

async function checkDanishSources() {
  const files = fs.readdirSync(DATA_DIRECTORY).filter((f) => f.endsWith('.csv'))

  if (files.length === 0) {
    console.log('No CSV files found in', DATA_DIRECTORY)
    return
  }

  console.log(`🔍 Checking ${files.length} GDELT files for specific Danish sources...`)
  console.log(`Target sources: ${TARGET_DANISH_SOURCES.join(', ')}`)
  console.log(`Data directory: ${DATA_DIRECTORY}\n`)

  let totalRows = 0
  let foundSources = new Map() // source -> count
  let sourceExamples = new Map() // source -> example URLs
  let fileHits = new Map() // file -> hits count

  const progressBar = new cliProgress.SingleBar({
    format: `  -> Processing | ${colors.cyan('{bar}')} | {percentage}% || {value}/{total} Files`,
    barCompleteChar: '\u2588',
    barIncompleteChar: '\u2591',
    hideCursor: true,
  })

  progressBar.start(files.length, 0)

  for (const file of files) {
    const filePath = path.join(DATA_DIRECTORY, file)
    let fileContent

    try {
      fileContent = fs.readFileSync(filePath, 'utf8')
    } catch (error) {
      console.log(`\nError reading file ${file}:`, error.message)
      progressBar.increment()
      continue
    }

    const result = Papa.parse(fileContent, {
      delimiter: '\t',
      header: false,
      skipEmptyLines: true,
      dynamicTyping: false,
    })

    let fileHitCount = 0

    for (const record of result.data) {
      if (!record || record.length < GKG_HEADERS.length) continue

      totalRows++

      // Map headers to row data
      const row = {}
      GKG_HEADERS.forEach((header, i) => {
        row[header] = record[i] || ''
      })

      // Check both SourceCommonName and DocumentIdentifier for Danish sources
      const sourceName = (row.SourceCommonName || '').toLowerCase()
      const documentUrl = (row.DocumentIdentifier || '').toLowerCase()

      for (const targetSource of TARGET_DANISH_SOURCES) {
        const targetLower = targetSource.toLowerCase()

        if (sourceName.includes(targetLower) || documentUrl.includes(targetLower)) {
          foundSources.set(targetSource, (foundSources.get(targetSource) || 0) + 1)
          fileHitCount++

          // Store example URL for this source
          if (!sourceExamples.has(targetSource) && documentUrl) {
            sourceExamples.set(targetSource, documentUrl)
          }
          break // Found a match, no need to check other sources
        }
      }
    }

    if (fileHitCount > 0) {
      fileHits.set(file, fileHitCount)
    }

    progressBar.increment()
  }

  progressBar.stop()

  console.log('\n📊 Results:')
  console.log(`Total articles processed: ${totalRows.toLocaleString()}`)
  console.log(`Files with Danish sources: ${fileHits.size}/${files.length}`)
  console.log('')

  // Display found sources
  if (foundSources.size === 0) {
    console.log('❌ No articles from the specified Danish sources found!')
    console.log('')
    console.log('Possible reasons:')
    console.log('1. The GDELT files might not contain these specific sources')
    console.log('2. The sources might use different domain patterns')
    console.log('3. The time period might not have coverage from these sources')
    console.log('4. There might be encoding/parsing issues')
  } else {
    console.log('✅ Found articles from these Danish sources:')
    console.log('')

    const sortedSources = Array.from(foundSources.entries()).sort((a, b) => b[1] - a[1])

    for (const [source, count] of sortedSources) {
      const exampleUrl = sourceExamples.get(source) || 'No URL example'
      console.log(`📰 ${source.padEnd(20)}: ${count.toString().padStart(4)} articles`)
      console.log(
        `   Example: ${exampleUrl.substring(0, 80)}${exampleUrl.length > 80 ? '...' : ''}`
      )
      console.log('')
    }

    // Show which files contained Danish sources
    console.log('📁 Files containing Danish sources:')
    const sortedFiles = Array.from(fileHits.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10) // Show top 10 files

    for (const [file, count] of sortedFiles) {
      console.log(`   ${file}: ${count} articles`)
    }

    if (fileHits.size > 10) {
      console.log(`   ... and ${fileHits.size - 10} more files`)
    }
  }

  // Additional diagnostic: Check for any .dk domains
  console.log('\n🔍 Scanning for ANY .dk domains (broader search)...')

  let dkDomainsFound = new Map()
  let sampleDkUrls = new Map()

  for (const file of files.slice(0, 105)) {
    // Check first 5 files for speed
    const filePath = path.join(DATA_DIRECTORY, file)
    try {
      const content = fs.readFileSync(filePath, 'utf8')
      const lines = content.split('\n')

      for (const line of lines.slice(0, 1000)) {
        // Check first 1000 lines
        const columns = line.split('\t')
        if (columns.length >= 5) {
          const source = (columns[3] || '').toLowerCase() // SourceCommonName
          const url = (columns[4] || '').toLowerCase() // DocumentIdentifier

          if (source.includes('.dk') || url.includes('.dk')) {
            // Extract domain
            let domain = null
            if (url.includes('.dk')) {
              const match = url.match(/([a-zA-Z0-9-]+\.dk)/)
              if (match) domain = match[1]
            }
            if (!domain && source.includes('.dk')) {
              const match = source.match(/([a-zA-Z0-9-]+\.dk)/)
              if (match) domain = match[1]
            }

            if (domain) {
              dkDomainsFound.set(domain, (dkDomainsFound.get(domain) || 0) + 1)
              if (!sampleDkUrls.has(domain)) {
                sampleDkUrls.set(domain, url)
              }
            }
          }
        }
      }
    } catch (error) {
      // Skip file errors
    }
  }

  if (dkDomainsFound.size > 0) {
    console.log('\n🌐 Found these .dk domains in the data:')
    const sortedDkDomains = Array.from(dkDomainsFound.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 15)

    for (const [domain, count] of sortedDkDomains) {
      console.log(`   ${domain.padEnd(25)}: ${count} occurrences`)
    }
  } else {
    console.log('   No .dk domains found in sample scan')
  }
}

// Run the analysis
checkDanishSources().catch((error) => {
  console.error('❌ Analysis failed:', error.message)
  process.exit(1)
})

```

## 📄 scripts/sources/discover.js
*Lines: 110, Size: 4.02 KB*

```javascript
// apps/pipeline/scripts/sources/discover-sections.js (version 2.0)
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import * as cheerio from 'cheerio';
import { fetchPageWithPlaywright } from '@headlines/scraper-logic/src/browser.js';
import { heuristicallyFindSelectors } from '@headlines/scraper-logic/src/scraper/selectorOptimizer.js';
import { sectionClassifierAgent } from '@headlines/scraper-logic/src/ai/index.js';
import { logger } from '../../../../packages/utils/src/server.js';
import pLimit from 'p-limit';

const CONCURRENCY = 3;

async function main() {
  const argv = yargs(hideBin(process.argv))
    .usage('Usage: $0 --url <URL>')
    .option('url', {
      alias: 'u',
      type: 'string',
      description: 'The base URL of the news site to discover sections from.',
      demandOption: true,
    }).argv;

  const baseUrl = argv.url;
  const baseUrlObj = new URL(baseUrl);
  logger.info(`🔎 Discovering news sections for: ${baseUrl} (AI-Powered)`);

  const html = await fetchPageWithPlaywright(baseUrl, 'SectionDiscoverer');
  if (!html) {
    logger.error('Failed to fetch base page content. Aborting.');
    return;
  }

  const $ = cheerio.load(html);
  const allLinks = [];
  $('a').each((_, el) => {
    const $el = $(el);
    const href = $el.attr('href');
    const text = $el.text().trim().replace(/\s+/g, ' ');

    if (href && text && !href.startsWith('#') && !href.startsWith('mailto:')) {
      try {
        const fullUrl = new URL(href, baseUrl).href;
        if (new URL(fullUrl).hostname.endsWith(baseUrlObj.hostname)) {
          allLinks.push({ text, href: fullUrl });
        }
      } catch (e) { /* ignore invalid URLs */ }
    }
  });

  const uniqueLinks = [...new Map(allLinks.map(item => [item.href, item])).values()];
  logger.info(`Found ${uniqueLinks.length} unique internal links. Classifying with AI...`);

  const classifications = await sectionClassifierAgent(uniqueLinks);
  if (!classifications) {
    logger.error('AI link classification failed. Aborting.');
    return;
  }

  const topCandidates = uniqueLinks
    .map((link, i) => ({ ...link, classification: classifications[i].classification }))
    .filter(link => link.classification === 'news_section');

  if (topCandidates.length === 0) {
      logger.warn('AI analysis did not identify any promising "news_section" links.');
      return;
  }
  
  logger.info(`AI identified ${topCandidates.length} promising sections. Verifying for headlines...`);
  
  const limit = pLimit(CONCURRENCY);
  const verificationPromises = topCandidates.map(section => 
    limit(async () => {
      logger.info(`  ...verifying ${section.href}`);
      const sectionHtml = await fetchPageWithPlaywright(section.href, 'SectionVerifier');
      if (!sectionHtml) return null;
      const suggestions = heuristicallyFindSelectors(sectionHtml);
      if (suggestions.length > 0) {
        return {
          url: section.href,
          title: section.text,
          headlineConfidence: suggestions[0].score.toFixed(2),
          suggestedSelector: suggestions[0].selector,
          sampleHeadlines: suggestions[0].samples.slice(0, 2),
        };
      }
      return null;
    })
  );

  const verifiedSections = (await Promise.all(verificationPromises)).filter(Boolean);

  if (verifiedSections.length === 0) {
    logger.warn('Could not verify any AI-suggested sections with a high confidence of headlines.');
    return;
  }
  
  logger.info(`\n✅ Discovery Complete. Found ${verifiedSections.length} potential new sources:\n`);

  verifiedSections.sort((a,b) => b.headlineConfidence - a.headlineConfidence).forEach(section => {
    console.log(`--- Section: \x1b[36m${section.title}\x1b[0m (Confidence: ${section.headlineConfidence}) ---`);
    console.log(`URL: \x1b[32m${section.url}\x1b[0m`);
    console.log(`Suggested Selector: \x1b[33m${section.suggestedSelector}\x1b[0m`);
    console.log(`Sample Headlines:`);
    section.sampleHeadlines.forEach(h => console.log(`  - "${h}"`));
    console.log('\n');
  });
}

main().catch(err => logger.error({ err }, 'Section discovery failed.'));

```

## 📄 scripts/sources/list-sources.js
*Lines: 60, Size: 1.92 KB*

```javascript
// apps/pipeline/scripts/sources/list-sources.js (version 3.0.0)
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import mongoose from 'mongoose';
import { Source } from '../../../../packages/models/src/index.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import colors from 'ansi-colors';

async function listSources() {
  const argv = yargs(hideBin(process.argv))
    .option('country', { alias: 'c', type: 'string' })
    .option('status', { alias: 's', type: 'string', choices: ['failing', 'healthy'] })
    .option('json', { type: 'boolean', description: 'Output as JSON' })
    .help().argv;
  
  await dbConnect();
  try {
    const query = { status: 'active' };
    if (argv.country) query.country = new RegExp(`^${argv.country}$`, 'i');
    if (argv.status === 'failing') {
        query['analytics.lastRunHeadlineCount'] = 0;
        query['analytics.totalRuns'] = { $gt: 0 };
    } else if (argv.status === 'healthy') {
        query['analytics.lastRunHeadlineCount'] = { $gt: 0 };
    }

    const sources = await Source.find(query).sort({ country: 1, name: 1 }).lean();
    
    if (argv.json) {
        console.log(JSON.stringify(sources, null, 2));
        return;
    }

    if (sources.length === 0) {
      console.log('No sources found matching criteria.');
      return;
    }
    
    const tableData = sources.map(s => {
        const analytics = s.analytics || {};
        let health = colors.yellow('❓ New');
        if (analytics.totalRuns > 0) {
          health = analytics.lastRunHeadlineCount > 0 ? colors.green('✅ Healthy') : colors.red('❌ Failing');
        }
        return {
          Name: s.name,
          Health: health,
          'Last Count': analytics.lastRunHeadlineCount ?? 'N/A',
          Country: s.country,
          Method: s.extractionMethod,
        };
      });
    console.table(tableData);

  } finally {
    await mongoose.disconnect();
  }
}
listSources();

```

## 📄 scripts/sources/maintain.js
*Lines: 60, Size: 2.31 KB*

```javascript
// apps/pipeline/scripts/sources/maintain.js (version 2.0.0)
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import { Source } from '../../../../packages/models/src/index.js';
import { logger } from '../../../../packages/utils/src/server.js';
import mongoose from 'mongoose';
import colors from 'ansi-colors';

const LOW_LEAD_RATE_THRESHOLD = 0.01; // 1%
const MIN_RUNS_FOR_PRUNING = 100;

async function maintainSources() {
  await dbConnect();
  logger.info('🤖 Starting Autonomous Scraper Maintenance...');

  // --- 1. Report on Failing Sources (Self-Heal Disabled) ---
  logger.info('--- Phase 1: Identifying and Reporting Failing Scrapers ---');
  const failingSources = await Source.find({
    status: 'active',
    'analytics.totalRuns': { $gt: 0 },
    'analytics.lastRunHeadlineCount': 0,
  }).lean();

  if (failingSources.length === 0) {
    logger.info('✅ No failing sources detected.');
  } else {
    logger.warn(`Found ${failingSources.length} failing sources. Self-healing is disabled, reporting only:`);
    for (const source of failingSources) {
      logger.warn(colors.red(`  - FAILED: ${source.name} (Last scraped: ${source.lastScrapedAt?.toISOString() || 'N/A'})`));
    }
  }

  // --- 2. Proactive Pruning of Low-Value Sources ---
  logger.info('\n--- Phase 2: Pruning Low-Value (High Noise) Sources ---');
  const candidatesForPruning = await Source.find({
      'analytics.totalRuns': { $gt: MIN_RUNS_FOR_PRUNING },
      scrapeFrequency: 'high'
  }).lean();

  let prunedCount = 0;
  for (const source of candidatesForPruning) {
      const analytics = source.analytics;
      const leadRate = analytics.totalScraped > 0 ? (analytics.totalRelevant / analytics.totalScraped) : 0;
      if (leadRate < LOW_LEAD_RATE_THRESHOLD) {
          await Source.findByIdAndUpdate(source._id, { $set: { scrapeFrequency: 'low' } });
          logger.warn(`  - Downgraded "${source.name}" to 'low' frequency due to low lead rate (${(leadRate * 100).toFixed(2)}%).`);
          prunedCount++;
      }
  }

  if (prunedCount > 0) {
    logger.info(`✅ Pruning complete. Downgraded ${prunedCount} noisy sources.`);
  } else {
    logger.info('✅ No sources met the criteria for pruning.');
  }

  logger.info('\n🤖 Autonomous Scraper Maintenance complete.');
}

maintainSources().finally(() => mongoose.disconnect());

```

## 📄 scripts/sources/scrape-many.js
*Lines: 104, Size: 3.51 KB*

```javascript
// apps/pipeline/scripts/sources/scrape-many.js (version 1.0)
undefined
import { initializeSettings } undefined;
import { sleep, truncateString } from '../../../../packages/utils/src/index.js';
import { reinitializeLogger as initializeLogger, logger } from '../../../../packages/utils/src/server.js';
import path from 'path';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import mongoose from 'mongoose';
import pLimit from 'p-limit';
import { Source } from '../../../../packages/models/src/index.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import { configure as configureScraperLogic } from '@headlines/scraper-logic/config.js';
import { scrapeSiteForHeadlines, scrapeArticleContent } from '@headlines/scraper-logic/scraper/index.js';

initializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'));

configureScraperLogic({
  paths: { debugHtmlDir: path.resolve(process.cwd(), 'apps/pipeline/debug_html') },
  configStore: {},
  utilityFunctions: {},
});

const CONCURRENCY = 5;

async function testSource(source) {
  logger.info(`\n▶️  Testing: ${source.name} (${source.country})`);
  const headlineResult = await scrapeSiteForHeadlines(source);

  if (!headlineResult.success || headlineResult.resultCount === 0) {
    logger.error(`❌ Headline scraping failed. Reason: ${headlineResult.error || 'No headlines found.'}`);
    return;
  }

  logger.info(`✅ Found ${headlineResult.resultCount} headlines.`);
  const firstArticle = headlineResult.articles[0];

  const contentResult = await scrapeArticleContent(
    { ...firstArticle, source: source.name, newspaper: source.name, country: source.country },
    source
  );

  if (contentResult.articleContent && contentResult.articleContent.contents.length > 0) {
    logger.info(`✅ Content scraping successful (${contentResult.articleContent.contents.join('').length} chars).`);
  } else {
    logger.error(`❌ Content scraping failed. Reason: ${contentResult.enrichment_error}`);
  }
}

async function scrapeMany() {
  const argv = yargs(hideBin(process.argv))
    .option('country', {
      alias: 'c',
      type: 'string',
      description: 'The country to scrape sources from.',
    })
    .option('include-inactive', {
      alias: 'i',
      type: 'boolean',
      description: 'Include sources marked as "paused" or "under_review".',
      default: false,
    })
    .help()
    .alias('help', 'h').argv;

  try {
    await dbConnect();
    await initializeSettings();

    const query = {};
    if (argv.country) {
      query.country = new RegExp(`^${argv.country}$`, 'i');
      logger.info(`Filtering for country: "${argv.country}"`);
    }
    if (!argv.includeInactive) {
      query.status = 'active';
      logger.info('Including only "active" sources. Use --include-inactive to override.');
    }

    const sources = await Source.find(query).sort({ country: 1, name: 1 }).lean();

    if (sources.length === 0) {
      logger.warn('No sources found matching the criteria.');
      return;
    }

    logger.info(`🚀 Found ${sources.length} source(s) to test. Starting with concurrency ${CONCURRENCY}...`);
    const limit = pLimit(CONCURRENCY);
    const promises = sources.map(source => limit(() => testSource(source)));

    await Promise.all(promises);
    logger.info('\n✅ All scrape tests completed.');

  } catch (error) {
    logger.fatal({ err: error }, 'A critical error occurred during the scrape-many script.');
  } finally {
    if (mongoose.connection.readyState === 1) {
      await mongoose.disconnect();
    }
  }
}

scrapeMany();

```

## 📄 scripts/sources/scrape-one.js
*Lines: 92, Size: 3.46 KB*

```javascript
// apps/pipeline/scripts/sources/scrape-one.js (version 1.5.0)
undefined
import { initializeSettings } undefined;
import { truncateString } from '../../../../packages/utils/src/index.js';
import { logger, reinitializeLogger } from '../../../../packages/utils/src/server.js';
import path from 'path';
import { fileURLToPath } from 'url';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import mongoose from 'mongoose';
import { Source } from '../../../../packages/models/src/index.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import { configure as configureScraperLogic } from '@headlines/scraper-logic/config.js';
import { scrapeSiteForHeadlines, scrapeArticleContent } from '@headlines/scraper-logic/scraper/index.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.resolve(__dirname, '../../../');

reinitializeLogger(path.join(PROJECT_ROOT, 'logs'));

configureScraperLogic({
  paths: { debugHtmlDir: path.join(PROJECT_ROOT, 'debug_html') },
  configStore: {},
});

// ... (rest of the script remains the same)
async function scrapeOne() {
  const argv = yargs(hideBin(process.argv))
    .option('source', {
      alias: 's',
      type: 'string',
      description: 'The name of the source to scrape.',
      demandOption: true,
    })
    .help()
    .alias('help', 'h').argv;

  const sourceName = argv.source;
  logger.info(`🚀 Starting single source scrape for: "${sourceName}"`);

  try {
    await dbConnect();
    await initializeSettings();

    const source = await Source.findOne({ name: new RegExp(`^${sourceName}$`, 'i') }).lean();
    if (!source) {
      logger.error(`❌ Source "${sourceName}" not found in the database.`);
      return;
    }

    logger.info('🔬 Source Configuration:\n' + JSON.stringify(source, null, 2));

    logger.info('\n▶️  Phase 1: Scraping Headlines...');
    const headlineResult = await scrapeSiteForHeadlines(source);

    if (!headlineResult.success || headlineResult.resultCount === 0) {
      logger.error(`❌ Headline scraping failed. Reason: ${headlineResult.error || 'No headlines found.'}`);
      return;
    }

    logger.info(`✅ Found ${headlineResult.resultCount} headlines.`);
    const firstArticle = headlineResult.articles[0];
    logger.info(`    - First Headline: "${firstArticle.headline}"\n    - Link: ${firstArticle.link}`);

    logger.info('\n▶️  Phase 2: Scraping Content for First Article...');
    const contentResult = await scrapeArticleContent(
      { ...firstArticle, source: source.name, newspaper: source.name, country: source.country },
      source
    );

    if (contentResult.articleContent && contentResult.articleContent.contents.length > 0) {
      const content = contentResult.articleContent.contents.join('\n');
      logger.info(`✅ Content scraping successful! (${content.length} chars)`);
      logger.info(`    - Snippet: "${truncateString(content, 300)}..."`);
    } else {
      logger.error(`❌ Content scraping failed. Reason: ${contentResult.enrichment_error}`);
      if (contentResult.contentPreview) {
        logger.warn(`    - Scraped Preview: "${contentResult.contentPreview}..."`);
      }
    }
  } catch (error) {
    logger.fatal({ err: error }, 'A critical error occurred during the scrape-one script.');
  } finally {
    if (mongoose.connection.readyState === 1) {
      await mongoose.disconnect();
      logger.info('Database connection closed.');
    }
  }
}
scrapeOne();

```

## 📄 scripts/sources/update.js
*Lines: 64, Size: 2.42 KB*

```javascript
// apps/pipeline/scripts/sources/update.js (version 2.0)
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import mongoose from 'mongoose';
import { Source } from '../../../../packages/models/src/index.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import { logger } from '../../../../packages/utils/src/server.js';
undefined
import readline from 'readline';
import colors from 'ansi-colors';

const rl = readline.createInterface({ input: process.stdin, output: process.stdout });

async function main() {
  const argv = yargs(hideBin(process.argv))
    .option('source', { alias: 's', type: 'string', demandOption: true })
    .option('key', { alias: 'k', type: 'string', demandOption: true })
    .option('value', { alias: 'v', type: 'string', demandOption: true })
    .option('yes', { alias: 'y', type: 'boolean', description: 'Skip confirmation prompt' })
    .help().argv;

  await dbConnect();
  try {
    const source = await Source.findOne({ name: new RegExp(`^${argv.source}$`, 'i') });
    if (!source) {
      logger.error(`Source "${argv.source}" not found.`);
      return;
    }

    let parsedValue;
    try {
      parsedValue = JSON.parse(argv.value);
    } catch (e) {
      parsedValue = argv.value === 'null' ? undefined : argv.value;
    }
    
    console.log(`\n--- Change Summary for Source: ${colors.bold(source.name)} ---`);
    console.log(`Field:      ${colors.cyan(argv.key)}`);
    const oldValue = JSON.stringify(source.get(argv.key), null, 2) || 'undefined';
    console.log(`Old Value:  ${colors.red(oldValue)}`);
    console.log(`New Value:  ${colors.green(JSON.stringify(parsedValue, null, 2))}`);
    console.log('-----------------------------------------------------\n');

    if (!argv.yes) {
        const answer = await new Promise(resolve => rl.question('Apply this change? (yes/no): ', resolve));
        if (answer.toLowerCase() !== 'yes') {
            logger.warn('Operation cancelled by user.');
            return;
        }
    }

    const update = parsedValue === undefined ? { $unset: { [argv.key]: "" } } : { $set: { [argv.key]: parsedValue } };
    await Source.updateOne({ _id: source._id }, update);

    logger.info(`✅ Successfully updated field "${argv.key}" for source "${source.name}".`);
  } catch (error) {
    logger.error({ err: error }, 'An error occurred during the update process.');
  } finally {
    rl.close();
    await mongoose.disconnect();
  }
}
main();

```

## 📄 scripts/subscribers/list.js
*Lines: 40, Size: 1.11 KB*

```javascript
// apps/pipeline/scripts/subscribers/list.js (version 1.0)
import dbConnect from '../../../../packages/data-access/src/dbConnect.js'
import { Subscriber } from '../../../../packages/models/src/index.js'
import mongoose from 'mongoose'
import colors from 'ansi-colors'

async function listSubscribers() {
  await dbConnect()
  try {
    const subscribers = await Subscriber.find({}).sort({ email: 1 }).lean()

    if (subscribers.length === 0) {
      console.log('No subscribers found.')
      return
    }

    const tableData = subscribers.map((s) => {
      let status = s.isActive ? colors.green('Active') : colors.red('Inactive')
      if (s.role === 'admin') {
        status += ` / ${colors.yellow('Admin')}`
      }
      return {
        Email: s.email,
        Name: `${s.firstName} ${s.lastName || ''}`,
        Status: status,
        Tier: s.subscriptionTier,
        Countries: s.countries.length,
      }
    })
    console.log('\n--- All Subscribers ---')
    console.table(tableData)
  } catch (e) {
    console.error('Error listing subscribers:', e)
  } finally {
    await mongoose.disconnect()
  }
}

listSubscribers()

```

## 📄 scripts/subscribers/update.js
*Lines: 72, Size: 2.37 KB*

```javascript
// apps/pipeline/scripts/subscribers/update.js (version 1.0)
import yargs from 'yargs'
import { hideBin } from 'yargs/helpers'
import mongoose from 'mongoose'
import { Subscriber } from '../../../../packages/models/src/index.js'
import dbConnect from '../../../../packages/data-access/src/dbConnect.js'
import { logger } from '../../../../packages/utils/src/server.js';
import '@headlines/config'
import readline from 'readline'
import colors from 'ansi-colors'

const rl = readline.createInterface({ input: process.stdin, output: process.stdout })

async function main() {
  const argv = yargs(hideBin(process.argv))
    .option('email', { type: 'string', demandOption: true })
    .option('key', { alias: 'k', type: 'string', demandOption: true })
    .option('value', { alias: 'v', type: 'string', demandOption: true })
    .option('yes', { alias: 'y', type: 'boolean' })
    .help().argv

  await dbConnect()
  try {
    const subscriber = await Subscriber.findOne({ email: argv.email })
    if (!subscriber) {
      logger.error(`Subscriber with email "${argv.email}" not found.`)
      return
    }

    let parsedValue
    try {
      parsedValue = JSON.parse(argv.value)
    } catch (e) {
      parsedValue = argv.value === 'null' ? undefined : argv.value
    }

    console.log(
      `\n--- Change Summary for Subscriber: ${colors.bold(subscriber.email)} ---`
    )
    console.log(`Field:      ${colors.cyan(argv.key)}`)
    console.log(`Old Value:  ${colors.red(JSON.stringify(subscriber.get(argv.key)))}`)
    console.log(`New Value:  ${colors.green(JSON.stringify(parsedValue))}`)
    console.log('-----------------------------------------------------\n')

    if (!argv.yes) {
      const answer = await new Promise((resolve) =>
        rl.question('Apply this change? (yes/no): ', resolve)
      )
      if (answer.toLowerCase() !== 'yes') {
        logger.warn('Operation cancelled.')
        return
      }
    }

    const update =
      parsedValue === undefined
        ? { $unset: { [argv.key]: '' } }
        : { $set: { [argv.key]: parsedValue } }
    await Subscriber.updateOne({ _id: subscriber._id }, update)

    logger.info(
      `✅ Successfully updated field "${argv.key}" for subscriber "${subscriber.email}".`
    )
  } catch (error) {
    logger.error({ err: error }, 'An error occurred during the update process.')
  } finally {
    rl.close()
    await mongoose.disconnect()
  }
}
main()

```

## 📄 scripts/test-pipeline/test-payload.js
*Lines: 28, Size: 1.61 KB*

```javascript
// scripts/test-pipeline/test-payload.js (version 1.1)
/**
 * This file contains a "known good" test article payload.
 * The --dry-run mode injects this data directly into the pipeline,
 * bypassing the scraping and filtering stages. This ensures a consistent
 * and repeatable test case for the AI assessment, enrichment, clustering,
 * synthesis, and notification preparation stages.
 */
import mongoose from 'mongoose';

export const testArticles = [
  {
    _id: new mongoose.Types.ObjectId(), // DEFINITIVE FIX: Add a synthetic ID for test mode.
    headline:
      'Danish Møller family sells their shipping software company, NaviTech, for $500M to an American buyer.',
    link: 'https://example.com/moller-family-sells-navitech-for-500m',
    source: 'Test Source',
    newspaper: 'Test Source',
    country: 'Denmark',
    articleContent: {
      contents: [
        'COPENHAGEN -- In a landmark deal for the Danish tech sector, the prominent Møller family announced today the successful sale of their privately-held software company, NaviTech, for an estimated $500 million. The buyer is the US-based logistics giant, Global Transport Inc. NaviTech, founded by patriarch Jørgen Møller in 1998, has become a critical player in maritime logistics software. "This is a proud day for our family," said CEO and daughter, Christina Møller. "We built this from the ground up, and we are confident that Global Transport Inc. will take it to the next level. The family plans to focus on philanthropic endeavors through the Møller Foundation going forward."',
      ],
    },
  },
  // You can add more test articles here to test clustering
]

```

## 📄 scripts/tools/calculate-watchlist-hits.js
*Lines: 108, Size: 3.72 KB*

```javascript
// apps/pipeline/scripts/tools/calculate-watchlist-hits.js (version 1.0.0)
'use strict';
import mongoose from 'mongoose';
import cliProgress from 'cli-progress';
import colors from 'ansi-colors';
import { Article, WatchlistEntity } from '../../../../packages/models/src/index.js';
import dbConnect from '../../../../packages/data-access/src/dbConnect.js';
import { reinitializeLogger, logger } from '../../../../packages/utils/src/server.js';
import path from 'path';

// --- SCRIPT CONFIGURATION ---
const LOG_LEVEL = 'info'; // Set to 'trace' for more detailed logs

// Initialize a dedicated logger for this script
reinitializeLogger(path.resolve(process.cwd(), 'apps/pipeline/logs'));
logger.level = LOG_LEVEL;

async function calculateHits() {
  const startTime = Date.now();
  logger.info('🚀 Starting Watchlist Hit Count Calculation...');

  await dbConnect();

  // 1. Load all data into memory
  logger.info('Loading all articles and watchlist entities into memory...');
  const [allArticles, watchlistEntities] = await Promise.all([
    Article.find({}).select('headline').lean(),
    WatchlistEntity.find({}).select('name searchTerms').lean(),
  ]);
  logger.info(`Loaded ${watchlistEntities.length} watchlist entities and ${allArticles.length.toLocaleString()} articles.`);

  if (watchlistEntities.length === 0 || allArticles.length === 0) {
    logger.warn('Nothing to process. Exiting.');
    return;
  }

  // 2. Perform the hit calculation
  logger.info('Calculating hits... (This may take a while)');
  const progressBar = new cliProgress.SingleBar({
    format: `Processing | ${colors.cyan('{bar}')} | {percentage}% || {value}/{total} Entities`,
    barCompleteChar: '\u2588',
    barIncompleteChar: '\u2591',
    hideCursor: true,
  });
  progressBar.start(watchlistEntities.length, 0);

  const hitCounts = new Map();

  for (const entity of watchlistEntities) {
    let count = 0;
    const allTerms = [entity.name, ...(entity.searchTerms || [])]
      .map(t => t.toLowerCase().trim())
      .filter(Boolean);
    
    const uniqueTerms = [...new Set(allTerms)];
    const termRegexes = uniqueTerms.map(term => new RegExp(`\\b${term.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\b`, 'i'));
    
    const countedHeadlines = new Set();

    for (const article of allArticles) {
        if (countedHeadlines.has(article._id.toString())) continue;

        for (const regex of termRegexes) {
            if (regex.test(article.headline)) {
                count++;
                countedHeadlines.add(article._id.toString());
                break; // Move to the next article once a hit is found for this entity
            }
        }
    }
    hitCounts.set(entity._id.toString(), count);
    progressBar.increment();
  }
  progressBar.stop();
  logger.info('✅ Hit calculation complete.');

  // 3. Update the database in bulk
  logger.info('Preparing bulk update for the database...');
  const bulkOps = [];
  for (const [entityId, count] of hitCounts.entries()) {
    bulkOps.push({
      updateOne: {
        filter: { _id: new mongoose.Types.ObjectId(entityId) },
        update: { $set: { hitCount: count } },
      },
    });
  }

  if (bulkOps.length > 0) {
    logger.info(`Sending ${bulkOps.length} updates to the database...`);
    const result = await WatchlistEntity.bulkWrite(bulkOps);
    logger.info(`✅ Database update complete. Modified ${result.modifiedCount} documents.`);
  } else {
    logger.info('No updates were necessary.');
  }

  const duration = (Date.now() - startTime) / 1000;
  logger.info(`✨ Operation finished in ${duration.toFixed(2)} seconds.`);
}

calculateHits()
  .catch((err) => logger.fatal({ err }, 'A critical error occurred.'))
  .finally(() => {
    if (mongoose.connection.readyState === 1) {
      mongoose.disconnect();
    }
  });

```

## 📄 scripts/tools/get-db-stats.js
*Lines: 46, Size: 1.4 KB*

```javascript
// scripts/tools/get-db-stats.js (version 1.0)
import 'dotenv/config'
import { connectDatabase, disconnectDatabase } from '../../../src/database.js'
import Article from '../../../models/Article.js'
import SynthesizedEvent from '../../../models/SynthesizedEvent.js'
import Opportunity from '../../../models/Opportunity.js'
import WatchlistEntity from '../../../models/WatchlistEntity.js'
import Source from '../../../models/Source.js'
import Subscriber from '../../../models/Subscriber.js'

async function getStats() {
  await connectDatabase()
  try {
    console.log('\n--- 📊 Database Statistics ---')
    const [
      articles,
      events,
      opportunities,
      watchlist,
      sources,
      subscribers,
    ] = await Promise.all([
      Article.countDocuments(),
      SynthesizedEvent.countDocuments(),
      Opportunity.countDocuments(),
      WatchlistEntity.countDocuments({ status: 'active' }),
      Source.countDocuments({ status: 'active' }),
      Subscriber.countDocuments({ isActive: true }),
    ])

    console.table({
      'Active Sources': sources,
      'Active Watchlist Entities': watchlist,
      'Total Articles': articles,
      'Total Synthesized Events': events,
      'Total Opportunities': opportunities,
      'Active Subscribers': subscribers,
    })
  } catch (error) {
    console.error('Failed to fetch database stats:', error)
  } finally {
    await disconnectDatabase()
  }
}

getStats()
```

## 📄 scripts/watchlist/list.js
*Lines: 42, Size: 1.21 KB*

```javascript
// apps/pipeline/scripts/watchlist/list.js (version 1.0)
import yargs from 'yargs'
import { hideBin } from 'yargs/helpers'
import mongoose from 'mongoose'
import { WatchlistEntity } from '../../../../packages/models/src/index.js'
import dbConnect from '../../../../packages/data-access/src/dbConnect.js'
import colors from 'ansi-colors'

async function main() {
  const argv = yargs(hideBin(process.argv))
    .option('q', { type: 'string', description: 'Search query for entity name' })
    .help().argv

  await dbConnect()
  try {
    const query = {}
    if (argv.q) {
      query.name = new RegExp(argv.q, 'i')
    }

    const entities = await WatchlistEntity.find(query).sort({ name: 1 }).lean()

    if (entities.length === 0) {
      console.log('No watchlist entities found.')
      return
    }

    const tableData = entities.map((e) => ({
      Name: e.name,
      Type: e.type,
      Status: e.status === 'active' ? colors.green('Active') : colors.yellow(e.status),
      Country: e.country || 'N/A',
      'Search Terms': (e.searchTerms || []).join(', '),
    }))
    console.log(`\n--- Watchlist Entities (${entities.length}) ---`)
    console.table(tableData)
  } finally {
    await mongoose.disconnect()
  }
}
main()

```

## 📄 src/app.js
*Lines: 71, Size: 2.14 KB*

```javascript
// apps/pipeline/src/app.js
process.env.IS_PIPELINE_RUN = 'true'

import { env } from '@headlines/config/src/server.js'
import { reinitializeLogger } from '@headlines/utils/src/server.js'
import { initializeAuditLogger } from './utils/auditLogger.js'
import path from 'path'
import yargs from 'yargs'
import { hideBin } from 'yargs/helpers'
import { runPipeline } from './orchestrator.js'
import humanLogStream from './utils/humanLogStream.js'
import fs from 'fs'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const PROJECT_ROOT = path.resolve(__dirname, '../../..')

const logDirectory = path.join(PROJECT_ROOT, 'apps/pipeline/logs')
if (!fs.existsSync(logDirectory)) fs.mkdirSync(logDirectory, { recursive: true })

const logFile = path.join(logDirectory, 'run.log')
try {
  fs.unlinkSync(logFile)
} catch (e) {
  if (e.code !== 'ENOENT') console.error('Could not clear old log file:', e)
}
const fileWriteStream = fs.createWriteStream(logFile, { flags: 'a' })
humanLogStream.pipe(fileWriteStream)
const extraStreams = [{ level: 'trace', stream: humanLogStream }]

const logger = reinitializeLogger(logDirectory, extraStreams)
initializeAuditLogger(logDirectory)

async function start() {
  const argv = yargs(hideBin(process.argv)).argv
  const options = {
    ...argv,
    countryFilter: argv.country,
    sourceFilter: argv.source,
    projectRoot: PROJECT_ROOT,
  }

  logger.info('--- Pipeline Execution Flags ---')
  Object.entries(argv).forEach(([key, value]) => {
    if (key !== '_' && key !== '$0' && value) {
      logger.info(`- ${key.toUpperCase()}: ${value}`)
    }
  })
  logger.info('------------------------------------')

  let result
  try {
    result = await runPipeline(options)
  } catch (error) {
    logger.fatal({ err: error }, 'A top-level, unhandled exception occurred.')
    process.exit(1)
  }

  if (result && !result.success) {
    logger.warn(
      'Pipeline completed with one or more fatal errors. Exiting with status 1.'
    )
    process.exit(1)
  } else {
    logger.info('Pipeline completed successfully. Exiting with status 0.')
    process.exit(0)
  }
}
start()

```

## 📄 src/config/PEFirms.json
*Lines: 212, Size: 12.23 KB*

```json
[
  {
    "country": "Global PE",
    "flag_emoji": "🌐",
    "outlets": [
      {
        "name": "Apollo",
        "url": "https://www.apollo.com",
        "commentary": "Global alternative asset manager.",
        "labCheckPerformed": true,
        "analysis": {
          "urlDiscoveryMethod": "initial",
          "finalUrl": "https://www.apollo.com",
          "technology": "playwright + AI",
          "headlineSelectorMethod": "AI Structural Analysis",
          "headlineSelector": "a.cmp-insight-column-card__item__title--link, a.cmp-teaser__title-link, a.text-link-blck, a.cmp-navigation-featuredcontent__link",
          "headlinesFound": 21,
          "firstArticleUrl": "https://www.apollo.com/insights-news/insights/2025/06/mid-year-outlook-at-the-crossroads-of-stagflation-whats-next",
          "articleContentSelector": "main p",
          "sampleArticleLength": 8513,
          "aiInsights": {
            "pattern": "Headline links on this site share common traits: they usually use title-cased, descriptive text (often long) and live under /insights-news/ (either /insights/ or /pressreleases/) or the site’s feature/teaser areas. The CSS classes used for headlines include .cmp-insight-column-card__item__title--link (insight cards), .cmp-teaser__title-link (teasers/featured items), .text-link-blck (press releases/compact lists), and .cmp-navigation-featuredcontent__link (promoted featured content). Headlines often contain organization names, event names, or report titles and sometimes point to PDFs or IR pages.",
            "confidence": 0.9009523809523808
          },
          "notes": "Handled consent using persistent browser state."
        }
      },
      {
        "name": "KKR",
        "url": "https://www.kkr.com",
        "commentary": "Global investment company.",
        "labCheckPerformed": true,
        "analysis": {
          "urlDiscoveryMethod": "initial",
          "finalUrl": "https://www.kkr.com",
          "technology": "playwright + AI",
          "headlineSelectorMethod": "AI Structural Analysis",
          "headlineSelector": "a.article-teaser__link, a[href^=\"/insights/\"], a[href*=\"media.kkr.com/news-details\"]",
          "headlinesFound": 4,
          "firstArticleUrl": "https://www.kkr.com/insights/thoughts-from-the-road-asia-2025",
          "articleContentSelector": "article p",
          "sampleArticleLength": 2123,
          "aiInsights": {
            "pattern": "Headline links on this site appear in two primary patterns: 1) Insight/article teasers using the .article-teaser__link class with anchor text that begins with a content category (e.g., 'Macro Insights', 'Investment Insights'), followed by a concise headline and often a month/year and 'Learn More' suffix. These link URLs are under the /insights/ path with a readable slug. 2) Press releases use an external media subdomain (media.kkr.com) and a 'news-details' endpoint with a news_id GUID parameter. Navigation/utility links (about, invest, cookie policy, IR) use different selectors (generic a, cmp-button, .cmp-link) and shorter, non-article text.",
            "confidence": 0.9374999999999999
          },
          "notes": "Handled consent using persistent browser state."
        }
      },
      {
        "name": "PAI Partners",
        "url": "https://www.paipartners.com",
        "commentary": "European private equity firm.",
        "labCheckPerformed": true,
        "analysis": {
          "urlDiscoveryMethod": "initial",
          "finalUrl": "https://www.paipartners.com",
          "technology": "playwright + AI",
          "headlineSelectorMethod": "AI Structural Analysis",
          "headlineSelector": "a[href*=\"/mediaitem/\"]",
          "headlinesFound": 5,
          "firstArticleUrl": "https://www.paipartners.com/mediaitem/2025-annual-general-meetings/",
          "articleContentSelector": null,
          "sampleArticleLength": 0,
          "aiInsights": {
            "pattern": "Headline links share these characteristics: (1) URLs contain the segment '/mediaitem/' (site's press/news item pattern). (2) Anchor text is natural-language, headline-style (short-to-medium length, often starting with the organisation name or an active verb and containing proper nouns or numeric details). (3) The CSS selector for headline anchors is a plain 'a' within the news listing; navigation CTAs use distinct classes (e.g., 'a.btn') and case studies use different URL paths such as '/case-study/'.",
            "confidence": 0.95
          },
          "notes": "Handled consent using persistent browser state."
        }
      },
      {
        "name": "EQT Group",
        "url": "https://www.eqtgroup.com",
        "commentary": "Global investment organization.",
        "labCheckPerformed": true,
        "analysis": {
          "urlDiscoveryMethod": "initial",
          "finalUrl": "https://www.eqtgroup.com",
          "technology": "playwright + AI",
          "headlineSelectorMethod": "AI Structural Analysis",
          "headlineSelector": "Prefer URL-prefix + presentation-class combination to capture headlines while avoiding nav: \"a[href^='/thinq/'], a[href^='/news/']\". Optionally restrict to known article classes: \"a.p-6, a.bg-transparent, a.md\\:p-6, a[href^='/thinq/'], a[href^='/news/']\"",
          "headlinesFound": 18,
          "firstArticleUrl": "https://www.eqtgroup.com/thinq/private-markets/ipo-report-2025",
          "articleContentSelector": "main p",
          "sampleArticleLength": 2123,
          "aiInsights": {
            "pattern": "Headline links cluster under two main URL patterns: /thinq/ (editorial/insights, case-studies, education, opinion) and /news/ (press releases). Headlines tend to have: longer, descriptive anchor text (often >4 words), question or quoted formats, numeric values or company names, and appear with presentation classes such as a.p-6, a.bg-transparent, or a.md:p-6. Navigation and utility links are shorter (single words or short phrases like 'Private Capital', 'About') and often use a.w-full or a.bg-white selectors.",
            "confidence": 0.8833333333333332
          },
          "notes": "Handled consent using persistent browser state."
        }
      },
      {
        "name": "Egeria",
        "url": "https://egeriagroup.com",
        "commentary": "Dutch private equity firm."
      },
      {
        "name": "Rivean Capital (Gilde)",
        "url": "https://www.riveancapital.com",
        "commentary": "Formerly Gilde Equity Management (GEM)."
      },
      {
        "name": "IK Partners (News & Insights)",
        "url": "https://www.ikpartners.com",
        "commentary": "Main press releases and portfolio updates."
      },
      {
        "name": "IK Partners (Portfolio News)",
        "url": "https://www.ikpartners.com/portfolio-company-news",
        "commentary": "Specific news archive for portfolio companies."
      },
      {
        "name": "Triton Partners",
        "url": "https://www.triton-partners.com",
        "commentary": "European private equity investment firm."
      },
      {
        "name": "Bridgepoint (News & Insights)",
        "url": "https://www.bridgepoint.eu",
        "commentary": "Corporate news and insights."
      },
      {
        "name": "Bridgepoint (Regulatory News)",
        "url": "https://www.bridgepoint.eu/shareholder-centre/regulatory-news",
        "commentary": "Live LSE regulatory news feed."
      },
      {
        "name": "Hg Capital",
        "url": "https://hgcapital.com",
        "commentary": "Software and services investor.",
        "labCheckPerformed": true,
        "analysis": {
          "urlDiscoveryMethod": "initial",
          "finalUrl": "https://hgcapital.com",
          "technology": "playwright + AI",
          "headlineSelectorMethod": "AI Structural Analysis",
          "headlineSelector": "article h2 a, article h3 a, .card__link, .post-card a, a[href*=\"/insights/\"], a[href*=\"/news/\"], a[href*=\"/case-studies/\"]",
          "headlinesFound": 1,
          "firstArticleUrl": "https://hgcapital.com/portfolio/case-studies/visma",
          "articleContentSelector": "main p",
          "sampleArticleLength": 3547,
          "aiInsights": {
            "pattern": "In this sample, genuine content/headline links are characterized by: (1) non-generic, descriptive anchor text (not repeated section labels like 'News & Insights'); (2) URLs that contain content paths (e.g., /portfolio/case-studies/, /insights/, /news/ or similar slugs) rather than top-level section or utility domains; and (3) selectors that are not the generic 'a' used for utilities (cookie consent) or site-wide buttons. Note the provided CSS selector (a.index-style__ButtonMain-sc-207d00b9-2) appears used for header/CTA buttons and repeated navigation, so it is less reliable alone for distinguishing article headlines.",
            "confidence": 0.9
          },
          "notes": "Handled consent using persistent browser state."
        }
      },
      {
        "name": "3i Group (Press Releases)",
        "url": "https://www.3i.com/media/press-releases/",
        "commentary": "Main corporate press releases."
      },
      {
        "name": "3i Group (Regulatory News)",
        "url": "https://www.3i.com/investors/regulatory-news/",
        "commentary": "Investor relations and regulatory news."
      },
      {
        "name": "CVC Capital Partners",
        "url": "https://www.cvc.com",
        "commentary": "Global private equity and credit."
      },
      {
        "name": "Ardian (News & Insights)",
        "url": "https://www.ardian.com/news-insights",
        "commentary": "Thought leadership and news articles.",
        "labCheckPerformed": true,
        "analysis": {
          "urlDiscoveryMethod": "initial",
          "finalUrl": "https://www.ardian.com/news-insights",
          "technology": "playwright + AI",
          "headlineSelectorMethod": "AI Structural Analysis",
          "headlineSelector": "a[href^=\"/news-insights/\"]:not(.tag):not(.btn-outline), a[href*=\"-report\"], a[href*=\"-years\"], article h2 a, article h3 a",
          "headlinesFound": 4,
          "firstArticleUrl": "https://www.ardian.com/news-insights/responsible-finance?category=202",
          "articleContentSelector": "div[class*=\"content\"] p",
          "sampleArticleLength": 1528,
          "aiInsights": {
            "pattern": "True news/headline links in this sample mostly target the '/news-insights/' path or external microsites dedicated to reports/campaigns. Headline-like anchors tend to be simple 'a' elements or prominent CTAs (e.g., 'a.btn-outline'). Tag/filter links use a distinct class ('a.tag') and cookie/privacy/vendor links use cookie dialog-specific selectors—these are not headlines. Headlines and content CTAs use descriptive, content-focused text (topic names, report titles or campaign domains) rather than generic utility/legal phrasing.",
            "confidence": 0.65
          },
          "notes": "Handled consent using persistent browser state."
        }
      },
      {
        "name": "Ardian (Press Releases)",
        "url": "https://www.ardian.com/press-releases",
        "commentary": "Official press releases.",
        "labCheckPerformed": true,
        "analysis": {
          "urlDiscoveryMethod": "initial",
          "finalUrl": "https://www.ardian.com/press-releases",
          "technology": "playwright + AI",
          "headlineSelectorMethod": "AI Structural Analysis",
          "headlineSelector": "a[href^='/news-insights/press-releases/']",
          "headlinesFound": 7,
          "firstArticleUrl": "https://www.ardian.com/news-insights/press-releases/diot-siaci-announces-new-ownership-structure-ardian-burrus-group-and",
          "articleContentSelector": "div[class*=\"content\"] p",
          "sampleArticleLength": 7719,
          "aiInsights": {
            "pattern": "Headlines are sentence-style, descriptive strings (often starting with firm names or action verbs like 'announces', 'enters', 'launches', 'acquire', 'finalizes') and typically include company names, transaction or product details, and locations/numbers. Their URLs consistently live under the /news-insights/press-releases/ path. The selector in the provided data is a generic 'a', implying these headline links are simple anchor tags within a news/press listing.",
            "confidence": 0.9585714285714287
          },
          "notes": "Handled consent using persistent browser state."
        }
      }
    ]
  }
]
```

## 📄 src/config/dynamicConfig.js
*Lines: 66, Size: 2.21 KB*

```javascript
// apps/pipeline/src/config/dynamicConfig.js (version 3.2.0)
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url';
import { Source, WatchlistEntity, Country } from '@headlines/models/src/index.js'
import { logger } from '@headlines/utils/src/server.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export const configStore = {
  newspaperToCountryMap: new Map(),
  watchlistEntities: new Map(),
  activeCountries: new Set(),
  searchTermToEntityMap: new Map(),
}

async function loadConfigFromDB() {
  logger.info('Loading dynamic configuration from database...');
  Object.keys(configStore).forEach((key) => {
    const store = configStore[key];
    if (store instanceof Map || store instanceof Set) store.clear();
    if (Array.isArray(store)) store.length = 0;
  });

  const [sources, watchlistItems, activeCountries] = await Promise.all([
    Source.find().lean(),
    WatchlistEntity.find({ status: 'active' }).lean(),
    Country.find({ status: 'active' }).select('name').lean(),
  ]);

  for (const country of activeCountries) {
    configStore.activeCountries.add(country.name);
  }

  for (const source of sources) {
    configStore.newspaperToCountryMap.set(source.name, source.country);
  }

  for (const item of watchlistItems) {
    const nameKey = item.name.toLowerCase().trim();
    if (!configStore.watchlistEntities.has(nameKey)) {
      configStore.watchlistEntities.set(nameKey, item);
    }

    if (item.searchTerms && item.searchTerms.length > 0) {
      for (const term of item.searchTerms) {
        const termKey = term.toLowerCase().trim();
        if (!configStore.searchTermToEntityMap.has(termKey)) {
          configStore.searchTermToEntityMap.set(termKey, item);
        }
      }
    }
  }

  logger.info(`Dynamic config loaded:\n    - Sources: ${sources.length}\n    - Watchlist Items: ${configStore.watchlistEntities.size}\n    - Active Countries: ${configStore.activeCountries.size}\n    - Search Terms: ${configStore.searchTermToEntityMap.size}`);
}

export async function refreshConfig() {
  try {
    await loadConfigFromDB();
  } catch (error) {
    logger.error({ err: error }, 'Failed to refresh dynamic configuration from DB.');
  }
}

```

## 📄 src/config/index.js
*Lines: 50, Size: 1.52 KB*

```javascript
// apps/pipeline/src/config/index.js (version 6.0.0)
// Use the server-safe entrypoint for all config imports in the pipeline
import { env, settings } from '@headlines/config/src/server.js'

// --- Re-export all shared env and settings for local pipeline use ---
export * from '@headlines/config/src/server.js'

// --- App-Specific Static Constants (Not dynamically configurable) ---
export const IS_REFRESH_MODE = process.env.REFRESH_MODE === 'true'

// --- Static Thresholds (less likely to be changed by admin) ---
export const MAX_ARTICLE_CHARS = 30000
export const LLM_CONTEXT_MAX_CHARS = 25000
export const MIN_HEADLINE_CHARS = 5
export const MAX_HEADLINE_CHARS = 500
export const AI_BATCH_SIZE = 6

// --- Re-export SMTP and Email configs from env for convenience ---
export const SMTP_CONFIG = {
  host: env.SMTP_HOST,
  port: env.SMTP_PORT,
  secure: env.SMTP_SECURE,
  auth: {
    user: env.SMTP_USER,
    pass: env.SMTP_PASS,
  },
  fromAddress: env.SMTP_FROM_ADDRESS || env.SMTP_USER,
  fromName: env.SMTP_FROM_NAME,
  pool: true,
  maxConnections: 5,
  maxMessages: 100,
  rateLimit: 10,
}

export const EMAIL_CONFIG = {
  templateName: 'wealthEvents',
  subject: 'New Nordic Banking Opportunities Detected',
  language: 'en',
  brandName: 'Your Wealth Watch',
  companyAddress: 'Wealth Watch Inc., Paris, France',
  unsubscribeUrl: '#',
}

export const SUPERVISOR_EMAIL_CONFIG = {
  templateName: 'supervisorReport',
  subject: '⚙️ Hourly Headlines Processing Run Summary',
  language: 'en',
  brandName: 'Headlines Processing Bot',
}

```

## 📄 src/modules/dataStore/index.js
*Lines: 136, Size: 6.5 KB*

```javascript
// apps/pipeline/src/modules/dataStore/index.js (version 6.1.0)
import { Pinecone } from '@pinecone-database/pinecone'
import { logger } from '@headlines/utils/src/server.js';
import { generateEmbedding } from '@headlines/ai-services/src/index.js'
import { env } from '@headlines/config/src/server.js'
import { Opportunity } from '@headlines/models/src/index.js';
import { bulkWriteEvents, bulkWriteArticles, findEventsByKeys, findArticlesByLinks } from '@headlines/data-access/src/index.js'

const { PINECONE_API_KEY, PINECONE_INDEX_NAME } = env;

if (!PINECONE_API_KEY) throw new Error('Pinecone API Key is missing!')
const pc = new Pinecone({ apiKey: PINECONE_API_KEY })
const pineconeIndex = pc.index(PINECONE_INDEX_NAME)

export async function savePipelineResults(articlesToSave, eventsToSave, savedOpportunities) {
  logger.info(`Committing pipeline results to databases (MongoDB & Pinecone)...`)

  let savedEvents = []
  const pineconeVectors = []

  try {
    if (eventsToSave && eventsToSave.length > 0) {
      const eventOps = eventsToSave.map((event) => {
        const eventPayload = event.toObject ? event.toObject() : event
        delete eventPayload._id
        return {
          updateOne: {
            filter: { event_key: event.event_key },
            update: { $set: { ...eventPayload, emailed: false } },
            upsert: true,
          },
        }
      })
      const eventResult = await bulkWriteEvents(eventOps);
      if (!eventResult.success) throw new Error(eventResult.error);
      logger.info(`MongoDB Event commit complete. Upserted: ${eventResult.upsertedCount}, Modified: ${eventResult.modifiedCount}.`)

      const eventKeys = eventsToSave.map((e) => e.event_key)
      const findResult = await findEventsByKeys(eventKeys);
      if (!findResult.success) throw new Error(findResult.error);
      savedEvents = findResult.data;

      for (const event of savedEvents) {
        const textToEmbed = `${event.synthesized_headline}\n${event.synthesized_summary}`
        const embedding = await generateEmbedding(textToEmbed)
        const eventDate = event.event_date ? new Date(event.event_date) : new Date(); // Robust date handling
        pineconeVectors.push({
          id: `event_${event._id.toString()}`, values: embedding,
          metadata: { type: 'event', headline: event.synthesized_headline, summary: event.synthesized_summary, country: event.country, event_date: eventDate.toISOString(), key_individuals: (event.key_individuals || []).map((p) => p.name).join(', ') },
        })
      }
    }

    if (articlesToSave && articlesToSave.length > 0) {
      const articleOps = []
      const eventKeyToIdMap = new Map(savedEvents.map((e) => [e.event_key, e._id]))
      const articleIdToEventKeyMap = new Map()
      for (const event of eventsToSave) {
        for (const sourceArticle of event.source_articles) {
          const article = articlesToSave.find((a) => a.link === sourceArticle.link)
          if (article) articleIdToEventKeyMap.set(article._id.toString(), event.event_key)
        }
      }

      for (const article of articlesToSave) {
        // Embed the AI-generated summary, not the full text
        if (article.relevance_article && article.assessment_article) {
          const textToEmbed = `${article.headline}\n${article.assessment_article}`
          article.embedding = await generateEmbedding(textToEmbed)
        }
        const articleIdStr = article._id.toString()
        if (article.embedding) {
          pineconeVectors.push({
            id: `article_${articleIdStr}`, values: article.embedding,
            metadata: { type: 'article', headline: article.headline, summary: article.assessment_article || 'No summary.', newspaper: article.newspaper, country: article.country },
          })
        }

        const eventKey = articleIdToEventKeyMap.get(articleIdStr)
        if (eventKey) article.synthesizedEventId = eventKeyToIdMap.get(eventKey)

        const { _id, ...dataToSet } = article
        // Delete articleContent before saving
        delete dataToSet.articleContent;
        Object.keys(dataToSet).forEach((key) => dataToSet[key] === undefined && delete dataToSet[key])
        if ((dataToSet.relevance_headline <= 25 && dataToSet.relevance_article <= 25)) delete dataToSet.articleContent
        delete dataToSet.embedding
        articleOps.push({ updateOne: { filter: { link: article.link }, update: { $set: dataToSet }, upsert: true } })
      }
      await bulkWriteArticles(articleOps);
      logger.info(`MongoDB Article commit complete. Upserted/Modified: ${articleOps.length}.`)
    }

    const opportunityDocs = (await Opportunity.find({ _id: { $in: (savedOpportunities || []).map(o => o._id) } }).lean()) || [];
    for (const opp of opportunityDocs) {
        if (opp.embedding && opp.embedding.length > 0) {
            pineconeVectors.push({
                id: `opportunity_${opp._id.toString()}`,
                values: opp.embedding,
                metadata: { type: 'opportunity', headline: opp.reachOutTo, summary: opp.whyContact.join(' '), country: opp.basedIn },
            });
        }
    }
    if (pineconeVectors.length > 0) {
      await pineconeIndex.upsert(pineconeVectors)
      logger.info(`Pinecone commit complete. Upserted ${pineconeVectors.length} vectors.`)
    }

    return { success: true, savedEvents }
  } catch (error) {
    logger.fatal({ err: error }, 'CRITICAL: Failed to commit pipeline results to the databases.')
    return { success: false, savedEvents: [] }
  }
}

export async function filterFreshArticles(articles, isRefreshMode = false) {
  if (!articles || articles.length === 0) return []
  const scrapedLinks = articles.map((a) => a.link)
  if (isRefreshMode) {
    logger.warn('REFRESH MODE: All scraped articles will be processed.')
    const result = await findArticlesByLinks(scrapedLinks);
    if (!result.success) throw new Error(result.error);
    const existingArticlesMap = new Map(result.data.map((a) => [a.link, a._id]))
    const articlesForReprocessing = articles.map((scrapedArticle) =>
      existingArticlesMap.get(scrapedArticle.link) ? { ...scrapedArticle, _id: existingArticlesMap.get(scrapedArticle.link) } : scrapedArticle
    )
    return articlesForReprocessing
  }
  const result = await findArticlesByLinks(scrapedLinks);
  if (!result.success) throw new Error(result.error);
  const existingLinks = new Set(result.data.map((a) => a.link))
  const freshArticles = articles.filter((a) => !existingLinks.has(a.link))
  logger.info(`Filtering complete. Found ${existingLinks.size} existing articles, ${freshArticles.length} are fresh.`)
  return freshArticles
}

```

## 📄 src/modules/email/components/articleFormatter.js
*Lines: 87, Size: 3.43 KB*

```javascript
// apps/pipeline/src/modules/email/components/articleFormatter.js (version 2.0.0)
import { logger } from '@headlines/utils/src/server.js';
import { truncateString } from '@headlines/utils/src/server.js'

function createArticleCard(article) {
  const {
    link,
    headline,
    source,
    contacts,
    summary,
    assessmentText,
    relevanceScore,
    callToActionText,
  } = article

  const scoreColor =
    relevanceScore >= 80 ? '#27ae60' : relevanceScore >= 50 ? '#f39c12' : '#c0392b'

  const contactsHtml =
    contacts && contacts.length > 0
      ? `<p style="margin: 0 0 15px; font-size: 14px; color: #555;"><strong>Contacts:</strong> ${contacts.join(', ')}</p>`
      : ''

  return `
    <div style="border: 1px solid #e0e0e0; border-radius: 8px; margin-bottom: 20px; padding: 20px; background-color: #ffffff; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
        <h3 style="margin-top: 0; margin-bottom: 10px; font-size: 18px; color: #333;">
            <a href="${link}" style="color: #007bff; text-decoration: none;">${headline}</a>
        </h3>
        <p style="margin: 0 0 15px; font-size: 14px; color: #777;"><strong>Source:</strong> ${source}</p>
        ${contactsHtml}
        <p style="margin: 0 0 15px; font-size: 15px; color: #555; line-height: 1.6;">${summary}</p>
        <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; padding: 15px; margin-bottom: 15px;">
            <p style="margin: 0; font-size: 14px; color: #333;">
                <strong>System Assessment:</strong> <span style="font-weight: bold; color: ${scoreColor};">[Score: ${relevanceScore}]</span> ${assessmentText}
            </p>
        </div>
        <a href="${link}" style="display: inline-block; background-color: #007bff; color: #ffffff; padding: 10px 15px; border-radius: 5px; text-decoration: none; font-weight: bold; font-size: 14px;">
            ${callToActionText}
        </a>
    </div>
    `
}

export function formatArticleForEmail(article) {
  if (!article || typeof article !== 'object' || !article.link || !article.headline) {
    logger.warn(`formatArticleForEmail: Invalid article object provided.`, {
      articlePreview: article,
    })
    return `<p style="color:red;">Error: Article data was invalid.</p>`
  }

  const genericArticleData = {
    link: article.link,
    headline: article.headline,
    source: article.source || article.newspaper || 'N/A',
    contacts: article.contacts || [],
    summary: 'No summary available.',
    assessmentText:
      article.assessment_article ||
      article.assessment_headline ||
      'Assessment not available.',
    relevanceScore: article.relevance_article ?? article.relevance_headline ?? 'N/A',
    callToActionText: 'Read Full Article →',
  }

  if (article.articleContent && typeof article.articleContent === 'object') {
    const { contents } = article.articleContent
    if (contents && Array.isArray(contents) && contents.length > 0) {
      genericArticleData.summary = truncateString(contents.join(' '), 250)
    }
  }

  if (genericArticleData.summary === 'No summary available.') {
    genericArticleData.summary = truncateString(genericArticleData.assessmentText, 250)
  }

  try {
    return createArticleCard(genericArticleData)
  } catch (error) {
    logger.error(`Error creating article card for email: "${article.headline}"`, {
      errorMessage: error.message,
    })
    return `<p style="color:red;">Error formatting article: ${truncateString(article.headline, 50)}</p>`
  }
}

```

## 📄 src/modules/email/components/emailBodyBuilder.js
*Lines: 126, Size: 5.86 KB*

```javascript
// apps/pipeline/src/modules/email/components/emailBodyBuilder.js (version 4.1.1 - Path Fix)
import { logger } from '@headlines/utils/src/logger.js'
import { EMAIL_CONFIG } from '../../../config/index.js'
import { formatEventForEmail } from './eventFormatter.js'
import { getCountryFlag } from '@headlines/utils/src/index.js'

function createEmailWrapper(bodyContent, subject) {
  // ... (wrapper remains the same)
  return `
    <!DOCTYPE html>
    <html lang="en">
        <head>
            <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
            <title>${subject}</title>
            <style type="text/css">
                body { margin: 0; padding: 0; background-color: #0d1117; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; }
                .content-table { width: 100%; max-width: 640px; }
                .main-heading { color: #EAEAEA; font-weight: 600; }
                .paragraph { color: #cccccc; line-height: 1.7; }
                .button { background-color: #238636; border-radius: 6px; }
                .button a { color: #ffffff; text-decoration: none; display: inline-block; width: 100%; text-align: center; }
                .footer-text { color: #888888; }
                @media only screen and (max-width: 600px) {
                    .content-table { width: 100% !important; }
                    .content-background { padding: 20px 15px !important; }
                }
            </style>
        </head>
        <body style="margin: 0; padding: 0; background-color: #0d1117;">
            <table role="presentation" border="0" cellpadding="0" cellspacing="0" width="100%">
                <tr>
                    <td align="center" style="padding: 20px 0;">
                        ${bodyContent}
                    </td>
                </tr>
            </table>
        </body>
    </html>
  `
}

export async function createPersonalizedEmailBody(
  user,
  eventsByCountry,
  subject,
  intro // Now a structured object
) {
  logger.info(
    { user: user.email, countries: Object.keys(eventsByCountry) },
    'Initiating email body generation.'
  )

  if (!user || !eventsByCountry || Object.keys(eventsByCountry).length === 0) {
    logger.warn('createPersonalizedEmailBody: Missing user or events data.')
    return null
  }

  // Format the new intro structure
  const bulletsHtml = intro.bullets
    .map((b) => `<li style="margin-bottom: 10px;">${b}</li>`)
    .join('')
  const introHtml = `
    <h1 class="main-heading" style="margin:0 0 20px 0; font-size: 24px; font-weight: bold;">${intro.greeting}</h1>
    <p class="paragraph" style="margin:0 0 25px 0; font-size: 15px;">${intro.body}</p>
    <ul class="paragraph" style="margin:0 0 25px 0; font-size: 15px; padding-left: 20px;">${bulletsHtml}</ul>
    <p class="paragraph" style="margin:0 0 25px 0; font-size: 15px;">${intro.signoff.replace(/\\n/g, '<br>')}</p>
  `

  let formattedEventsHtml = ''
  for (const [country, events] of Object.entries(eventsByCountry)) {
    const flag = getCountryFlag(country) // CORRECTED: Use utility function
    formattedEventsHtml += `<tr><td style="padding: 30px 0 10px 0;"><h2 style="margin:0; font-size: 24px; font-weight: 500; color: #EAEAEA;">${flag} ${country}</h2></td></tr>`

    const eventPromises = events.map((event) => formatEventForEmail(event))
    const results = await Promise.allSettled(eventPromises)

    results.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        formattedEventsHtml += `<tr><td>${result.value}</td></tr>`
      } else {
        const failedEvent = events[index]
        logger.error(
          {
            err: result.reason,
            event: { _id: failedEvent._id, headline: failedEvent.synthesized_headline },
          },
          'A single event card failed to render. It will be skipped in the email.'
        )
        formattedEventsHtml += `<tr><td><p style="color:red;">Error: Could not render event: ${failedEvent.synthesized_headline}</p></td></tr>`
      }
    })
  }

  const mainContent = `
    <div class="content-table" style="margin:0 auto;">
      <table role="presentation" style="width:100%;border-collapse:collapse;border:0;border-spacing:0;">
          <tr>
              <td style="padding:36px 30px;" class="content-background">
                  <table role="presentation" style="width:100%;border-collapse:collapse;border:0;border-spacing:0;">
                      <tr>
                          <td>
                              ${introHtml}
                          </td>
                      </tr>
                      <tr>
                        <td align="center" style="padding: 10px 0 30px 0;">
                           <table role="presentation" border="0" cellspacing="0" cellpadding="0"><tr><td class="button" style="padding:14px 28px;"><a href="https://headlines-client.vercel.app" target="_blank" style="font-size: 16px;">View Full Dashboard</a></td></tr></table>
                        </td>
                      </tr>
                      ${formattedEventsHtml}
                  </table>
              </td>
          </tr>
          <tr>
              <td style="padding:30px;">
                  <table role="presentation" style="width:100%;border-collapse:collapse;border:0;border-spacing:0;"><tr><td align="center"><p class="footer-text" style="margin:0;font-size:12px;">${EMAIL_CONFIG.brandName} | ${EMAIL_CONFIG.companyAddress}</p><p class="footer-text" style="margin:10px 0 0 0;font-size:12px;"><a href="${EMAIL_CONFIG.unsubscribeUrl}" style="color:#888888;text-decoration:underline;">Unsubscribe</a></p></td></tr></table>
              </td>
          </tr>
      </table>
    </div>`

  logger.info(`Successfully generated email body for ${user.email}.`)
  return createEmailWrapper(mainContent, subject)
}

```

## 📄 src/modules/email/components/eventFormatter.js
*Lines: 181, Size: 6.24 KB*

```javascript
// apps/pipeline/src/modules/email/components/eventFormatter.js (version 5.1.0)
import { logger } from '@headlines/utils/src/server.js'
import { Opportunity } from '@headlines/models/src/index.js'

const sourceIcons = {
  rag_db: '🗄️',
  wikipedia: '🌐',
  news_api: '📰',
}

function formatEnrichmentSources(sources = []) {
  if (sources.length === 0) return ''
  const icons = sources.map((s) => sourceIcons[s] || '❓').join(' ')
  return `<span style="font-size: 14px; margin-left: 12px; vertical-align: middle;">${icons}</span>`
}

async function getOpportunitiesForEvent(eventId) {
  try {
    if (!eventId) return []
    return await Opportunity.find({ events: eventId }).lean()
  } catch (error) {
    logger.error(
      { err: error, eventId },
      'Failed to fetch opportunities for an event card.'
    )
    return []
  }
}

async function createEventBriefCard(event) {
  const {
    _id,
    synthesized_headline,
    synthesized_summary,
    ai_assessment_reason,
    source_articles,
    highest_relevance_score,
    enrichmentSources,
    eventClassification, // Get the new field
  } = event

  const opportunities = await getOpportunitiesForEvent(_id)

  const scoreColor =
    highest_relevance_score >= 80
      ? '#4CAF50'
      : highest_relevance_score >= 50
        ? '#FFC107'
        : '#F44336'
  const scoreTextShadow = `0 0 8px ${scoreColor}40`

  // NEW: HTML block for the classification badge
  const classificationHtml = eventClassification
    ? `
    <div style="margin-top: 8px; display: inline-block; padding: 3px 10px; background-color: rgba(212, 175, 55, 0.1); border: 1px solid rgba(212, 175, 55, 0.2); border-radius: 99px; font-size: 11px; font-weight: 600; color: #D4AF37; text-transform: uppercase; letter-spacing: 0.5px;">
        ${eventClassification}
    </div>
  `
    : ''

  const opportunitiesHtml =
    opportunities && opportunities.length > 0
      ? `
    <tr>
        <td style="padding: 16px 0 8px; border-top: 1px solid #444444;">
            <p style="margin:0; font-size: 14px; color: #D4AF37; font-weight: 600;">Related Opportunities</p>
        </td>
    </tr>
    <tr>
        <td>
            ${opportunities
              .map(
                (opp) => `
                <div style="font-size: 14px; color: #cccccc; line-height: 1.6; margin-bottom: 8px;">
                    <strong>${opp.reachOutTo}</strong> (~$${
                      opp.likelyMMDollarWealth
                    }M) - <em>${opp.contactDetails?.role || 'Role not specified'}</em>
                </div>`
              )
              .join('')}
        </td>
    </tr>
  `
      : ''

  const reasoningHtml = ai_assessment_reason
    ? `
    <tr>
        <td style="padding: 16px 0 0; border-top: 1px solid #444444;">
            <p style="margin:0; font-size: 12px; color: #a0a0a0; font-style: italic;">
                <strong>AI Assessment:</strong> ${ai_assessment_reason}
            </p>
        </td>
    </tr>
  `
    : ''

  const sourcesHtml = (source_articles || [])
    .map(
      (article) => `
    <tr>
        <td style="padding: 4px 0;">
            <a href="${article.link}" style="color: #a0a0a0; text-decoration: none; font-size: 13px;">
                ${article.newspaper}: ${article.headline}
            </a>
        </td>
    </tr>
  `
    )
    .join('')

  return `
    <div style="background-color: #1E1E1E; border-radius: 12px; margin-bottom: 25px; padding: 25px; border: 1px solid #333333; box-shadow: 0 10px 25px rgba(0,0,0,0.3);">
        <table role="presentation" style="width:100%;border-collapse:collapse;border:0;border-spacing:0;">
            <!-- Score & Headline -->
            <tr>
                <td style="padding-bottom: 15px;">
                    <table role="presentation" style="width:100%;border-collapse:collapse;border:0;border-spacing:0;">
                        <tr>
                            <td style="width: 60px; vertical-align: top;" valign="top">
                                <p style="font-size: 28px; font-weight: 700; color: ${scoreColor}; margin: 0; text-shadow: ${scoreTextShadow};">${highest_relevance_score}</p>
                                <p style="font-size: 12px; color: #a0a0a0; margin: 0;">Score</p>
                                ${classificationHtml}
                            </td>
                            <td style="padding-left: 20px;">
                                <h2 style="margin:0; font-size: 20px; font-weight: 600; color: #EAEAEA; line-height: 1.4;">${synthesized_headline}${formatEnrichmentSources(enrichmentSources)}</h2>
                            </td>
                        </tr>
                    </table>
                </td>
            </tr>
            <!-- Summary -->
            <tr>
                <td style="padding-bottom: 20px;">
                    <p style="margin:0; font-size: 16px; color: #cccccc; line-height: 1.7;">${synthesized_summary}</p>
                </td>
            </tr>
            
            ${opportunitiesHtml}
            
            <!-- Sources -->
            <tr>
                <td style="padding: 16px 0 8px; border-top: 1px solid #444444;">
                    <p style="margin:0; font-size: 14px; color: #D4AF37; font-weight: 600;">Source Articles</p>
                </td>
            </tr>
            <tr>
              <td>
                <table role="presentation" style="width:100%;border-collapse:collapse;border:0;border-spacing:0;">${sourcesHtml}</table>
              </td>
            </tr>
            ${reasoningHtml}
        </table>
    </div>
    `
}

export async function formatEventForEmail(event) {
  logger.info(
    { event: { _id: event._id, headline: event.synthesized_headline } },
    'Formatting event card for email.'
  )
  if (!event || typeof event !== 'object' || !event.synthesized_headline) {
    logger.warn(`formatEventForEmail: Invalid event object provided.`, {
      eventPreview: event,
    })
    throw new Error('Invalid event object provided to formatEventForEmail.')
  }
  try {
    const cardHtml = await createEventBriefCard(event)
    logger.info({ eventId: event._id }, 'Successfully formatted event card.')
    return cardHtml
  } catch (error) {
    logger.error(`Error creating event card for email: "${event.synthesized_headline}"`, {
      errorMessage: error.message,
      stack: error.stack,
    })
    throw error
  }
}

```

## 📄 src/modules/email/components/supervisor/costSummary.js
*Lines: 85, Size: 2.57 KB*

```javascript
// apps/pipeline/src/modules/email/components/supervisor/costSummary.js (version 2.0.0)
import { escapeHtml } from '@headlines/utils/src/server.js'

function formatCost(cost) {
  return `$${cost.toFixed(4)}`
}

export function createCostSummaryHtml(runStats) {
  if (!runStats || (!runStats.tokenUsage && !runStats.apiCalls)) {
    return ''
  }

  let totalTokenCost = 0
  let totalApiCost = 0
  let tokenHtml = ''
  let apiHtml = ''

  if (runStats.tokenUsage) {
    const modelsWithUsage = Object.keys(runStats.tokenUsage).filter(
      (model) =>
        runStats.tokenUsage[model].inputTokens > 0 ||
        runStats.tokenUsage[model].outputTokens > 0
    )
    if (modelsWithUsage.length > 0) {
      const tokenRows = modelsWithUsage
        .map((model) => {
          const stats = runStats.tokenUsage[model]
          totalTokenCost += stats.cost
          return `
            <tr>
                <td>${escapeHtml(model)}</td>
                <td>${stats.inputTokens.toLocaleString()}</td>
                <td>${stats.outputTokens.toLocaleString()}</td>
                <td>${formatCost(stats.cost)}</td>
            </tr>`
        })
        .join('')
      tokenHtml = `
        <h3>LLM Token Usage</h3>
        <table>
            <thead><tr><th>Model</th><th>Input Tokens</th><th>Output Tokens</th><th>Est. Cost</th></tr></thead>
            <tbody>${tokenRows}</tbody>
        </table>`
    }
  }

  if (runStats.apiCalls) {
    const servicesWithUsage = Object.keys(runStats.apiCalls).filter(
      (service) => runStats.apiCalls[service].calls > 0
    )
    if (servicesWithUsage.length > 0) {
      const apiRows = servicesWithUsage
        .map((service) => {
          const stats = runStats.apiCalls[service]
          totalApiCost += stats.cost
          return `
            <tr>
                <td>${escapeHtml(service)}</td>
                <td>${stats.calls.toLocaleString()}</td>
                <td>${stats.cost > 0 ? formatCost(stats.cost) : '(Free)'}</td>
            </tr>`
        })
        .join('')
      apiHtml = `
        <h3 style="margin-top: 30px;">Third-Party API Usage</h3>
        <table>
            <thead><tr><th>Service</th><th>Calls</th><th>Est. Cost</th></tr></thead>
            <tbody>${apiRows}</tbody>
        </table>`
    }
  }

  const grandTotalCost = totalTokenCost + totalApiCost

  return `
    <h2>Cost Summary</h2>
    ${tokenHtml}
    ${apiHtml}
    <p style="text-align: right; font-size: 16px; font-weight: bold; margin-top: 20px;">
        Total Estimated Run Cost: <span style="color: #0056b3;">${formatCost(
          grandTotalCost
        )}</span>
    </p>`
}

```

## 📄 src/modules/email/components/supervisor/databaseTables.js
*Lines: 81, Size: 3.38 KB*

```javascript
// apps/pipeline/src/modules/email/components/supervisor/databaseTables.js (version 2.2.0)
import { SynthesizedEvent } from '@headlines/models/src/index.js'
import { settings } from '@headlines/config/src/server.js'
import { truncateString, escapeHtml } from '@headlines/utils/src/server.js'

const sourceIcons = {
    rag_db: '🗄️',
    wikipedia: '🌐',
    news_api: '📰',
};

function formatEnrichmentSources(sources = []) {
    if (sources.length === 0) return 'N/A';
    return sources.map(s => sourceIcons[s] || '❓').join(' ');
}

export async function createEventsTableHtml(runStartDate) {
  const recentEvents = await SynthesizedEvent.find({ createdAt: { $gte: runStartDate } })
    .sort({ createdAt: -1 })
    .limit(50)
    .lean()
  if (recentEvents.length === 0)
    return `<h2>Synthesized Events from this Run</h2><p>No events were synthesized in this run.</p>`
  let tableRows = recentEvents
    .map(
      (event) =>
        `<tr>
            <td>${truncateString(escapeHtml(event.synthesized_headline), 70)}</td>
            <td>${event.highest_relevance_score}</td>
            <td>${formatEnrichmentSources(event.enrichmentSources)}</td>
            <td>${escapeHtml((event.key_individuals || []).map((p) => p.name).join(', ') || 'N/A')}</td>
            <td>${event.emailed ? 'Yes' : 'No'}</td>
        </tr>`
    )
    .join('')
  return `<h2>Synthesized Events (${recentEvents.length})</h2>
    <table>
        <thead><tr><th>Synthesized Headline</th><th>Score</th><th>Enrichment</th><th>Key Individuals</th><th>Emailed?</th></tr></thead>
        <tbody>${tableRows}</tbody>
    </table>`
}

export async function createArticlesTableHtml(runStats) {
  // DEFINITIVE FIX: Use enrichmentOutcomes as the source of truth
  const allArticles = runStats.enrichmentOutcomes || [];
  
  if (allArticles.length === 0)
    return `<h2>All Fresh Articles Processed</h2><p>No new raw articles were processed in the enrichment stage.</p>`

  const relevantArticles = allArticles.filter(
    (a) => a.headlineScore >= settings.HEADLINES_RELEVANCE_THRESHOLD
  )
  const irrelevantCount = runStats.freshHeadlinesFound - relevantArticles.length

  if (relevantArticles.length === 0) {
    return `<h2>All Fresh Articles Processed (${runStats.freshHeadlinesFound})</h2><p>No headlines were deemed relevant (all scored < ${settings.HEADLINES_RELEVANCE_THRESHOLD}).</p>`
  }

  relevantArticles.sort((a, b) => (b.finalScore || b.headlineScore) - (a.finalScore || a.headlineScore));

  let tableRows = relevantArticles
    .map((article) => {
      const status = article.outcome
      const finalScore = article.finalScore ?? 'N/A'
      return `<tr><td><a href="${article.link}" target="_blank">${truncateString(escapeHtml(article.headline), 80)}</a></td><td>${escapeHtml(article.newspaper)}</td><td>${article.headlineScore}</td><td>${finalScore}</td><td>${status}</td></tr>`
    })
    .join('')

  let footer = ''
  if (irrelevantCount > 0) {
    footer = `<p style="margin-top: 15px; font-size: 13px; color: #6c757d;">... plus ${irrelevantCount} other headlines that were deemed irrelevant (score < ${settings.HEADLINES_RELEVANCE_THRESHOLD}).</p>`
  }

  return `<h2>All Fresh Articles Processed (${runStats.freshHeadlinesFound})</h2>
    <table>
        <thead><tr><th>Headline</th><th>Source</th><th>HL Score</th><th>Final Score</th><th>Enrichment Status</th></tr></thead>
        <tbody>${tableRows}</tbody>
    </table>
    ${footer}`
}

```

## 📄 src/modules/email/components/supervisor/enrichmentFunnel.js
*Lines: 61, Size: 2.92 KB*

```javascript
// apps/pipeline/src/modules/email/components/supervisor/enrichmentFunnel.js (version 2.1.0)
import { settings } from '@headlines/config/src/server.js'
import { escapeHtml, truncateString } from '@headlines/utils/src/server.js'

export function createEnrichmentFunnelHtml(runStats) {
  const enrichmentOutcomes = runStats.enrichmentOutcomes || []

  if (runStats.relevantHeadlines === 0) {
    return `<h2>Enrichment Funnel</h2><p>No headlines met the relevance threshold (scored &lt; ${settings.HEADLINES_RELEVANCE_THRESHOLD}).</p>`
  }

  const cardsHtml = enrichmentOutcomes
    .sort((a, b) => (b.headlineScore || 0) - (a.headlineScore || 0))
    .map((item) => {
      const isSuccess = item.outcome.toLowerCase() === 'success'
      const statusClass = isSuccess
        ? 'status-success'
        : item.outcome === 'High-Signal Failure'
          ? 'status-failure'
          : 'status-dropped'
      const statusIcon = isSuccess ? '✅' : '❌'

      let finalScoreText = `Final Score [${item.finalScore ?? 'N/A'}]`
      if (item.agent_disagreement) {
        finalScoreText += ` <strong style="color: #d97706;">(Disagreement)</strong>`
      }

      // DEFINITIVE FIX: Use the actual assessment text and content snippets
      const headlineAssessment = item.assessment_headline || 'N/A';
      const articleAssessment = item.assessment_article || 'N/A';
      const contentSnippet = item.content_snippet ? `${escapeHtml(item.content_snippet)}...` : 'N/A';

      return `
        <div class="card">
            <div class="card-header">
                <h4 style="margin:0; font-size: 16px;">
                    <a href="${item.link}" target="_blank">${escapeHtml(item.headline)}</a>
                </h4>
                <p style="margin: 5px 0 0; font-size: 12px; color: #6c757d;">Source: ${escapeHtml(item.newspaper)}</p>
            </div>
            <div class="card-body">
                <p style="margin: 0 0 10px;"><strong>${statusIcon} Final Outcome:</strong> <span class="${statusClass}">${item.outcome}</span></p>
                <div class="step">
                    <p class="step-title"><strong>Stage 1: Headline Assessment</strong></p>
                    <p class="step-detail">Score [${item.headlineScore}] - <i>${escapeHtml(truncateString(headlineAssessment, 150))}</i></p>
                </div>
                <div class="step">
                    <p class="step-title"><strong>Stage 2: Content Enrichment & Assessment</strong></p>
                    <p class="step-detail">${finalScoreText} - <i>${escapeHtml(truncateString(articleAssessment, 200))}</i></p>
                </div>
                <div class="snippet">
                    <strong>Article Snippet:</strong>
                    <p class="snippet-text">${contentSnippet}</p>
                </div>
            </div>
        </div>`
    })
    .join('')
  return `<h2>Enrichment Funnel Audit Trail (Lifecycle of ${runStats.relevantHeadlines} relevant headlines)</h2>${cardsHtml}`
}

```

## 📄 src/modules/email/components/supervisor/judgeVerdict.js
*Lines: 53, Size: 1.83 KB*

```javascript
// apps/pipeline/src/modules/email/components/supervisor/judgeVerdict.js (version 2.0.0)
import { escapeHtml } from '@headlines/utils/src/server.js'

function getVerdictClass(quality) {
  if (!quality) return 'verdict-neutral'
  const q = quality.toLowerCase()
  if (q === 'excellent' || q === 'good') {
    return 'verdict-positive'
  }
  if (q === 'poor' || q === 'irrelevant') {
    return 'verdict-negative'
  }
  return 'verdict-neutral' // For Acceptable, Marginal
}

export function createJudgeVerdictHtml(judgeVerdict) {
  if (!judgeVerdict) return ''

  let html = '<h2>⚖️ Judge & Arbitrator Verdict</h2>'
  html +=
    '<p>The following is a quality control review of the items generated in this run, intended to provide feedback for prompt engineering and system improvements.</p>'

  const renderJudgements = (judgements) => {
    let content = ''
    if (judgements && judgements.length > 0) {
      judgements.forEach((item) => {
        const verdictClass = getVerdictClass(item.quality)
        content += `
            <div class="card">
                <div class="card-header"><h4 style="margin:0; font-size: 15px;">${escapeHtml(item.identifier)}</h4></div>
                <div class="card-body">
                    <p class="judge-verdict" style="margin:0;">
                        <strong class="${verdictClass}">[${escapeHtml(item.quality)}]</strong> 
                        ${escapeHtml(item.commentary)}
                    </p>
                </div>
            </div>`
      })
    }
    return content
  }

  html += '<h3>Event Judgements</h3>'
  html += renderJudgements(judgeVerdict.event_judgements) || '<p>No events to judge.</p>'

  html += '<h3 style="margin-top: 30px;">Opportunity Judgements</h3>'
  html +=
    renderJudgements(judgeVerdict.opportunity_judgements) ||
    '<p>No opportunities to judge.</p>'

  return html
}

```

## 📄 src/modules/email/components/supervisor/scraperHealth.js
*Lines: 66, Size: 2.49 KB*

```javascript
// apps/pipeline/src/modules/email/components/supervisor/scraperHealth.js (version 2.0.0)
import { escapeHtml } from '@headlines/utils/src/server.js'

export function createScraperFailureAlertHtml(enrichmentOutcomes) {
  if (!enrichmentOutcomes || enrichmentOutcomes.length === 0) return ''

  // Filter for high-signal headlines where content scraping failed.
  const scraperFailures = enrichmentOutcomes.filter(
    (item) =>
      item.outcome === 'High-Signal Failure' ||
      (item.outcome === 'Dropped' &&
        // DEFENSIVE FIX: Check for assessment_article existence before calling .includes()
        (item.assessment_article || '').includes('Enrichment Failed'))
  )

  if (scraperFailures.length === 0) return ''

  let listItems = scraperFailures
    .map((item) => {
      // Differentiate the reason in the email for clarity.
      const reason =
        item.outcome === 'High-Signal Failure'
          ? 'High-Signal Headline - Content Scraping Failed'
          : item.assessment_article

      return `
        <li style="margin-bottom: 12px;">
            <strong>${escapeHtml(item.newspaper)}:</strong> 
            <a href="${item.link}" target="_blank">${escapeHtml(item.headline)}</a><br>
            <em style="font-size:13px; color: #555;">${escapeHtml(reason)}</em>
        </li>`
    })
    .join('')

  return `
    <div class="alert-box alert-danger">
        <h2 style="margin-top:0;">⚠️ Scraper Action Required</h2>
        <p>The following relevant headlines failed the enrichment stage, likely due to an outdated or incorrect article text selector.</p>
        <ul style="padding-left: 20px; margin-top: 15px; font-size: 14px;">${listItems}</ul>
    </div>`
}

export function createScraperHealthTable(healthStats) {
  if (!healthStats || healthStats.length === 0)
    return '<h2>Scraper Health Check</h2><p>No health stats available.</p>'
  let tableRows = healthStats
    .sort((a, b) => a.source.localeCompare(b.source))
    .map((stat) => {
      const status = stat.success ? '✅ OK' : '❌ FAILED'
      const statusColor = stat.success ? '#28a745' : '#dc3545'
      return `
            <tr>
                <td>${escapeHtml(stat.source)}</td>
                <td style="color: ${statusColor}; font-weight: bold;">${status}</td>
                <td>${stat.count}</td>
            </tr>`
    })
    .join('')
  return `
    <h2>Scraper Health Check</h2>
    <table>
        <thead><tr><th>Source</th><th>Status</th><th>Articles Found</th></tr></thead>
        <tbody>${tableRows}</tbody>
    </table>`
}

```

## 📄 src/modules/email/components/supervisor/supervisorEmailBodyBuilder.js
*Lines: 134, Size: 4.75 KB*

```javascript
// apps/pipeline/src/modules/email/components/supervisor/supervisorEmailBodyBuilder.js (version 5.2.2 - Path Fix)
import { SUPERVISOR_EMAIL_CONFIG } from '../../../../config/index.js'
import { createSupervisorEmailWrapper } from '../../templates/supervisorWrapper.js'
import {
  createScraperHealthTable,
  createScraperFailureAlertHtml,
} from './scraperHealth.js'
import { createEnrichmentFunnelHtml } from './enrichmentFunnel.js'
import { createEventsTableHtml, createArticlesTableHtml } from './databaseTables.js'
import { createJudgeVerdictHtml } from './judgeVerdict.js'
import { createCostSummaryHtml } from './costSummary.js'
import { SynthesizedEvent, Opportunity } from '@headlines/models/src/index.js'
import { executiveSummaryChain } from '@headlines/ai-services/src/index.js'
import { logger } from '@headlines/utils/src/logger.js';

function createPerformanceDashboardHtml(runStats, newEventCount, newOpportunityCount) {
  const funnel = `${runStats.headlinesScraped} Scraped ➔ ${runStats.relevantHeadlines} Relevant ➔ ${runStats.eventsSynthesized} Events ➔ ${newOpportunityCount} Opps`
  const totalCost =
    (runStats.tokenUsage
      ? Object.values(runStats.tokenUsage).reduce((acc, model) => acc + model.cost, 0)
      : 0) +
    (runStats.apiCalls
      ? Object.values(runStats.apiCalls).reduce((acc, service) => acc + service.cost, 0)
      : 0)

  return `
        <h2>Performance Dashboard</h2>
        <table class="dashboard">
            <tr>
                <th>Funnel</th>
                <td>${funnel}</td>
            </tr>
            <tr>
                <th>New Events Created</th>
                <td>${newEventCount}</td>
            </tr>
            <tr>
                <th>Est. Run Cost</th>
                <td>$${totalCost.toFixed(4)}</td>
            </tr>
             <tr>
                <th>Errors</th>
                <td style="color: ${runStats.errors?.length > 0 ? '#dc3545' : '#28a745'}; font-weight: bold;">${runStats.errors?.length || 0}</td>
            </tr>
        </table>
    `
}

export async function createSupervisorEmailBody(runStats) {
  const runTimestamp = new Date().toLocaleString('en-GB', {
    timeZone: 'Europe/Copenhagen',
  })
  const runStartDate = new Date(Date.now() - 20 * 60 * 1000)

  const [newEventCount, newOpportunityCount] = await Promise.all([
    SynthesizedEvent.countDocuments({ createdAt: { $gte: runStartDate } }),
    Opportunity.countDocuments({ createdAt: { $gte: runStartDate } }),
  ])

  const executiveSummaryPayload = {
    freshHeadlinesFound: runStats.freshHeadlinesFound,
    judgeVerdict: runStats.judgeVerdict || {
      event_judgements: [],
      opportunity_judgements: [],
    },
  }

  const executiveSummaryResult = await executiveSummaryChain({
    payload_json_string: JSON.stringify(executiveSummaryPayload),
  })
  const executiveSummary =
    executiveSummaryResult.summary || 'AI failed to generate a summary for this run.'

  const scraperFailureAlertHtml = createScraperFailureAlertHtml(
    runStats.enrichmentOutcomes
  )

  const executiveSummaryHtml = executiveSummary
    ? `<div class="alert-box alert-info">
          <h2 style="margin-top:0;">🤖 Executive Summary</h2>
          <p style="font-style: italic; font-size: 15px;">"${executiveSummary}"</p>
      </div>`
    : ''

  const dashboardHtml = createPerformanceDashboardHtml(
    runStats,
    newEventCount,
    newOpportunityCount
  )

  const [
    scraperHealthHtml,
    enrichmentFunnelHtml,
    judgeVerdictHtml,
    eventsTableHtml,
    articlesTableHtml,
    costSummaryHtml,
  ] = await Promise.all([
    createScraperHealthTable(runStats.scraperHealth),
    createEnrichmentFunnelHtml(runStats),
    createJudgeVerdictHtml(runStats.judgeVerdict),
    createEventsTableHtml(runStartDate),
    createArticlesTableHtml(runStats),
    createCostSummaryHtml(runStats),
  ])

  const bodyContent = `
        <div style="text-align:center; margin-bottom: 30px;">
            <h1>${SUPERVISOR_EMAIL_CONFIG.subject}</h1>
            <p style="font-size: 16px; color: #6c757d;">Run completed: ${runTimestamp}</p>
        </div>
        
        <!-- BLUF SECTION -->
        ${executiveSummaryHtml}
        ${scraperFailureAlertHtml} 
        ${dashboardHtml}
        ${costSummaryHtml}

        <!-- APPENDICES -->
        <div class="appendix-section">
            ${judgeVerdictHtml}
            ${enrichmentFunnelHtml}
            ${eventsTableHtml}
            ${articlesTableHtml}
            ${scraperHealthHtml}
        </div>

        <div style="text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #dee2e6; font-size: 12px; color: #6c757d;">
            <p>This is an automated report from the ${SUPERVISOR_EMAIL_CONFIG.brandName}.</p>
        </div>`

  return createSupervisorEmailWrapper(bodyContent, SUPERVISOR_EMAIL_CONFIG.subject)
}

```

## 📄 src/modules/email/constants.js
*Lines: 9, Size: 337 Bytes*

```javascript
// src/modules/email/constants.js (version 2.1)
// src/modules/email/constants.js

// Define the Content-ID (CID) for the embedded logo.
// This acts as an internal URL within the email itself.
export const LOGO_CID = 'logo@wealthevents.email';

// Define the local path to the logo file.
export const LOGO_PATH = './public/bullion.png';
```

## 📄 src/modules/email/emailDispatcher.js
*Lines: 131, Size: 4.36 KB*

```javascript
// apps/pipeline/src/modules/notifications/emailDispatcher.js (version 4.0.1)
import { groupItemsByCountry, getCountryFlag } from '@headlines/utils/src/server.js'
import { logger } from '@headlines/utils/src/server.js'
import { createPersonalizedEmailBody } from '../email/components/emailBodyBuilder.js'
import { sendWealthEventsEmail } from '../email/mailer.js'
import {
  emailSubjectChain,
  emailIntroChain,
  translateChain,
} from '@headlines/ai-services/src/index.js'

export async function sendBulkEmails(emailQueue) {
  if (emailQueue.length === 0) return 0

  const isDryRun = process.env.DRY_RUN === 'true'
  if (isDryRun) {
    logger.warn(
      'DRY RUN MODE: Email dispatch is being simulated. No actual emails will be sent.'
    )
    let simulatedSuccessCount = 0
    for (const { user, events } of emailQueue) {
      if (events && events.length > 0) {
        logger.info(
          `[DRY RUN] Would have sent ${user.language} email to ${user.email} with ${events.length} events.`
        )
        simulatedSuccessCount++
      }
    }
    return simulatedSuccessCount
  }

  logger.info(
    `Dispatching ${emailQueue.length} personalized emails with AI-powered copy...`
  )
  let successCount = 0

  for (const { user, events, opportunities } of emailQueue) {
    try {
      if (!events || events.length === 0) {
        logger.info(`Skipping email for ${user.email} as it contained no valid events.`)
        continue
      }

      // --- AI-Powered Subject and Intro Generation ---
      const eventsByCountry = groupItemsByCountry(events, 'country')
      const primaryCountry = Object.keys(eventsByCountry)[0]
      const countryFlag = getCountryFlag(primaryCountry)

      const eventPayloadForAI = events.map((e) => ({
        headline: e.synthesized_headline,
        summary: e.synthesized_summary,
      }))

      // DEFINITIVE FIX: Use direct await calls instead of .invoke
      const [subjectResult, introResult] = await Promise.all([
        emailSubjectChain({
          events_json_string: JSON.stringify(eventPayloadForAI),
        }),
        emailIntroChain({
          payload_json_string: JSON.stringify({
            firstName: user.firstName,
            events: eventPayloadForAI,
          }),
        }),
      ])

      const aiSubject = subjectResult.subject_headline || 'Key Developments'

      const aiIntro = introResult.error
        ? {
            greeting: `Dear ${user.firstName},`,
            body: 'Here are the latest relevant wealth events we have identified for your review.',
            bullets: events
              .slice(0, 2)
              .map(
                (e) =>
                  `A key development regarding ${e.synthesized_headline.substring(0, 40)}...`
              ),
            signoff: 'We wish you a fruitful day!\\n\\nThe team at Wealth Watch',
          }
        : introResult

      const subject = `${countryFlag} Wealth News (${events.length}): ${aiSubject}`

      const htmlBody = await createPersonalizedEmailBody(
        user,
        eventsByCountry,
        subject,
        aiIntro
      )

      if (!htmlBody) {
        logger.error(`Failed to generate email body for ${user.email}. Skipping.`)
        continue
      }

      let finalHtmlBody = htmlBody
      const targetLanguage = user.language || 'English'

      if (targetLanguage !== 'English') {
        logger.info(`Translating email for ${user.email} into ${targetLanguage}...`)
        // DEFINITIVE FIX: Use direct await calls instead of .invoke
        const translationResult = await translateChain({
          language: targetLanguage,
          html_content: htmlBody,
        })
        if (translationResult.error) {
          logger.error(
            { err: translationResult.error, user: user.email },
            `AI translation to ${targetLanguage} failed. Sending in English as a fallback.`
          )
        } else {
          finalHtmlBody = translationResult.translated_html
          logger.info(`Successfully translated email for ${user.email}.`)
        }
      }

      const mailOptions = { to: user.email, subject, html: finalHtmlBody }
      const wasSent = await sendWealthEventsEmail(mailOptions)
      if (wasSent) successCount++
    } catch (error) {
      logger.error(
        { err: error, user: user.email },
        'A critical, unhandled error occurred during the email dispatch loop for a user. Skipping this user.'
      )
    }
  }

  return successCount
}

```

## 📄 src/modules/email/index.js
*Lines: 39, Size: 1.19 KB*

```javascript
// apps/pipeline/src/modules/email/index.js (version 3.0.0)
import { logger } from '@headlines/utils/src/server.js';
import { performActualSupervisorEmailSend } from './mailer.js'
import { Subscriber } from '@headlines/models/src/index.js'

/**
 * Coordinates sending the supervisor report email.
 * @param {Object} runStats - Statistics about the current pipeline run.
 */
export async function sendSupervisorReportEmail(runStats) {
  if (!runStats) {
    logger.error('No runStats provided for supervisor report. Skipping email.')
    return
  }

  logger.info('Preparing supervisor report email...')

  try {
    const superUsers = await Subscriber.find({
      isActive: true,
      role: 'admin',
    })
      .select('email')
      .lean()

    const superUserEmails = superUsers.map((user) => user.email)

    if (superUserEmails.length === 0) {
      logger.warn('No admin users found. Skipping supervisor report.')
      return
    }

    await performActualSupervisorEmailSend(runStats, superUserEmails)
    logger.info('✅ Supervisor report email successfully sent/queued to all superusers.')
  } catch (error) {
    logger.error({ err: error }, '💥 CRITICAL: Failed to send supervisor report email.')
  }
}

```

## 📄 src/modules/email/mailer.js
*Lines: 80, Size: 2.65 KB*

```javascript
// apps/pipeline/src/modules/email/mailer.js (version 3.0.3 - Path Fix)
import nodemailer from 'nodemailer'
import { logger } from '@headlines/utils/src/logger.js';
import { safeExecute } from '@headlines/utils/src/server.js';
import { SMTP_CONFIG, SUPERVISOR_EMAIL_CONFIG } from '../../config/index.js'
import { createSupervisorEmailBody } from './components/supervisor/supervisorEmailBodyBuilder.js'

async function sendEmail(mailOptions, emailType) {
  if (!SMTP_CONFIG?.auth?.user || !SMTP_CONFIG?.auth?.pass) {
    logger.error(`❌ [${emailType} Mailer] SMTP authentication not fully configured.`)
    return { error: 'SMTP authentication not fully configured.' }
  }

  logger.info(
    `📤 [${emailType} Mailer] Sending email via Nodemailer to: ${mailOptions.to}.`
  )

  const transporter = nodemailer.createTransport(SMTP_CONFIG)

  const sendResult = await safeExecute(() => transporter.sendMail(mailOptions), {
    errorHandler: (error) => {
      logger.error(`❌ [${emailType} Mailer] Nodemailer SMTP error:`, {
        message: error.message,
        code: error.code,
      })
      return { errorOccurred: true, details: error.message }
    },
  })

  if (sendResult && sendResult.errorOccurred) {
    return { error: `SMTP Error: ${sendResult.details}` }
  }

  logger.info(`✅ [${emailType} Mailer] Email sent successfully to ${mailOptions.to}.`)
  return { success: true }
}

export async function sendWealthEventsEmail({ to, subject, html }) {
  if (!to) {
    logger.error(`❌ [Wealth Events Mailer] Invalid 'to' address provided.`)
    return false
  }
  const mailOptions = {
    from: `"${SMTP_CONFIG.fromName}" <${SMTP_CONFIG.fromAddress}>`,
    to: to,
    cc: 'reconozco@gmail.com',
    subject: subject,
    html: html,
  }
  const result = await sendEmail(mailOptions, 'Wealth Events')
  return result.success || false
}

export async function performActualSupervisorEmailSend(runStats, recipients) {
  if (!recipients || recipients.length === 0) {
    logger.warn(
      '[Supervisor Mailer] Skipping: No superusers configured to receive this report.'
    )
    return
  }

  const emailBodyHtml = await createSupervisorEmailBody(runStats)
  if (!emailBodyHtml) {
    logger.error('❌ [Supervisor Mailer] HTML email body generation failed.')
    throw new Error('Failed to generate supervisor email body')
  }

  const mailOptions = {
    from: `"${SMTP_CONFIG.fromName}" <${SMTP_CONFIG.fromAddress}>`,
    to: recipients.join(', '),
    subject: SUPERVISOR_EMAIL_CONFIG.subject,
    html: emailBodyHtml,
  }

  const result = await sendEmail(mailOptions, 'Supervisor Report')
  if (result.error) {
    throw new Error(`Failed to send supervisor email: ${result.error}`)
  }
}

```

## 📄 src/modules/email/templates/supervisorWrapper.js
*Lines: 49, Size: 2.87 KB*

```javascript
// apps/pipeline/src/modules/email/templates/supervisorWrapper.js (version 2.0)
/**
 * Provides the HTML shell and CSS for the supervisor report email.
 * @param {string} bodyContent - The pre-compiled HTML content of the report.
 * @param {string} subject - The email subject.
 * @returns {string} The full HTML document for the email.
 */
export function createSupervisorEmailWrapper(bodyContent, subject) {
  return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${subject}</title>
        <style>
            body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: #f8f9fa; color: #212529; }
            .container { max-width: 1200px; margin: 20px auto; background-color: #ffffff; padding: 40px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); }
            h1, h2, h3, h4 { margin-top: 0; margin-bottom: 1rem; font-weight: 600; color: #343a40; }
            h1 { font-size: 28px; }
            h2 { font-size: 22px; border-bottom: 1px solid #dee2e6; padding-bottom: 10px; margin-top: 40px; }
            p { margin-top: 0; margin-bottom: 1rem; line-height: 1.6; }
            table { width: 100%; border-collapse: collapse; font-size: 14px; margin-bottom: 20px; }
            th, td { padding: 12px 15px; text-align: left; border-bottom: 1px solid #dee2e6; }
            th { background-color: #f1f3f5; font-weight: 600; }
            tr:nth-child(even) { background-color: #f8f9fa; }
            a { color: #007bff; text-decoration: none; }
            .alert-box { border-left-width: 4px; border-radius: 4px; padding: 20px; margin: 20px 0; }
            .alert-danger { background-color: #f8d7da; border-left-color: #f5c6cb; color: #721c24; }
            .alert-danger h2 { color: #721c24; }
            .alert-info { background-color: #cce5ff; border-left-color: #b8daff; color: #004085; }
            .alert-info h2 { color: #004085; }
            .card { border: 1px solid #dee2e6; border-radius: 8px; margin-bottom: 20px; background-color: #ffffff; }
            .card-header { padding: 15px; border-bottom: 1px solid #dee2e6; background-color: #f8f9fa; }
            .card-body { padding: 20px; }
            .judge-verdict { border-left: 4px solid #17a2b8; padding-left: 15px; font-style: italic; color: #495057; }
            .verdict-positive { color: #28a745; font-weight: 600; }
            .verdict-negative { color: #dc3545; font-weight: 600; }
            .dashboard { table-layout: fixed; }
            .dashboard th { width: 30%; background-color: #f8f9fa; }
            .appendix-section { margin-top: 50px; padding-top: 30px; border-top: 2px solid #adb5bd;}
        </style>
    </head>
    <body>
        <div class="container">${bodyContent}</div>
    </body>
    </html>`
}

```

## 📄 src/modules/notifications/emailDispatcher.js
*Lines: 135, Size: 4.31 KB*

```javascript
// apps/pipeline/src/modules/notifications/emailDispatcher.js
import { groupItemsByCountry, getCountryFlag } from '@headlines/utils/src/server.js'
import { logger, auditLogger } from '@headlines/utils/src/server.js'
import { createPersonalizedEmailBody } from '../email/components/emailBodyBuilder.js'
import { sendWealthEventsEmail } from '../email/mailer.js'
import {
  emailSubjectChain,
  emailIntroChain,
  translateChain,
} from '@headlines/ai-services/src/index.js'

export async function sendBulkEmails(emailQueue) {
  if (emailQueue.length === 0) return 0

  const isDryRun = process.env.DRY_RUN === 'true'
  if (isDryRun) {
    logger.warn(
      'DRY RUN MODE: Email dispatch is being simulated. No actual emails will be sent.'
    )
    let simulatedSuccessCount = 0
    for (const { user, events } of emailQueue) {
      if (events && events.length > 0) {
        logger.info(
          `[DRY RUN] Would have sent ${user.language} email to ${user.email} with ${events.length} events.`
        )
        simulatedSuccessCount++
      }
    }
    return simulatedSuccessCount
  }

  logger.info(
    `Dispatching ${emailQueue.length} personalized emails with AI-powered copy...`
  )
  let successCount = 0

  for (const { user, events, opportunities } of emailQueue) {
    try {
      if (!events || events.length === 0) {
        logger.info(`Skipping email for ${user.email} as it contained no valid events.`)
        continue
      }

      const eventsByCountry = groupItemsByCountry(events, 'country')
      const primaryCountry = Object.keys(eventsByCountry)[0]
      const countryFlag = getCountryFlag(primaryCountry)

      const eventPayloadForAI = events.map((e) => ({
        headline: e.synthesized_headline,
        summary: e.synthesized_summary,
      }))

      const [subjectResult, introResult] = await Promise.all([
        emailSubjectChain({
          events_json_string: JSON.stringify(eventPayloadForAI),
        }),
        emailIntroChain({
          payload_json_string: JSON.stringify({
            firstName: user.firstName,
            events: eventPayloadForAI,
          }),
        }),
      ])

      const aiSubject = subjectResult.subject_headline || 'Key Developments'

      const aiIntro = introResult.error
        ? {
            greeting: `Dear ${user.firstName},`,
            body: 'Here are the latest relevant wealth events we have identified for your review.',
            bullets: events
              .slice(0, 2)
              .map(
                (e) =>
                  `A key development regarding ${e.synthesized_headline.substring(0, 40)}...`
              ),
            signoff: 'We wish you a fruitful day!\\n\\nThe team at Wealth Watch',
          }
        : introResult

      const subject = `${countryFlag} Wealth News (${events.length}): ${aiSubject}`

      const htmlBody = await createPersonalizedEmailBody(
        user,
        eventsByCountry,
        subject,
        aiIntro
      )

      if (!htmlBody) {
        logger.error(`Failed to generate email body for ${user.email}. Skipping.`)
        continue
      }

      let finalHtmlBody = htmlBody
      const targetLanguage = user.language || 'English'

      if (targetLanguage !== 'English') {
        logger.info(`Translating email for ${user.email} into ${targetLanguage}...`)
        const translationResult = await translateChain({
          language: targetLanguage,
          html_content: htmlBody,
        })
        if (translationResult.error) {
          logger.error(
            { err: translationResult.error, user: user.email },
            `AI translation to ${targetLanguage} failed. Sending in English as a fallback.`
          )
        } else {
          finalHtmlBody = translationResult.translated_html
          logger.info(`Successfully translated email for ${user.email}.`)
        }
      }

      auditLogger.info(
        { context: { recipient: user.email, subject, event_count: events.length } },
        'Preparing to Send User Email'
      )
      const wasSent = await sendWealthEventsEmail({
        to: user.email,
        subject,
        html: finalHtmlBody,
      })
      if (wasSent) successCount++
    } catch (error) {
      logger.error(
        { err: error, user: user.email },
        'A critical, unhandled error occurred during the email dispatch loop for a user. Skipping this user.'
      )
    }
  }

  return successCount
}

```

## 📄 src/modules/notifications/index.js
*Lines: 104, Size: 3.64 KB*

```javascript
// apps/pipeline/src/modules/notifications/index.js (version 2.2.0)
import { groupItemsByCountry } from '@headlines/utils/src/server.js';
import { logger } from '@headlines/utils/src/server.js';
import { Subscriber, PushSubscription } from '@headlines/models/src/index.js'
import { sendBulkEmails } from './emailDispatcher.js'
import { sendBulkPushNotifications } from './pushService.js'

export async function sendNotifications(newEvents, newOpportunities = []) {
  logger.info(
    `📧 Starting personalized notification dispatch for ${newEvents.length} events and ${newOpportunities.length} opportunities.`
  )

  const [activeSubscribers, allPushSubscriptions] = await Promise.all([
    Subscriber.find({ isActive: true }).lean(),
    PushSubscription.find().lean(),
  ])

  if (activeSubscribers.length === 0) {
    logger.info('No active subscribers found. Skipping notification dispatch.');
    return { emailSentCount: 0, pushSentCount: 0 };
  }

  const pushSubsByUserId = allPushSubscriptions.reduce((acc, sub) => {
    if (!sub.subscriberId) return acc;
    const userId = sub.subscriberId.toString();
    if (!acc[userId]) acc[userId] = [];
    acc[userId].push(sub);
    return acc;
  }, {});

  const eventsByCountry = groupItemsByCountry(newEvents, 'country');
  const opportunitiesByCountry = groupItemsByCountry(newOpportunities, 'basedIn');

  const emailQueue = [];
  const pushQueue = [];

  for (const user of activeSubscribers) {
    const userCountries = new Set(
      (user.countries || []).filter((c) => c.active).map((c) => c.name)
    );
    if (userCountries.size === 0) continue;

    const userEvents = filterItemsForUser(eventsByCountry, userCountries);
    const userOpportunities = filterItemsForUser(opportunitiesByCountry, userCountries);

    if (userEvents.length === 0 && userOpportunities.length === 0) continue;

    if (user.emailNotificationsEnabled && userEvents.length > 0) { // Only queue email if there are events
      emailQueue.push({ user, events: userEvents, opportunities: userOpportunities });
    }
    
    const userPushSubs = pushSubsByUserId[user._id.toString()] || [];
    if (user.pushNotificationsEnabled && userPushSubs.length > 0) {
      pushQueue.push({ subscriptions: userPushSubs, events: userEvents, opportunities: userOpportunities });
    }
  }
  
  if (emailQueue.length === 0 && pushQueue.length === 0) {
      logger.warn('No users were subscribed to the countries of the generated events. No notifications will be sent.');
      return { emailSentCount: 0, pushSentCount: 0 };
  }

  const [emailSentCount, pushSentCount] = await Promise.all([
    sendBulkEmails(emailQueue),
    sendBulkPushNotifications(pushQueue),
  ]);
  
  // --- UPDATE COUNTERS ---
  if (emailSentCount > 0) {
    const bulkOps = emailQueue.map(({ user, events }) => ({
      updateOne: {
        filter: { _id: user._id },
        update: {
          $inc: {
            emailSentCount: 1,
            eventsReceivedCount: events.length,
          },
        },
      },
    }));
    try {
      await Subscriber.bulkWrite(bulkOps);
      logger.info(`Successfully updated engagement counters for ${bulkOps.length} subscribers.`);
    } catch (error) {
      logger.error({ err: error }, "Failed to update subscriber engagement counters.");
    }
  }

  logger.info(
    `✅ Notification dispatch complete. Emails Sent: ${emailSentCount}, Push Notifications Sent: ${pushSentCount}.`
  );
  return { emailSentCount, pushSentCount };
}

function filterItemsForUser(itemsByCountry, userCountries) {
  const userItems = [];
  for (const country of userCountries) {
    if (itemsByCountry[country]) {
      userItems.push(...itemsByCountry[country]);
    }
  }
  return userItems;
}

```

## 📄 src/modules/notifications/pushService.js
*Lines: 77, Size: 2.5 KB*

```javascript
// apps/pipeline/src/modules/notifications/pushService.js (version 3.0.0)
import { logger } from '@headlines/utils/src/server.js';
import { PushSubscription } from '@headlines/models/src/index.js'
import { webpush, isPushConfigured } from '@headlines/scraper-logic/src/push/client.js'

function createPushPayload(events, opportunities) {
  let title = 'New Intelligence Alert'
  let body = ''
  let url = '/events' // Default URL

  const eventCount = events.length
  const oppCount = opportunities.length

  if (eventCount > 0 && oppCount > 0) {
    title = `${eventCount} New Event(s), ${oppCount} New Opportunity/ies`
    body = `Primary Event: ${events[0].synthesized_headline}`
    url = `/events`
  } else if (eventCount > 0) {
    title = `${eventCount} New Wealth Event(s) Detected`
    body = events[0].synthesized_headline
    url = `/events`
  } else if (oppCount > 0) {
    title = `${oppCount} New Opportunity/ies Identified`
    body = `New contact: ${opportunities[0].reachOutTo} (~$${opportunities[0].likelyMMDollarWealth}M)`
    url = `/opportunities`
  }

  return {
    title,
    body,
    url,
    icon: '/icons/icon-192x192.png',
  }
}

export async function sendBulkPushNotifications(pushQueue) {
  if (!isPushConfigured || pushQueue.length === 0) {
    return 0
  }

  logger.info(`Dispatching push notifications to ${pushQueue.length} user group(s)...`)
  let successCount = 0

  const allPromises = []

  for (const { subscriptions, events, opportunities } of pushQueue) {
    const payload = createPushPayload(events, opportunities)
    const notificationPayload = JSON.stringify(payload)

    for (const subscription of subscriptions) {
      const pushPromise = webpush
        .sendNotification(subscription, notificationPayload)
        .then(() => {
          successCount++
          logger.info(`✅ Pushed to endpoint for user ${subscription.subscriberId}`)
        })
        .catch((error) => {
          if (error.statusCode === 410 || error.statusCode === 404) {
            logger.info(
              `Subscription expired or invalid for endpoint. Deleting: ${subscription.endpoint}`
            )
            return PushSubscription.deleteOne({ _id: subscription._id })
          } else {
            logger.error(
              { err: { message: error.message, statusCode: error.statusCode } },
              `Failed to send push notification to user ${subscription.subscriberId}`
            )
          }
        })
      allPromises.push(pushPromise)
    }
  }

  await Promise.all(allPromises)
  return successCount
}

```

## 📄 src/modules/realtime/index.js
*Lines: 83, Size: 2.54 KB*

```javascript
// apps/pipeline/src/modules/realtime/index.js (version 4.0.0)
import Pusher from 'pusher'
import { logger } from '@headlines/utils/src/server.js';
import { env } from '@headlines/config/src/server.js'

let pusher
let isRealtimeConfigured = false

export function configureRealtime() {
    if (isRealtimeConfigured) return;

    const { PUSHER_APP_ID, PUSHER_KEY, PUSHER_SECRET, PUSHER_CLUSTER } = env
    if (PUSHER_APP_ID && PUSHER_KEY && PUSHER_SECRET && PUSHER_CLUSTER) {
        pusher = new Pusher({
            appId: PUSHER_APP_ID,
            key: PUSHER_KEY,
            secret: PUSHER_SECRET,
            cluster: PUSHER_CLUSTER,
            useTLS: true,
        });
        isRealtimeConfigured = true;
        logger.info('✅ Real-time notification service (Pusher) configured.')
    } else {
        logger.warn(
            'Pusher credentials not fully configured. Real-time updates will be disabled.'
        )
    }
}


/**
 * A generic helper to stream a new data item to a specific channel.
 * @param {string} channel - The channel to publish on (e.g., 'articles-channel').
 * @param {string} event - The event name to trigger (e.g., 'new-article').
 * @param {object} data - The JSON payload to send.
 */
async function streamNewItem(channel, event, data) {
  if (!isRealtimeConfigured || !pusher) {
    return
  }
  try {
    logger.info(`📢 Streaming new item on channel '${channel}' with event '${event}'.`)
    await pusher.trigger(channel, event, data)
  } catch (error) {
    logger.error(
      { err: error, channel, event },
      'Failed to trigger Pusher real-time event.'
    )
  }
}

/**
 * Streams a newly synthesized event to all connected clients.
 * @param {object} event - The full synthesized event Mongoose document.
 */
export async function streamNewEvent(event) {
  if (typeof event.toRealtimePayload !== 'function') {
    logger.error(
      { eventId: event._id },
      'Event object is missing toRealtimePayload method.'
    )
    return
  }
  const payload = event.toRealtimePayload()
  await streamNewItem('events-channel', 'new-event', payload)
}

/**
 * Streams a newly identified relevant article to all connected clients.
 * @param {object} article - The full article Mongoose document.
 */
export async function streamNewArticle(article) {
  if (typeof article.toRealtimePayload !== 'function') {
    logger.error(
      { articleId: article._id },
      'Article object is missing toRealtimePayload method.'
    )
    return
  }
  const payload = article.toRealtimePayload()
  await streamNewItem('articles-channel', 'new-article', payload)
}

```

## 📄 src/orchestrator.js
*Lines: 148, Size: 5.33 KB*

```javascript
// apps/pipeline/src/orchestrator.js (version 14.2.0)
import { logger } from '@headlines/utils/src/logger.js'
import { tokenTracker, apiCallTracker } from '@headlines/utils/src/server.js'
import { logFinalReport } from './utils/pipelineLogger.js'
import { runPreFlightChecks } from './pipeline/1_preflight.js'
import { runScrapeAndFilter } from './pipeline/2_scrapeAndFilter.js'
import { runAssessAndEnrich } from './pipeline/3_assessAndEnrich.js'
import { runClusterAndSynthesize } from './pipeline/4_clusterAndSynthesize.js'
import { runCommitAndNotify } from './pipeline/5_commitAndNotify.js'
import { suggestNewWatchlistEntities } from './pipeline/6_suggestNewWatchlistEntities.js'
import { runSelfHealAndOptimize } from './pipeline/7_selfHealAndOptimize.js'
import { updateSourceAnalytics } from './pipeline/submodules/commit/4_updateSourceAnalytics.js'
import { settings } from '@headlines/config/src/server.js'
import { RunVerdict } from '@headlines/models/src/index.js'

async function saveRunVerdict(payload, duration) {
  if (payload.dbConnection && !payload.noCommitMode && !payload.useTestPayload) {
    try {
      const runVerdict = new RunVerdict({
        runStats: payload.runStats,
        judgeVerdict: payload.runStats.judgeVerdict || {},
        generatedEvents: (payload.savedEvents || []).map((e) => e._id),
        generatedOpportunities: (payload.savedOpportunities || []).map((o) => o._id),
        duration_seconds: duration,
        cost_summary: {
          tokens: payload.runStats.tokenUsage,
          apis: payload.runStats.apiCalls,
        },
      })
      await runVerdict.save()
    } catch (error) {
      logger.error({ err: error }, 'Failed to save the run verdict.')
      payload.runStats.errors.push('VERDICT_SAVE_FAILED: ' + error.message)
    }
  }
}

export async function runPipeline(options) {
  const runStartTime = Date.now()
  let success = true

  apiCallTracker.reset()

  let currentPayload = {
    ...options,
    runStats: {
      headlinesScraped: 0,
      scraperHealth: [],
      validatedHeadlines: 0,
      freshHeadlinesFound: 0,
      headlinesAssessed: 0,
      relevantHeadlines: 0,
      articlesEnriched: 0,
      relevantArticles: 0,
      eventsClustered: 0,
      eventsSynthesized: 0,
      synthesizedEventsForReport: [],
      enrichmentOutcomes: [],
      judgeVerdict: null,
      eventsEmailed: 0,
      errors: [],
      tokenUsage: {},
      apiCalls: {},
    },
    dbConnection: false,
  }

  try {
    const preflight = await runPreFlightChecks(currentPayload)
    if (!preflight.success) {
      success = false
      currentPayload.runStats.errors.push('Preflight checks failed.')
      return { success, payload: currentPayload }
    }
    currentPayload = preflight.payload

    tokenTracker.initializeModels([
      settings.LLM_MODEL_HEADLINE_ASSESSMENT,
      settings.LLM_MODEL_ARTICLE_ASSESSMENT,
      settings.LLM_MODEL_SYNTHESIS,
      settings.LLM_MODEL_UTILITY,
    ])

    if (options.useTestPayload) {
      logger.warn('--- USING TEST PAYLOAD ---')
      const { testArticles } = await import('../scripts/test-pipeline/test-payload.js')
      currentPayload.articlesForPipeline = testArticles
      currentPayload.runStats.freshHeadlinesFound = testArticles.length
    } else {
      const scrape = await runScrapeAndFilter(currentPayload)
      currentPayload = scrape.payload
    }

    // DEFINITIVE FIX: This logic block ensures AI stages run if there are articles.
    if (
      currentPayload.articlesForPipeline &&
      currentPayload.articlesForPipeline.length > 0
    ) {
      const assess = await runAssessAndEnrich(currentPayload)
      currentPayload = assess.payload
      if (currentPayload.enrichedArticles && currentPayload.enrichedArticles.length > 0) {
        const synthesize = await runClusterAndSynthesize(currentPayload)
        currentPayload = synthesize.payload
      }
    } else {
      logger.info('No fresh articles to process. Skipping AI analysis stages.')
    }

    currentPayload.runStats.tokenUsage = tokenTracker.getStats()
    currentPayload.runStats.apiCalls = apiCallTracker.getStats()

    if (!options.useTestPayload) {
      await updateSourceAnalytics(currentPayload)

      if (
        currentPayload.synthesizedEvents &&
        currentPayload.synthesizedEvents.length > 0
      ) {
        const commit = await runCommitAndNotify(currentPayload)
        currentPayload = commit.payload
        await suggestNewWatchlistEntities(currentPayload)
      } else {
        logger.info(
          'No new events were synthesized. Skipping commit and notification stages, but sending a supervisor report.'
        )
        const { sendSupervisorReportEmail } = await import('./modules/email/index.js')
        await sendSupervisorReportEmail(currentPayload.runStats)
      }
    }
  } catch (error) {
    success = false
    logger.fatal(
      { err: error },
      'A critical, unhandled error occurred in the orchestrator.'
    )
    currentPayload.runStats.errors.push(`ORCHESTRATOR_FATAL: ${error.message}`)
  } finally {
    const runEndTime = Date.now()
    const durationInSeconds = (runEndTime - runStartTime) / 1000
    currentPayload.runStats.tokenUsage = tokenTracker.getStats()
    currentPayload.runStats.apiCalls = apiCallTracker.getStats()

    await saveRunVerdict(currentPayload, durationInSeconds)
    await logFinalReport(currentPayload.runStats, durationInSeconds)
  }
  return { success }
}

```

## 📄 src/pipeline/1_preflight.js
*Lines: 57, Size: 2.19 KB*

```javascript
// apps/pipeline/src/pipeline/1_preflight.js (version 7.3.0)
import { logger } from '@headlines/utils/src/server.js';
import { configure as configureScraperLogic } from '@headlines/scraper-logic/src/config.js'
import * as appConfig from '@headlines/config/src/server.js'
import { refreshConfig, configStore } from '../config/dynamicConfig.js'
import { initializeSettings, settings } from '@headlines/config/src/server.js'
import dbConnect from '@headlines/data-access/src/dbConnect.js'
import { deleteTodaysDocuments } from '../../scripts/maintenance/delete-today.js'
import * as aiServices from '@headlines/ai-services/src/index.js'
import { performDatabaseHousekeeping } from '../utils/housekeeping.js';
import { configurePush } from '@headlines/scraper-logic/src/push/client.js';
import { configureRealtime } from '../modules/realtime/index.js';
import { testRedisConnection } from '../utils/redisClient.js';

export async function runPreFlightChecks(pipelinePayload) {
  await dbConnect()
  pipelinePayload.dbConnection = true

  if (pipelinePayload.deleteToday) {
      logger.warn('--- DELETE TODAY MODE ENABLED ---');
      await deleteTodaysDocuments(true);
  }

  // Load crucial settings before anything else
  await initializeSettings()
  await refreshConfig()
  
  // Now that env vars and settings are loaded, configure external services
  configurePush();
  configureRealtime();

  // New Redis Pre-flight Check
  if (!(await testRedisConnection())) {
    logger.fatal('Redis pre-flight check failed. Aborting pipeline.');
    return { success: false };
  }

  const utilityFunctions = {
    findAlternativeSources: aiServices.findAlternativeSources,
    findNewsApiArticlesForEvent: aiServices.findNewsApiArticlesForEvent,
    performGoogleSearch: aiServices.performGoogleSearch,
    fetchWikipediaSummary: aiServices.fetchWikipediaSummary,
  }
  
  configureScraperLogic({ ...appConfig, configStore, utilityFunctions, logger, settings })
  
  if (!(await aiServices.performAiSanityCheck(settings))) {
    logger.fatal('AI service checks failed. Aborting pipeline.')
    return { success: false }
  }
  
  // Run housekeeping early
  await performDatabaseHousekeeping();

  return { success: true, payload: pipelinePayload }
}

```

## 📄 src/pipeline/2_scrapeAndFilter.js
*Lines: 118, Size: 5.34 KB*

```javascript
// apps/pipeline/src/pipeline/2_scrapeAndFilter.js (version 9.0.0)
import { logger, auditLogger } from '@headlines/utils/src/server.js';
import { filterFreshArticles } from '../modules/dataStore/index.js';
import { triggerSelectorRepair } from './submodules/triggerSelectorRepair.js';
import { Source, Article } from '@headlines/models/src/index.js';
import { scrapeAllHeadlines } from '@headlines/scraper-logic/src/scraper/orchestrator.js';
import { scrapeArticleContent } from '@headlines/scraper-logic/src/scraper/index.js';
import mongoose from 'mongoose';
import { settings } from '@headlines/config/src/server.js';

async function performContentPreflight(source, articles) {
    if (!articles || articles.length === 0) return { success: false, reason: 'No headlines to test' };
    
    const firstArticle = { ...articles[0], source: source.name, newspaper: source.name, country: source.country };
    const contentResult = await scrapeArticleContent(firstArticle, source);
    const content = contentResult.articleContent?.contents?.join('');

    if (!content || content.length < settings.MIN_ARTICLE_CHARS) {
        const reason = !content ? contentResult.enrichment_error : `Content too short (${content.length} < ${settings.MIN_ARTICLE_CHARS} chars).`;
        logger.warn(`[Content Pre-flight] ❌ FAILED for "${source.name}". Reason: ${reason}`);
        return { success: false, reason };
    }
    
    logger.info(`✅ Content pre-flight check PASSED for "${source.name}".`);
    return { success: true };
}

export async function runScrapeAndFilter(pipelinePayload) {
  logger.info('--- STAGE 2: SCRAPE & FILTER ---');
  const { runStats } = pipelinePayload;

  const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);

  const baseQuery = {
    status: 'active',
    $or: [
      { scrapeFrequency: 'high' },
      { scrapeFrequency: 'low', lastScrapedAt: { $lt: twentyFourHoursAgo } },
      { scrapeFrequency: 'low', lastScrapedAt: { $exists: false } }
    ]
  };
  
  const queryCriteria = { ...baseQuery };

  if (pipelinePayload.countryFilter) {
      queryCriteria.country = new RegExp(`^${pipelinePayload.countryFilter}$`, 'i');
      delete queryCriteria.$or;
  }
  if (pipelinePayload.sourceFilter) {
      queryCriteria.name = new RegExp(`^${pipelinePayload.sourceFilter}$`, 'i');
      delete queryCriteria.$or;
  }

  const sourcesToScrape = await Source.find(queryCriteria).lean();
  if (sourcesToScrape.length === 0) {
    logger.warn(`No active sources found matching filter: ${JSON.stringify(queryCriteria)}. Ending run.`);
    return { success: true, payload: { ...pipelinePayload, articlesForPipeline: [] } };
  }
  
  const { allArticles, scraperHealth } = await scrapeAllHeadlines(sourcesToScrape);
  runStats.scraperHealth = scraperHealth;
  auditLogger.info({ context: { all_scraped_headlines: allArticles.map(a => ({ headline: a.headline, source: a.newspaper })) } }, 'All Scraped Headlines');
  
  const freshArticles = await filterFreshArticles(allArticles, pipelinePayload.isRefreshMode);
  auditLogger.info({ context: { fresh_headlines: freshArticles.map(a => a.headline) } }, 'Fresh Headlines After Filtering');
  
  const freshArticlesBySource = freshArticles.reduce((acc, article) => {
    if (!acc[article.source]) acc[article.source] = [];
    acc[article.source].push(article);
    return acc;
  }, {});

  const sourcesWithFreshContent = new Set(Object.keys(freshArticlesBySource));
  logger.info(`Found ${sourcesWithFreshContent.size} sources with fresh content that require a content pre-flight check.`);

  let validatedArticles = [];
  const analyticsUpdateOps = [];

  for (const sourceName of sourcesWithFreshContent) {
    const source = sourcesToScrape.find(s => s.name === sourceName);
    const healthReport = scraperHealth.find(h => h.source === sourceName);

    if (source && healthReport && healthReport.success) {
      const contentCheck = await performContentPreflight(source, freshArticlesBySource[sourceName]);
      if (contentCheck.success) {
        validatedArticles.push(...freshArticlesBySource[sourceName]);
        analyticsUpdateOps.push({ updateOne: { filter: { _id: source._id }, update: { $set: { 'analytics.lastRunContentSuccess': true } } } });
      } else {
        analyticsUpdateOps.push({ updateOne: { filter: { _id: source._id }, update: { $set: { 'analytics.lastRunContentSuccess': false } } } });
      }
    }
  }

  if (analyticsUpdateOps.length > 0) {
      await Source.bulkWrite(analyticsUpdateOps);
  }

  runStats.headlinesScraped = allArticles.length;
  runStats.validatedHeadlines = validatedArticles.length; 

  const articlesWithIds = validatedArticles.map(article => ({ ...article, _id: article._id || new mongoose.Types.ObjectId(), status: 'scraped' }));
  runStats.freshHeadlinesFound = articlesWithIds.length;

  if (articlesWithIds.length > 0) {
    await Article.insertMany(articlesWithIds, { ordered: false }).catch(err => {
      if (err.code !== 11000) logger.error({ err }, "Error inserting scraped articles");
    });
    logger.info(`Successfully saved ${articlesWithIds.length} fresh & validated articles to the database.`);
  } else {
    logger.info('No new, validated articles to process. Ending run early.');
    pipelinePayload.articlesForPipeline = [];
    return { success: true, payload: pipelinePayload };
  }
  
  pipelinePayload.articlesForPipeline = articlesWithIds;
  return { success: true, payload: pipelinePayload };
}

```

## 📄 src/pipeline/3_assessAndEnrich.js
*Lines: 266, Size: 9.31 KB*

```javascript
// apps/pipeline/src/pipeline/3_assessAndEnrich.js (version 9.2.0 - Retry & Fallback Logic)
import { truncateString, sleep } from '@headlines/utils/src/server.js'
import { logger } from '@headlines/utils/src/logger.js'
import { settings } from '@headlines/config/src/server.js'
import { Article } from '@headlines/models/src/index.js'
import { batchHeadlineChain } from '@headlines/ai-services/src/index.js'
import { processSingleArticle } from './submodules/processSingleArticle.js'
import pLimit from 'p-limit'
import { env } from '@headlines/config/src/server.js'
import { getConfig } from '@headlines/scraper-logic/src/config.js'

const BATCH_SIZE = 8 // Reduced batch size
const MAX_RETRIES = 1

async function withRetry(fn, retries = MAX_RETRIES) {
  for (let i = 0; i <= retries; i++) {
    try {
      return await fn()
    } catch (error) {
      if (i === retries) {
        throw error
      }
      logger.warn(
        `Operation failed. Retrying in 2 seconds... (Attempt ${i + 1}/${retries})`
      )
      await sleep(2000)
    }
  }
}

function findWatchlistHits(text, country) {
  const hits = new Map()
  const lowerText = text.toLowerCase()
  const config = getConfig()
  if (!config.configStore?.watchlistEntities) return []
  const createSearchRegex = (term) =>
    new RegExp(`\\b${term.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\b`, 'i')

  const relevantEntities = Array.from(
    config.configStore.watchlistEntities.values()
  ).filter(
    (entity) =>
      !entity.country ||
      entity.country === country ||
      entity.country === 'Global PE' ||
      entity.country === 'M&A Aggregators'
  )

  for (const entity of relevantEntities) {
    const terms = [entity.name.toLowerCase(), ...(entity.searchTerms || [])]
    for (const term of terms) {
      if (term.length > 3 && createSearchRegex(term).test(lowerText)) {
        if (!hits.has(entity.name)) hits.set(entity.name, { entity, matchedTerm: term })
      }
    }
  }
  return Array.from(hits.values())
}

export async function runAssessAndEnrich(pipelinePayload) {
  logger.info('--- STAGE 3: ASSESS & ENRICH ---')
  const { runStats, articlesForPipeline } = pipelinePayload

  if (!articlesForPipeline || articlesForPipeline.length === 0) {
    pipelinePayload.enrichedArticles = []
    return { success: true, payload: pipelinePayload }
  }

  const syntheticArticles = articlesForPipeline.filter(
    (a) => a.source === 'Richlist Ingestion'
  )
  const realArticles = articlesForPipeline.filter(
    (a) => a.source !== 'Richlist Ingestion'
  )

  logger.info(
    `Processing ${realArticles.length} real articles and ${syntheticArticles.length} synthetic articles.`
  )

  let assessedCandidates = []

  if (realArticles.length > 0) {
    logger.info(
      `Assessing ${realArticles.length} real headlines in batches of ${BATCH_SIZE}...`
    )
    const batches = []
    for (let i = 0; i < realArticles.length; i += BATCH_SIZE) {
      batches.push(realArticles.slice(i, i + BATCH_SIZE))
    }

    for (const [index, batch] of batches.entries()) {
      logger.info(`Assessing batch ${index + 1} of ${batches.length}...`)
      try {
        const batchProcessor = async () => {
          const batchWithContext = batch.map((article) => {
            const hits = findWatchlistHits(article.headline, article.country)
            let headlineWithContext = `[COUNTRY CONTEXT: ${article.country}] ${article.headline}`
            if (hits.length > 0) {
              const hitStrings = hits
                .map(
                  (hit) =>
                    `[WATCHLIST HIT: ${hit.entity.name} (matched on '${hit.matchedTerm}')]`
                )
                .join(' ')
              headlineWithContext = `${hitStrings} ${headlineWithContext}`
            }
            return { ...article, headlineWithContext }
          })

          // DEFINITIVE FIX: Changed from .invoke to direct await
          const response = await batchHeadlineChain({
            headlines_json_string: JSON.stringify(
              batchWithContext.map((a) => a.headlineWithContext)
            ),
          })

          if (
            response.error ||
            !response.assessments ||
            response.assessments.length !== batch.length
          ) {
            throw new Error('Batch assessment failed or returned mismatched count.')
          }

          const batchResults = batchWithContext.map((originalArticle, i) => {
            const assessment = response.assessments[i]
            if (originalArticle.headlineWithContext.includes('[WATCHLIST HIT')) {
              let score = assessment.relevance_headline
              score = Math.min(100, score + settings.WATCHLIST_SCORE_BOOST)
              assessment.assessment_headline = `Watchlist boost (+${settings.WATCHLIST_SCORE_BOOST}). ${assessment.assessment_headline}`
              assessment.relevance_headline = score
            }
            return { ...originalArticle, ...assessment }
          })
          return batchResults
        }

        const results = await withRetry(batchProcessor)
        assessedCandidates.push(...results)
      } catch (batchError) {
        logger.error(
          { err: batchError },
          `Batch ${index + 1} failed after all retries. FALLING BACK to single-article assessment.`
        )
        const fallbackPromises = batch.map((article) => processSingleArticle(article))
        const fallbackResults = await Promise.all(fallbackPromises)

        fallbackResults.forEach((result, i) => {
          const originalArticle = batch[i]
          if (result.article) {
            assessedCandidates.push({ ...originalArticle, ...result.article })
          } else {
            assessedCandidates.push({
              ...originalArticle,
              relevance_headline: 0,
              assessment_headline: result.lifecycleEvent.reason,
            })
          }
        })
      }
    }
  }

  runStats.headlinesAssessed = assessedCandidates.length

  // DEFINITIVE FIX: Add detailed logging for every assessed headline.
  logger.info('--- Headline Assessment Complete ---')
  assessedCandidates.forEach((article) => {
    const status =
      article.relevance_headline >= settings.HEADLINES_RELEVANCE_THRESHOLD
        ? 'PASSED'
        : 'DROPPED'
    const color = status === 'PASSED' ? '\\x1b[32m' : '\\x1b[90m'
    logger.info(
      `${color}[${status.padEnd(7)}] [Score: ${String(article.relevance_headline).padStart(3)}] "${truncateString(article.headline, 60)}" (${article.assessment_headline})\\x1b[0m`
    )
  })

  const relevantCandidates = assessedCandidates.filter(
    (a) => a.relevance_headline >= settings.HEADLINES_RELEVANCE_THRESHOLD
  )
  runStats.relevantHeadlines = relevantCandidates.length

  const enrichmentQueue = [...relevantCandidates, ...syntheticArticles]

  logger.info(
    `Found ${relevantCandidates.length} relevant headlines. Total for full enrichment (including synthetic): ${enrichmentQueue.length}.`
  )
  if (enrichmentQueue.length === 0) {
    pipelinePayload.enrichedArticles = []
    return { success: true, payload: pipelinePayload }
  }

  const limit = pLimit(env.CONCURRENCY_LIMIT)
  const processingPromises = enrichmentQueue.map((article) =>
    limit(() => processSingleArticle(article))
  )
  const results = await Promise.all(processingPromises)

  const enrichedArticles = []
  const articleUpdates = []
  runStats.enrichmentOutcomes = []

  logger.info('--- Full Article Enrichment Results ---')
  results.forEach((result, index) => {
    const originalArticle = enrichmentQueue[index]
    const finalArticleState = {
      ...originalArticle,
      ...result.article,
      pipeline_lifecycle: [
        ...(originalArticle.pipeline_lifecycle || []),
        result.lifecycleEvent,
      ],
    }
    const outcome = result.lifecycleEvent.status

    runStats.enrichmentOutcomes.push({
      link: finalArticleState.link,
      headline: finalArticleState.headline,
      newspaper: finalArticleState.newspaper,
      headlineScore: finalArticleState.relevance_headline,
      assessment_headline: finalArticleState.assessment_headline,
      finalScore: finalArticleState.relevance_article,
      assessment_article: finalArticleState.assessment_article,
      content_snippet: truncateString(result.contentPreview, 200),
      outcome: outcome,
      reason: result.lifecycleEvent.reason,
    })

    if (outcome === 'success') {
      enrichedArticles.push(finalArticleState)
      logger.info(
        `✅ [SUCCESS] "${truncateString(originalArticle.headline, 60)}" - Final Score: ${finalArticleState.relevance_article}`
      )
    } else {
      logger.warn(
        `❌ [${outcome.toUpperCase()}] "${truncateString(originalArticle.headline, 60)}" - Reason: ${result.lifecycleEvent.reason}`
      )
    }

    if (result.article || result.lifecycleEvent) {
      articleUpdates.push({
        updateOne: {
          filter: { _id: originalArticle._id },
          update: { $set: finalArticleState },
        },
      })
    }
  })

  if (articleUpdates.length > 0) {
    await Article.bulkWrite(articleUpdates, { ordered: false })
  }

  runStats.articlesEnriched = enrichedArticles.length
  runStats.relevantArticles = enrichedArticles.length

  logger.info(
    `Enrichment complete. Successfully enriched ${enrichedArticles.length} of ${enrichmentQueue.length} candidates.`
  )
  pipelinePayload.enrichedArticles = enrichedArticles
  pipelinePayload.assessedCandidates = assessedCandidates

  return { success: true, payload: pipelinePayload }
}

```

## 📄 src/pipeline/4_clusterAndSynthesize.js
*Lines: 213, Size: 7.45 KB*

```javascript
// apps/pipeline/src/pipeline/4_clusterAndSynthesize.js
import { truncateString } from '@headlines/utils/src/server.js'
import { logger, auditLogger } from '@headlines/utils/src/server.js'
import {
  clusteringChain,
  synthesisChain,
  entityExtractorChain,
  opportunityChain,
  findSimilarArticles,
} from '@headlines/ai-services/src/index.js'
import { settings } from '@headlines/config/src/server.js'
import { getConfig } from '@headlines/scraper-logic/src/config.js'

async function synthesizeEventsFromCluster(articlesInCluster, clusterKey, runStats) {
  const config = getConfig()
  const primaryHeadline = articlesInCluster[0]?.headline || clusterKey
  logger.info(
    `--- [ Synthesizing from Cluster: "${truncateString(primaryHeadline, 60)}" ] ---`
  )

  const uniqueArticlesInCluster = Array.from(
    new Map(articlesInCluster.map((a) => [a.link, a])).values()
  )
  const combinedText = uniqueArticlesInCluster
    .map((a) => `${a.headline}\n${a.assessment_article}`)
    .join('\n\n')

  const entityResult = await entityExtractorChain({ article_text: combinedText })
  const entities = entityResult.entities || []

  const historicalContext = await findSimilarArticles(entities.join(', '))
  const [wikiResults, newsApiResult] = await Promise.all([
    entities.length > 0
      ? Promise.all(entities.map((e) => config.utilityFunctions.fetchWikipediaSummary(e)))
      : Promise.resolve([]),
    config.utilityFunctions.findNewsApiArticlesForEvent(primaryHeadline),
  ])

  const enrichmentSources = []
  if (historicalContext.length > 0) enrichmentSources.push('rag_db')
  if (wikiResults.some((r) => r.success)) enrichmentSources.push('wikipedia')
  if (newsApiResult.success) enrichmentSources.push('news_api')

  const wikipediaContext =
    wikiResults
      .filter((r) => r.success)
      .map((r) => r.summary)
      .join('\n---\n') || 'Not available.'
  const newsApiContext = newsApiResult.snippets

  const synthesisInput = {
    "[ TODAY'S NEWS ]": uniqueArticlesInCluster.map((a) => ({
      headline: a.headline,
      source: a.newspaper,
      full_text: a.assessment_article,
      key_individuals: a.key_individuals || [],
    })),
    '[ HISTORICAL CONTEXT (Internal Database) ]': historicalContext,
    '[ PUBLIC WIKIPEDIA CONTEXT ]': wikipediaContext,
    '[ LATEST NEWS CONTEXT (NewsAPI) ]': newsApiContext,
  }

  auditLogger.info(
    { context: { synthesis_input: synthesisInput } },
    `Synthesis Context for: "${primaryHeadline}"`
  )
  const synthesisResult = await synthesisChain({
    context_json_string: JSON.stringify(synthesisInput),
  })
  auditLogger.info(
    { context: { llm_output: synthesisResult } },
    `Synthesis Verdict for: "${primaryHeadline}"`
  )

  if (!synthesisResult || synthesisResult.error || !synthesisResult.events) {
    logger.warn({ details: synthesisResult?.error }, 'Synthesis failed for cluster.')
    return []
  }

  const highestScoreInCluster = Math.max(
    ...uniqueArticlesInCluster.map((a) => a.relevance_article || 0)
  )

  const finalEventsAndOpps = []

  for (const [index, eventData] of synthesisResult.events.entries()) {
    if (highestScoreInCluster < settings.EVENT_RELEVANCE_THRESHOLD) {
      logger.warn(
        {
          score: highestScoreInCluster,
          threshold: settings.EVENT_RELEVANCE_THRESHOLD,
          headline: eventData.headline,
        },
        'Event failed final quality gate. Discarding.'
      )
      continue
    }

    runStats.eventsSynthesized++
    const eventObject = {
      ...eventData,
      event_key: `${clusterKey}-${index}`,
      synthesized_headline: eventData.headline,
      synthesized_summary: eventData.summary,
      ai_assessment_reason: uniqueArticlesInCluster[0].assessment_article,
      highest_relevance_score: highestScoreInCluster,
      source_articles: uniqueArticlesInCluster.map((a) => ({
        headline: a.headline,
        link: a.link,
        newspaper: a.newspaper,
        imageUrl: a.imageUrl,
      })),
      enrichmentSources,
    }

    const opportunityInput = {
      context_text: `Event Key: ${eventObject.event_key}\nSynthesized Event Headline: ${eventObject.synthesized_headline}\nSynthesized Event Summary: ${eventObject.synthesized_summary}\nKey Individuals already identified: ${JSON.stringify(eventObject.key_individuals)}\nSource Article Snippets: ${truncateString(combinedText, settings.LLM_CONTEXT_MAX_CHARS)}`,
    }
    const opportunityResult = await opportunityChain(opportunityInput)

    runStats.synthesizedEventsForReport.push({
      synthesized_headline: eventObject.synthesized_headline,
      highest_relevance_score: eventObject.highest_relevance_score,
    })

    finalEventsAndOpps.push({
      event: eventObject,
      opportunities: opportunityResult.opportunities || [],
    })
  }

  return finalEventsAndOpps
}

export async function runClusterAndSynthesize(pipelinePayload) {
  logger.info('--- STAGE 4: CLUSTER & SYNTHESIZE ---')
  const { runStats, enrichedArticles } = pipelinePayload

  const articlesForProcessing = enrichedArticles.filter(
    (a) => a.relevance_article >= settings.ARTICLES_RELEVANCE_THRESHOLD
  )
  if (articlesForProcessing.length === 0) {
    logger.info('No relevant articles were promoted for synthesis stage.')
    pipelinePayload.synthesizedEvents = []
    pipelinePayload.opportunitiesToSave = []
    return { success: true, payload: pipelinePayload }
  }

  const fullArticleMap = new Map(articlesForProcessing.map((a) => [a._id.toString(), a]))
  const articlePayload = articlesForProcessing.map((a) => ({
    id: a._id.toString(),
    headline: a.headline,
    source: a.newspaper,
    summary: a.assessment_article || '',
  }))
  const clusterResult = await clusteringChain({
    articles_json_string: JSON.stringify(articlePayload),
  })

  const eventClusters = clusterResult.events || []
  runStats.eventsClustered = eventClusters.length
  logger.info(
    { details: eventClusters },
    `Clustered ${articlesForProcessing.length} articles into ${eventClusters.length} unique events.`
  )

  const clusteredArticleIds = new Set(eventClusters.flatMap((c) => c.article_ids))
  let synthesizedEvents = []
  let opportunitiesToSave = []

  const synthesisPromises = []

  for (const cluster of eventClusters) {
    const articlesInCluster = cluster.article_ids
      .map((id) => fullArticleMap.get(id))
      .filter(Boolean)
    if (articlesInCluster.length > 0) {
      synthesisPromises.push(
        synthesizeEventsFromCluster(articlesInCluster, cluster.event_key, runStats)
      )
    }
  }

  const singletonArticles = articlesForProcessing.filter(
    (a) =>
      !clusteredArticleIds.has(a._id.toString()) &&
      a.relevance_article >= settings.SINGLETON_RELEVANCE_THRESHOLD
  )
  if (singletonArticles.length > 0) {
    logger.info(
      `Found ${singletonArticles.length} high-quality singleton articles to process as individual events.`
    )
    for (const article of singletonArticles) {
      const event_key = `singleton-${article.newspaper.toLowerCase().replace(/[^a-z0-9]/g, '')}-${article._id.toString()}`
      synthesisPromises.push(synthesizeEventsFromCluster([article], event_key, runStats))
    }
  }

  const results = await Promise.all(synthesisPromises)
  const flattenedResults = results.flat()

  flattenedResults.forEach((result) => {
    if (result) {
      synthesizedEvents.push(result.event)
      opportunitiesToSave.push(...result.opportunities)
    }
  })

  pipelinePayload.synthesizedEvents = synthesizedEvents
  pipelinePayload.opportunitiesToSave = opportunitiesToSave
  return { success: true, payload: pipelinePayload }
}

```

## 📄 src/pipeline/5_commitAndNotify.js
*Lines: 57, Size: 2.2 KB*

```javascript
// apps/pipeline/src/pipeline/5_commitAndNotify.js
import { logger, auditLogger } from '@headlines/utils/src/server.js'
import { sendSupervisorReportEmail } from '../modules/email/index.js'
import { judgeAndFilterOutput } from './submodules/commit/1_judgeOutput.js'
import { saveResultsToDb } from './submodules/commit/2_saveResults.js'
import { triggerNotifications } from './submodules/commit/3_triggerNotifications.js'

const FATAL_JUDGEMENT_QUALITIES = ['Irrelevant', 'Poor']

export async function runCommitAndNotify(pipelinePayload) {
  logger.info('--- STAGE 5: COMMIT & NOTIFY ---')
  const { noCommitMode, runStats, isDryRun, dbConnection } = pipelinePayload

  if (noCommitMode || isDryRun) {
    logger.warn(
      'COMMIT/NOTIFY: Skipping database commits and user notifications due to run flags.'
    )
    if (!isDryRun) await sendSupervisorReportEmail(runStats)
    return { success: true, payload: pipelinePayload }
  }

  if (dbConnection && (!runStats.errors || runStats.errors.length === 0)) {
    const { finalEvents, finalOpportunities } = await judgeAndFilterOutput(
      pipelinePayload,
      FATAL_JUDGEMENT_QUALITIES
    )

    const { savedEvents, savedOpportunities, articlesSavedCount } = await saveResultsToDb(
      pipelinePayload,
      finalEvents,
      finalOpportunities
    )

    pipelinePayload.savedEvents = savedEvents
    pipelinePayload.savedOpportunities = savedOpportunities

    logger.info(
      `Database Save Summary: ${articlesSavedCount} articles processed, ${savedEvents.length} events committed, ${savedOpportunities.length} opportunities committed.`
    )

    if (savedEvents.length > 0 || savedOpportunities.length > 0) {
      logger.info(
        `Triggering notifications for ${savedEvents.length} committed events and ${savedOpportunities.length} committed opportunities.`
      )
      await triggerNotifications(pipelinePayload, savedEvents, savedOpportunities)
    } else {
      logger.info(
        'No new items were successfully committed to the database. Skipping user notifications.'
      )
    }
  }

  auditLogger.info({ context: { run_stats: runStats } }, 'Final Run Statistics')
  await sendSupervisorReportEmail(runStats)
  return { success: true, payload: pipelinePayload }
}

```

## 📄 src/pipeline/6_suggestNewWatchlistEntities.js
*Lines: 81, Size: 2.58 KB*

```javascript
// apps/pipeline/src/pipeline/6_suggestNewWatchlistEntities.js (version 4.1)
import { logger } from '@headlines/utils/src/server.js';
import { watchlistSuggestionChain } from '@headlines/ai-services/src/index.js'
import {
  getActiveWatchlistEntityNames,
  bulkWriteWatchlistSuggestions,
} from '@headlines/data-access/src/index.js'
import { settings } from '@headlines/config/src/server.js'

export async function suggestNewWatchlistEntities(pipelinePayload) {
  logger.info('--- STAGE 6: WATCHLIST SUGGESTION ---')

  const { savedEvents } = pipelinePayload
  if (!savedEvents || savedEvents.length === 0) {
    logger.info('No new events saved. Skipping watchlist suggestion.')
    return
  }

  const highQualityEvents = savedEvents.filter(
    (e) => e.highest_relevance_score >= settings.SUGGESTION_GENERATION_THRESHOLD
  )
  if (highQualityEvents.length === 0) {
    logger.info(
      `No events met quality threshold (${settings.SUGGESTION_GENERATION_THRESHOLD}) for suggestions.`
    )
    return
  }

  logger.info(
    `Analyzing ${highQualityEvents.length} high-quality events for new watchlist candidates...`
  )

  const existingEntitiesResult = await getActiveWatchlistEntityNames()
  if (!existingEntitiesResult.success) {
    logger.error(
      { err: existingEntitiesResult.error },
      'Failed to fetch existing watchlist entities.'
    )
    return
  }
  const existingNames = new Set(
    existingEntitiesResult.data.map((e) => e.name.toLowerCase())
  )

  const result = await watchlistSuggestionChain({
    events_json_string: JSON.stringify(highQualityEvents),
  })

  if (result.error || !result.suggestions) {
    logger.warn('AI failed to generate watchlist suggestions.', result)
    return
  }

  // Post-filter to ensure we don't suggest entities that already exist
  const newSuggestions = result.suggestions.filter(
    (s) => !existingNames.has(s.name.toLowerCase())
  )

  if (newSuggestions.length > 0) {
    logger.info(`AI generated ${newSuggestions.length} new watchlist suggestions.`)
    const bulkOps = newSuggestions.map((suggestion) => ({
      updateOne: {
        filter: { name: suggestion.name },
        update: { $setOnInsert: suggestion },
        upsert: true,
      },
    }))

    const dbResult = await bulkWriteWatchlistSuggestions(bulkOps)
    if (dbResult.success) {
      logger.info(
        `Successfully saved ${newSuggestions.length} new suggestions to the database.`
      )
    } else {
      logger.error({ err: dbResult.error }, 'Failed to save new watchlist suggestions.')
    }
  } else {
    logger.info('AI analysis did not yield any new watchlist suggestions.')
  }
}

```

## 📄 src/pipeline/7_selfHealAndOptimize.js
*Lines: 10, Size: 472 Bytes*

```javascript
// apps/pipeline/src/pipeline/7_selfHealAndOptimize.js (version 2.0.0)
import { logger } from '@headlines/utils/src/server.js';

export async function runSelfHealAndOptimize(pipelinePayload) {
    logger.warn('--- STAGE 7: SELF-HEAL & OPTIMIZE (DISABLED) ---');
    logger.warn('Self-healing functionality has been disabled by configuration.');
    // The function now does nothing and simply returns the payload.
    return { success: true, payload: pipelinePayload };
}

```

## 📄 src/pipeline/submodules/commit/1_judgeOutput.js
*Lines: 79, Size: 2.54 KB*

```javascript
// apps/pipeline/src/pipeline/submodules/commit/1_judgeOutput.js (version 2.4.1)
import { logger } from '@headlines/utils/src/logger.js';
import { judgeChain } from '@headlines/ai-services/src/index.js'

export async function judgeAndFilterOutput(pipelinePayload, fatalQualities) {
  const {
    synthesizedEvents: initialEvents = [],
    opportunitiesToSave: initialOpportunities = [],
    runStats,
  } = pipelinePayload

  logger.info(
    `[Judge Agent] Received ${initialEvents.length} events and ${initialOpportunities.length} opportunities for final review.`
  )

  const lightweightEvents = initialEvents.map((e) => ({
    identifier: `Event: ${e.synthesized_headline}`,
    summary: e.synthesized_summary,
    assessment: e.ai_assessment_reason,
    score: e.highest_relevance_score,
  }))
  const lightweightOpportunities = initialOpportunities.map((o) => ({
    identifier: `Opportunity: ${o.reachOutTo}`,
    reason: o.whyContact,
    wealth_estimate_mm: o.likelyMMDollarWealth,
  }))

  const payloadForJudge = {
    events: lightweightEvents,
    opportunities: lightweightOpportunities,
  }
  // DEFINITIVE FIX: Changed from .invoke to direct await
  const judgeVerdict = await judgeChain({
    payload_json_string: JSON.stringify(payloadForJudge),
  })

  runStats.judgeVerdict = judgeVerdict

  if (judgeVerdict.error) {
    logger.error(
      'Judge agent returned an error. Allowing all items to pass as a failsafe.',
      { details: judgeVerdict.error }
    )
    return { finalEvents: initialEvents, finalOpportunities: initialOpportunities }
  }

  const fatalQualitiesSet = new Set(fatalQualities)

  const approvedEventIdentifiers = new Set(
    (judgeVerdict?.event_judgements || [])
      .filter((j) => !fatalQualitiesSet.has(j.quality))
      .map((j) => j.identifier)
  )

  const finalEvents = initialEvents.filter((event) => {
    const identifier = `Event: ${event.synthesized_headline}`
    const wasApproved = approvedEventIdentifiers.has(identifier)
    if (!wasApproved) {
      const verdict = judgeVerdict.event_judgements.find(
        (j) => j.identifier === identifier
      )
      logger.warn(
        { event: event.synthesized_headline, verdict: verdict },
        `Event discarded by Judge's final verdict.`
      )
    }
    return wasApproved
  })

  logger.info(
    `[Judge Agent] Verdict complete. Approved ${finalEvents.length} out of ${initialEvents.length} events.`
  )

  // For now, we are not filtering opportunities, but the framework is here.
  const finalOpportunities = initialOpportunities

  return { finalEvents, finalOpportunities }
}

```

## 📄 src/pipeline/submodules/commit/2_saveResults.js
*Lines: 61, Size: 2.16 KB*

```javascript
// apps/pipeline/src/pipeline/submodules/commit/2_saveResults.js (version 2.1.1)
import mongoose from 'mongoose'
import { savePipelineResults } from '../../../modules/dataStore/index.js'
import { enrichAndLinkOpportunities } from '../opportunityUpserter.js'
import { logger } from '@headlines/utils/src/logger.js'

export async function saveResultsToDb(
  pipelinePayload,
  finalEventsToSave,
  finalOpportunitiesToSave
) {
  const { assessedCandidates, isDryRun, runStats } = pipelinePayload
  const articlesToSave = assessedCandidates || []

  if (isDryRun) {
    logger.warn('DRY RUN: Simulating database save.')
    const savedEvents = finalEventsToSave.map((event) => ({
      ...event,
      _id: new mongoose.Types.ObjectId(),
    }))
    return {
      savedEvents,
      savedOpportunities: finalOpportunitiesToSave,
      articlesSavedCount: articlesToSave.length,
    }
  }

  const commitResult = await savePipelineResults(articlesToSave, finalEventsToSave)

  if (commitResult.success) {
    const savedEvents = commitResult.savedEvents
    try {
      const savedOpportunities = await enrichAndLinkOpportunities(
        finalOpportunitiesToSave,
        savedEvents
      )
      // DEFINITIVE FIX: Ensure the returned objects are plain JS objects (.lean())
      // The `savePipelineResults` already returns lean objects, so this is a confirmation of that contract.
      return {
        savedEvents: JSON.parse(JSON.stringify(savedEvents)),
        savedOpportunities: JSON.parse(JSON.stringify(savedOpportunities)),
        articlesSavedCount: articlesToSave.length,
      }
    } catch (error) {
      logger.error(
        { err: error },
        'CRITICAL: Failed during opportunity enrichment and linking. Opportunities will not be saved or sent.'
      )
      runStats.errors.push('CRITICAL: Opportunity processing failed: ' + error.message)
      return {
        savedEvents: JSON.parse(JSON.stringify(savedEvents)),
        savedOpportunities: [],
        articlesSavedCount: articlesToSave.length,
      }
    }
  } else {
    runStats.errors.push('CRITICAL: Failed to commit pipeline results.')
    return { savedEvents: [], savedOpportunities: [], articlesSavedCount: 0 }
  }
}

```

## 📄 src/pipeline/submodules/commit/3_triggerNotifications.js
*Lines: 60, Size: 1.85 KB*

```javascript
// apps/pipeline/src/pipeline/submodules/commit/3_triggerNotifications.js (version 2.2.3)
import { logger } from '@headlines/utils/src/logger.js';
import { streamNewEvent, streamNewArticle } from '../../../modules/realtime/index.js'
import { SynthesizedEvent, Article } from '@headlines/models/src/index.js'
import { settings } from '@headlines/config/src/server.js'
import { sendNotifications } from '../../../modules/notifications/index.js'

export async function triggerNotifications(
  pipelinePayload,
  savedEvents,
  savedOpportunities
) {
  const { assessedCandidates, isDryRun, runStats } = pipelinePayload

  const eventIds = savedEvents.map((e) => e._id)

  if (!isDryRun) {
    if (assessedCandidates?.length > 0) {
      const relevantArticleLinks = assessedCandidates
        .filter((a) => a.relevance_article >= settings.ARTICLES_RELEVANCE_THRESHOLD)
        .map((a) => a.link)

      if (relevantArticleLinks.length > 0) {
        const relevantArticleDocs = await Article.find({
          link: { $in: relevantArticleLinks },
        })
        for (const articleDoc of relevantArticleDocs) {
          await streamNewArticle(articleDoc)
        }
      }
    }

    if (eventIds.length > 0) {
      const eventDocsForStreaming = await SynthesizedEvent.find({
        _id: { $in: eventIds },
      })
      for (const eventDoc of eventDocsForStreaming) {
        await streamNewEvent(eventDoc)
      }
    }
  }

  const eventsForNotification = isDryRun
    ? savedEvents
    : await SynthesizedEvent.find({ _id: { $in: eventIds } }).lean()

  const { emailSentCount } = await sendNotifications(
    eventsForNotification,
    savedOpportunities
  )
  runStats.eventsEmailed = emailSentCount

  if (emailSentCount > 0 && !isDryRun) {
    await SynthesizedEvent.updateMany(
      { _id: { $in: eventIds } },
      { $set: { emailed: true, email_sent_at: new Date() } }
    )
  }
}

```

## 📄 src/pipeline/submodules/commit/4_updateSourceAnalytics.js
*Lines: 82, Size: 3.12 KB*

```javascript
// apps/pipeline/src/pipeline/submodules/commit/4_updateSourceAnalytics.js (version 3.2.0)
import { logger } from '@headlines/utils/src/server.js';
import { settings } from '@headlines/config/src/server.js'
import { updateSourceAnalyticsBatch } from '@headlines/data-access/src/index.js'

export async function updateSourceAnalytics(pipelinePayload) {
  const { runStats, assessedCandidates, articlesForPipeline } = pipelinePayload
  if (!runStats || !runStats.scraperHealth) {
    logger.warn('[Analytics] Missing scraperHealth data. Skipping source analytics update.')
    return
  }

  logger.info('📊 Updating source performance analytics...')

  const analyticsMap = new Map()

  // Step 1: Initialize analytics based on scrape success and total headlines found.
  for (const health of runStats.scraperHealth) {
    analyticsMap.set(health.source, {
      $inc: {
        'analytics.totalRuns': 1,
        'analytics.totalSuccesses': health.success ? 1 : 0,
        'analytics.totalFailures': health.success ? 0 : 1,
        'analytics.totalScraped': 0, // Will be incremented by fresh count
        'analytics.totalRelevant': 0, // Will be incremented by relevant count
      },
      $set: {
        'analytics.lastRunHeadlineCount': health.count,
        'analytics.lastRunRelevantCount': 0,
      },
    })
  }

  // Step 2: Calculate FRESH headlines per source to correctly increment totalScraped.
  const freshHeadlinesBySource = (articlesForPipeline || []).reduce((acc, article) => {
      acc[article.source] = (acc[article.source] || 0) + 1;
      return acc;
  }, {});

  for (const [sourceName, freshCount] of Object.entries(freshHeadlinesBySource)) {
      if (analyticsMap.has(sourceName)) {
          const data = analyticsMap.get(sourceName);
          data.$inc['analytics.totalScraped'] = freshCount;
      }
  }

  // Step 3: Calculate RELEVANT headlines per source.
  if (assessedCandidates && assessedCandidates.length > 0) {
      const relevanceBySource = new Map()
      for (const article of assessedCandidates) {
        if (article.relevance_headline >= settings.HEADLINES_RELEVANCE_THRESHOLD) {
          const currentCount = relevanceBySource.get(article.source) || 0
          relevanceBySource.set(article.source, currentCount + 1)
        }
      }

      for (const [sourceName, relevantCount] of relevanceBySource.entries()) {
        if (analyticsMap.has(sourceName)) {
          const data = analyticsMap.get(sourceName)
          data.$inc['analytics.totalRelevant'] = relevantCount
          data.$set['analytics.lastRunRelevantCount'] = relevantCount
        }
      }
  }

  const bulkOps = []
  for (const [name, update] of analyticsMap.entries()) {
    bulkOps.push({ updateOne: { filter: { name }, update } })
  }

  if (bulkOps.length > 0) {
    const result = await updateSourceAnalyticsBatch(bulkOps)
    if (result.success) {
      logger.info(`[Analytics] Successfully updated analytics for ${result.modifiedCount} sources.`)
    } else {
      logger.error({ err: result.error }, '[Analytics] Failed to bulk update source analytics.')
    }
  } else {
    logger.info('[Analytics] No sources required analytics updates for this run.')
  }
}

```

## 📄 src/pipeline/submodules/opportunityUpserter.js
*Lines: 178, Size: 5.97 KB*

```javascript
// apps/pipeline/src/pipeline/submodules/opportunityUpserter.js (version 7.1.0)
import { Opportunity, SynthesizedEvent, WatchlistEntity } from '@headlines/models/src/index.js'
import { logger } from '@headlines/utils/src/server.js';
import { contactFinderChain, entityCanonicalizerChain, generateEmbedding } from '@headlines/ai-services/src/index.js'
import { getConfig } from '@headlines/scraper-logic/src/config.js'

async function selfCorrectWatchlist(opportunityName, canonicalName) {
  if (opportunityName.toLowerCase() === canonicalName.toLowerCase()) return

  const watchlistEntity = await WatchlistEntity.findOne({ name: canonicalName })
  if (watchlistEntity) {
    const newSearchTerm = opportunityName.toLowerCase().trim()
    if (!watchlistEntity.searchTerms.includes(newSearchTerm)) {
      watchlistEntity.searchTerms.push(newSearchTerm)
      await watchlistEntity.save()
      logger.info(
        `[Self-Correct] Added search term '${newSearchTerm}' to watchlist entity '${canonicalName}'.`
      )
    }
  }
}

async function findContactEmail(person) {
  const config = getConfig()
  logger.info(`[Contact Research] Initiated for: ${person.reachOutTo}`)
  const queries = [
    `"${person.reachOutTo}" ${person.contactDetails.company} email address`,
    `"${person.reachOutTo}" contact information`,
  ]

  let combinedSnippets = ''
  for (const query of queries) {
    const searchResult = await config.utilityFunctions.performGoogleSearch(query)
    if (searchResult.success && searchResult.snippets) {
      combinedSnippets += `\n--- Results for query: "${query}" ---\n${searchResult.snippets}`
    }
  }

  if (!combinedSnippets) {
    logger.warn(`[Contact Research] No search results for "${person.reachOutTo}".`)
    return null
  }

  const response = await contactFinderChain({ snippets: combinedSnippets })

  if (response.error || !response.email) {
    logger.warn(
      `[Contact Research] LLM failed to extract email for "${person.reachOutTo}".`
    )
    return null
  }

  logger.info(
    { email: response.email },
    `[Contact Research] Found email for "${person.reachOutTo}".`
  )
  return response.email
}

export async function enrichAndLinkOpportunities(potentialOpportunities, savedEvents) {
  if (!potentialOpportunities || potentialOpportunities.length === 0) {
    return []
  }

  logger.info(
    `--- Opportunity Enrichment & Linking: Processing ${potentialOpportunities.length} potential opportunities... ---`
  )

  const canonicalizedOpportunities = await Promise.all(
    potentialOpportunities.map(async (opp) => {
      const originalName = opp.reachOutTo
      // DEFINITIVE FIX: Changed from .invoke to direct await
      const response = await entityCanonicalizerChain({
        entity_name: originalName,
      })
      if (response && !response.error && response.canonical_name) {
        opp.reachOutTo = response.canonical_name
        await selfCorrectWatchlist(originalName, response.canonical_name)
      }
      return opp
    })
  )

  const enrichedOpportunities = await Promise.all(
    canonicalizedOpportunities.map(async (opp) => {
      if (!opp.contactDetails.email) {
        const email = await findContactEmail(opp)
        if (email) {
          opp.contactDetails.email = email
        }
      }
      return opp
    })
  )

  const enrichedOpportunitiesWithEmbeddings = await Promise.all(
    enrichedOpportunities.map(async (opp) => {
      const textToEmbed = [
        opp.reachOutTo,
        ...(Array.isArray(opp.whyContact) ? opp.whyContact : [opp.whyContact]),
        opp.contactDetails?.company,
      ].filter(Boolean).join('; ');
      
      const embedding = await generateEmbedding(textToEmbed);
      return { ...opp, embedding };
    })
  );

  const findOrCreateOps = enrichedOpportunitiesWithEmbeddings.map((opp) => {
      const whyContactArray = Array.isArray(opp.whyContact) ? opp.whyContact : [opp.whyContact];
      return {
          updateOne: {
              filter: { reachOutTo: opp.reachOutTo },
              update: {
                  $setOnInsert: {
                      reachOutTo: opp.reachOutTo,
                      basedIn: opp.basedIn,
                      likelyMMDollarWealth: opp.likelyMMDollarWealth,
                      contactDetails: opp.contactDetails,
                  },
                  $set: {
                      embedding: opp.embedding,
                  },
                  $addToSet: { whyContact: { $each: whyContactArray } }
              },
              upsert: true,
          },
      };
  });


  if (findOrCreateOps.length > 0) {
    await Opportunity.bulkWrite(findOrCreateOps, { ordered: false })
  }

  const allOppNames = enrichedOpportunitiesWithEmbeddings.map((o) => o.reachOutTo)
  const allOpportunityDocs = await Opportunity.find({ reachOutTo: { $in: allOppNames } })
  const oppMap = new Map(allOpportunityDocs.map((o) => [o.reachOutTo, o]))
  const eventMap = new Map(savedEvents.map((e) => [e.event_key, e]))

  const oppLinkOps = []
  const eventLinkOps = []

  for (const enrichedOpp of enrichedOpportunitiesWithEmbeddings) {
    const opportunityDoc = oppMap.get(enrichedOpp.reachOutTo)
    const eventDoc = eventMap.get(enrichedOpp.event_key)
    if (opportunityDoc && eventDoc) {
      eventLinkOps.push({
        updateOne: {
          filter: { _id: eventDoc._id },
          update: { $addToSet: { relatedOpportunities: opportunityDoc._id } },
        },
      })
      oppLinkOps.push({
        updateOne: {
          filter: { _id: opportunityDoc._id },
          update: {
            $addToSet: { events: eventDoc._id },
            $max: { likelyMMDollarWealth: enrichedOpp.likelyMMDollarWealth },
          },
        },
      })
    }
  }

  if (oppLinkOps.length > 0) {
    await Promise.all([
      Opportunity.bulkWrite(oppLinkOps, { ordered: false }),
      SynthesizedEvent.bulkWrite(eventLinkOps, { ordered: false }),
    ])
    logger.info(
      `Successfully linked ${oppLinkOps.length} opportunity-event relationships.`
    )
  }

  return Opportunity.find({ _id: { $in: allOpportunityDocs.map((o) => o._id) } }).lean()
}

```

## 📄 src/pipeline/submodules/processSingleArticle.js
*Lines: 173, Size: 5.69 KB*

```javascript
// apps/pipeline/src/pipeline/submodules/processSingleArticle.js
import { logger } from '@headlines/utils/src/logger.js'
import { articleChain, articlePreAssessmentChain } from '@headlines/ai-services/src/index.js'
import { getConfig } from '@headlines/scraper-logic/src/config.js'
import { scrapeArticleContent } from '@headlines/scraper-logic/src/scraper/contentScraper.js'
import { settings } from '@headlines/config/src/server.js'
import { Source } from '@headlines/models/src/index.js'

function createLifecycleEvent(stage, status, reason) {
  return { stage, status, reason, timestamp: new Date() }
}

async function salvageHighSignalArticle(article) {
  logger.warn(
    { headline: article.headline },
    `SALVAGE MODE: Attempting to find alternative sources for high-signal headline.`
  )
  const config = getConfig()
  const searchResult = await config.utilityFunctions.findAlternativeSources(
    article.headline
  )
  if (!searchResult.success || searchResult.results.length === 0) {
    logger.error(
      { headline: article.headline },
      'SALVAGE FAILED: No alternative sources found.'
    )
    return {
      article: null,
      lifecycleEvent: createLifecycleEvent(
        'salvage',
        'failed',
        'No alternative sources found'
      ),
    }
  }

  for (const altSource of searchResult.results.slice(0, 2)) {
    const tempSourceConfig = { name: altSource.source, articleSelector: 'body' }
    const tempArticle = { ...article, link: altSource.link }
    const contentResult = await scrapeArticleContent(tempArticle, tempSourceConfig)

    if (contentResult.articleContent) {
      const finalAssessment = await articleChain({
        article_text: contentResult.articleContent.contents.join('\n'),
      })
      if (
        finalAssessment &&
        !finalAssessment.error &&
        finalAssessment.relevance_article >= settings.ARTICLES_RELEVANCE_THRESHOLD
      ) {
        logger.info(
          { headline: article.headline },
          'SALVAGE SUCCESS: Successfully enriched from alternative source.'
        )
        const salvagedArticle = {
          ...finalAssessment,
          assessment_article: `[SALVAGED] ${finalAssessment.assessment_article}`,
        }
        return {
          article: salvagedArticle,
          lifecycleEvent: createLifecycleEvent(
            'salvage',
            'success',
            `Used alternative source: ${altSource.link}`
          ),
        }
      }
    }
  }
  return {
    article: null,
    lifecycleEvent: createLifecycleEvent(
      'salvage',
      'failed',
      'All alternatives failed enrichment'
    ),
  }
}

export async function processSingleArticle(article) {
  let transientArticle
  try {
    let source
    if (article.source === 'Richlist Ingestion') {
      logger.trace('Using mock source config for synthetic rich list article.')
      source = {
        name: 'Richlist Ingestion',
        articleSelector: ['body'],
      }
      transientArticle = article
    } else {
      source = await Source.findOne({ name: article.source }).lean()
      if (!source)
        throw new Error(`Could not find source document for "${article.source}"`)
      transientArticle = await scrapeArticleContent(article, source)
    }

    if (transientArticle.articleContent) {
      const articleText = transientArticle.articleContent.contents.join('\n')
      // DEFINITIVE FIX: Changed from .invoke to direct await
      const triageResult = await articlePreAssessmentChain({ input: articleText })

      if (triageResult.error || triageResult.classification !== 'private') {
        return {
          article: null,
          lifecycleEvent: createLifecycleEvent(
            'enrichment',
            'dropped',
            `Failed AI Triage (classified as ${triageResult.classification})`
          ),
          contentPreview: transientArticle.contentPreview,
        }
      }

      // DEFINITIVE FIX: Changed from .invoke to direct await
      const finalAssessment = await articleChain({ article_text: articleText })

      if (finalAssessment.error) {
        throw new Error(finalAssessment.error)
      }

      if (finalAssessment.relevance_article >= settings.ARTICLES_RELEVANCE_THRESHOLD) {
        return {
          article: finalAssessment,
          lifecycleEvent: createLifecycleEvent(
            'enrichment',
            'success',
            `Final score: ${finalAssessment.relevance_article}`
          ),
          contentPreview: transientArticle.contentPreview,
        }
      } else {
        return {
          article: { ...finalAssessment },
          lifecycleEvent: createLifecycleEvent(
            'enrichment',
            'dropped',
            `Content score ${finalAssessment.relevance_article} < threshold ${settings.ARTICLES_RELEVANCE_THRESHOLD}`
          ),
          contentPreview: transientArticle.contentPreview,
        }
      }
    } else {
      if (article.relevance_headline >= settings.HIGH_SIGNAL_HEADLINE_THRESHOLD) {
        return {
          ...(await salvageHighSignalArticle(article)),
          contentPreview: transientArticle.contentPreview,
        }
      } else {
        return {
          article: null,
          lifecycleEvent: createLifecycleEvent(
            'enrichment',
            'dropped',
            `Content scrape failed and headline score ${article.relevance_headline} was not high-signal`
          ),
          contentPreview: transientArticle.contentPreview,
        }
      }
    }
  } catch (error) {
    logger.error(
      { err: error, articleLink: article.link },
      'Critical error during single article processing.'
    )
    return {
      article: null,
      lifecycleEvent: createLifecycleEvent('enrichment', 'error', error.message),
      contentPreview: transientArticle?.contentPreview,
    }
  }
}

```

## 📄 src/pipeline/submodules/triggerSelectorRepair.js
*Lines: 9, Size: 370 Bytes*

```javascript
// apps/pipeline/src/pipeline/submodules/triggerSelectorRepair.js (version 4.0)
import { logger } from '@headlines/utils/src/logger.js';

export async function triggerSelectorRepair(source, htmlContent, failedSelector) {
    logger.warn(`[Repair Orchestrator] SKIPPED for "${source.name}". Self-healing is disabled.`);
    // This function is now a no-op.
    return;
}

```

## 📄 src/utils/auditLogger.js
*Lines: 89, Size: 2.37 KB*

```javascript
// apps/pipeline/src/utils/auditLogger.js
import pino from 'pino'
import fs from 'fs'
import path from 'path'
import { Transform } from 'stream'
import { EOL } from 'os'
import moment from 'moment'
import { format } from 'util'

const COLORS = {
  reset: '\x1b[0m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m',
  yellow: '\x1b[33m',
  grey: '\x1b[90m',
}

const humanAuditStream = new Transform({
  transform(chunk, enc, cb) {
    try {
      const logObject = JSON.parse(chunk)
      const { time, msg, context } = logObject
      const timestamp = moment(time).format('HH:mm:ss.SSS')
      let output = `${COLORS.cyan}--- [${timestamp}] ${msg} ---${COLORS.reset}${EOL}`

      if (context) {
        for (const [key, value] of Object.entries(context)) {
          const formattedKey = key
            .replace(/_/g, ' ')
            .replace(/\b\w/g, (l) => l.toUpperCase())
          output += `  ${COLORS.yellow}${formattedKey}:${COLORS.reset}${EOL}`
          output += `${COLORS.grey}${format(value, { depth: null }).replace(/^/gm, '    > ')}${COLORS.reset}${EOL}${EOL}`
        }
      }
      this.push(output)
    } catch (e) {
      this.push(chunk) // Pass through non-JSON
    }
    cb()
  },
})

let auditLoggerInstance

export function initializeAuditLogger(logDirectory) {
  if (auditLoggerInstance) return auditLoggerInstance

  if (!logDirectory) {
    throw new Error('[AuditLogger] Initialization failed: logDirectory must be provided.')
  }

  if (!fs.existsSync(logDirectory)) fs.mkdirSync(logDirectory, { recursive: true })

  const auditLogFile = path.join(logDirectory, 'run_audit.log')
  try {
    fs.unlinkSync(auditLogFile)
  } catch (e) {
    if (e.code !== 'ENOENT') console.error('Could not clear old audit log file:', e)
  }

  const fileWriteStream = fs.createWriteStream(auditLogFile, { flags: 'a' })
  humanAuditStream.pipe(fileWriteStream)

  auditLoggerInstance = pino({ level: 'info' }, humanAuditStream)
  return auditLoggerInstance
}

export const auditLogger = new Proxy(
  {},
  {
    get(target, prop) {
      if (auditLoggerInstance) {
        return auditLoggerInstance[prop]
      }
      if (
        prop === 'info' ||
        prop === 'warn' ||
        prop === 'error' ||
        prop === 'fatal' ||
        prop === 'debug' ||
        prop === 'trace'
      ) {
        return () => {} // Return a no-op function to prevent crashes
      }
      return undefined
    },
  }
)

```

## 📄 src/utils/errorStream.js
*Lines: 40, Size: 902 Bytes*

```javascript
// apps/pipeline/src/utils/errorStream.js (version 3.0.0)
import pino from 'pino'
import fs from 'fs'
import path from 'path'

const logDir = path.join(process.cwd(), 'apps/pipeline/logs')
const errorLogFile = path.join(logDir, 'error.log')

if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir, { recursive: true })
}
try {
  fs.unlinkSync(errorLogFile)
} catch (error) {
  if (error.code !== 'ENOENT') {
    console.error('Could not clear old error log file:', error)
  }
}

const errorFileTransport = pino.transport({
  target: 'pino-pretty',
  options: {
    colorize: false,
    translateTime: 'SYS:yyyy-mm-dd HH:MM:ss.l',
    ignore: 'pid,hostname',
    singleLine: false,
    destination: errorLogFile,
    mkdir: true,
    append: true,
  },
})

// This stream only logs levels 'warn' and above.
const errorStream = {
  level: 'warn',
  stream: errorFileTransport,
}

export default errorStream

```

## 📄 src/utils/housekeeping.js
*Lines: 43, Size: 1.65 KB*

```javascript
// apps/pipeline/src/utils/housekeeping.js (version 3.0.0)
import { logger } from '@headlines/utils/src/logger.js';
import { findSourcesForScraping, performHousekeeping } from '@headlines/data-access/src/index.js'

const ARTICLE_RETENTION_DAYS = 14

export async function performDatabaseHousekeeping() {
  logger.info('🧹 Performing database housekeeping...')

  try {
    const dynamicSourcesResult = await findSourcesForScraping({ isDynamicContent: true });
    if (!dynamicSourcesResult.success) throw new Error(dynamicSourcesResult.error);
    
    const dynamicNewspaperNames = dynamicSourcesResult.data.map((s) => s.name)
    if (dynamicNewspaperNames.length === 0) {
      logger.info('Housekeeping: No sources marked for dynamic content cleanup. Skipping.')
      return
    }

    const cutoffDate = new Date()
    cutoffDate.setDate(cutoffDate.getDate() - ARTICLE_RETENTION_DAYS)
    const deletionCriteria = {
      newspaper: { $in: dynamicNewspaperNames },
      createdAt: { $lt: cutoffDate },
      $and: [
        { $or: [{ relevance_headline: { $lt: 25 } }, { relevance_headline: { $exists: false } }] },
        { $or: [{ relevance_article: { $lt: 25 } }, { relevance_article: { $exists: false } }] },
      ],
    }

    const result = await performHousekeeping(deletionCriteria);
    if (!result.success) throw new Error(result.error);

    if (result.deletedCount > 0) {
      logger.info(`Housekeeping complete. Deleted ${result.deletedCount} old, irrelevant articles.`)
    } else {
      logger.info('Housekeeping complete. No old, irrelevant articles to delete.')
    }
  } catch (error) {
    logger.error({ err: error }, 'Database housekeeping failed.')
  }
}

```

## 📄 src/utils/humanLogStream.js
*Lines: 59, Size: 1.91 KB*

```javascript
// apps/pipeline/src/utils/humanLogStream.js (version 2.1.0)
import { Transform } from 'stream'
import { EOL } from 'os'
import moment from 'moment'
import { format } from 'util'

const KEYS_TO_IGNORE = new Set(['level', 'time', 'pid', 'hostname', 'msg', 'v']);

function prettyPrint(obj, indent = '  ') {
    let output = '';
    for (const [key, value] of Object.entries(obj)) {
        if (KEYS_TO_IGNORE.has(key)) continue;
        if (value === undefined || value === null || (Array.isArray(value) && value.length === 0)) continue;

        const formattedKey = key.replace(/([A-Z])/g, ' $1').replace(/^./, (str) => str.toUpperCase());
        
        if (typeof value === 'object' && value !== null) {
            const nested = prettyPrint(value, indent + '  ');
            if (nested) {
                output += `${indent}${formattedKey}:${EOL}${nested}`;
            }
        } else {
            output += `${indent}${formattedKey}: ${format(value)}${EOL}`;
        }
    }
    return output;
}

const humanLogStream = new Transform({
    transform(chunk, enc, cb) {
        try {
            const logObject = JSON.parse(chunk);
            const { time, msg, level, ...rest } = logObject;
            
            if (msg.includes("PIPELINE RUN INITIATED")) {
                return cb();
            }

            const timestamp = moment(time).format('HH:mm:ss.SSS');
            let output = `[${timestamp}] ${msg}${EOL}`;

            // DEFINITIVE FIX: Remove the level check. All details from all levels will now be logged to the file.
            const details = prettyPrint(rest);
            if (details) {
                output += details + EOL;
            }
            
            this.push(output);
        } catch (e) {
            // Non-JSON logs (like the final report) will pass through as is.
            this.push(chunk);
            this.push(EOL);
        }
        cb();
    },
});

export default humanLogStream;

```

## 📄 src/utils/pipelineLogger.js
*Lines: 44, Size: 1.59 KB*

```javascript
// apps/pipeline/src/utils/pipelineLogger.js (version 4.1.0)
import { logger } from '@headlines/utils/src/logger.js';
import moment from 'moment';
import 'moment-duration-format';
import {
  formatRunFunnel,
  formatTopEvents,
  formatStrugglingSources,
  formatTokenUsage,
  formatApiUsage,
  formatContentScrapingFailures,
} from './reportSections.js'

const colors = {
  reset: '\x1b[0m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m',
}

/**
 * The main function to log the final, comprehensive report for a pipeline run.
 * @param {Object} runStats - The statistics collected during the pipeline run.
 * @param {number} duration - The duration of the pipeline run in seconds.
 */
export async function logFinalReport(runStats, duration) {
  const formattedDuration = moment.duration(Math.round(duration), 'seconds').format("h [hrs], m [min], s [sec]");

  let report = `\n\n${colors.cyan}=============================================================${colors.reset}\n`
  report += `${colors.cyan} 🚀 PIPELINE RUN SUMMARY${colors.reset}\n`
  report += `${colors.cyan}=============================================================${colors.reset}\n\n`
  report += `  ${colors.magenta}Duration:${colors.reset} ${formattedDuration}\n\n`

  report += formatTokenUsage(runStats)
  report += formatApiUsage(runStats)
  report += formatContentScrapingFailures(runStats)
  report += formatTopEvents(runStats)
  report += await formatStrugglingSources(runStats)

  report += '\n' + formatRunFunnel(runStats)
  report += `${colors.cyan}=============================================================${colors.reset}\n`

  logger.info(report)
}

```

## 📄 src/utils/rag.js
*Lines: 65, Size: 2.28 KB*

```javascript
// apps/pipeline/src/utils/rag.js (version 2.0.0)
import { Pinecone } from '@pinecone-database/pinecone'
import { logger } from './logger.js';
import { generateEmbedding } from '@headlines/ai-services/src/index.js'
import { env } from '@headlines/config/src/server.js'

const { PINECONE_API_KEY, PINECONE_INDEX_NAME } = env;

const SIMILARITY_THRESHOLD = 0.65
const MAX_CONTEXT_ARTICLES = 3

if (!PINECONE_API_KEY) {
  throw new Error('Pinecone API Key must be defined in .env file for RAG module.')
}
const pc = new Pinecone({ apiKey: PINECONE_API_KEY })
const pineconeIndex = pc.index(PINECONE_INDEX_NAME)

/**
 * Finds historical articles similar to a given set of new articles by querying Pinecone.
 * @param {Array<Object>} articlesInCluster - The new articles forming an event.
 * @returns {Promise<Array<Object>>} A promise that resolves to an array of relevant historical articles.
 */
export async function findSimilarArticles(articlesInCluster) {
  logger.info('RAG: Searching for historical context in Pinecone...');
  if (!articlesInCluster || articlesInCluster.length === 0) return [];

  const queryText = articlesInCluster.map((a) => a.headline).join('\n');
  
  try {
    const queryEmbedding = await generateEmbedding(queryText);

    const queryResponse = await pineconeIndex.query({
      topK: MAX_CONTEXT_ARTICLES,
      vector: queryEmbedding,
      includeMetadata: true,
    });

    const relevantMatches = queryResponse.matches.filter(
      (match) => match.score >= SIMILARITY_THRESHOLD
    );

    if (relevantMatches.length > 0) {
      const retrievedArticlesForLogging = relevantMatches
        .map(
          (match) => `  - [Score: ${match.score.toFixed(3)}] "${match.metadata.headline}"`
        )
        .join('\n');
      logger.info(
        `RAG: Found ${relevantMatches.length} relevant historical articles:\n${retrievedArticlesForLogging}`
      );
      return relevantMatches.map((match) => ({
        headline: match.metadata.headline,
        newspaper: match.metadata.newspaper,
        assessment_article: match.metadata.summary,
      }));
    } else {
      logger.info('RAG: Found no relevant historical articles in Pinecone.');
      return [];
    }
  } catch (error) {
    logger.error({ err: error }, 'RAG: Pinecone query or embedding generation failed.');
    return [];
  }
}

```

## 📄 src/utils/redisClient.js
*Lines: 258, Size: 6.63 KB*

```javascript
// apps/pipeline/src/utils/redisClient.js (HTTP Alternative Version)
import { logger } from '@headlines/utils/src/server.js';
import { env } from '@headlines/config/src/server.js';

let httpRedisClient;
let connectionState = 'idle';

// HTTP-based Redis client using fetch (works everywhere)
class HttpRedisClient {
  constructor(url, token) {
    this.baseUrl = url;
    this.token = token;
    this.headers = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    };
  }

  async request(command, ...args) {
    const body = [command, ...args];
    
    try {
      const response = await fetch(`${this.baseUrl}`, {
        method: 'POST',
        headers: this.headers,
        body: JSON.stringify(body),
        timeout: 10000
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      return data.result;
    } catch (err) {
      logger.error({ err: err.message, command, args }, 'Redis HTTP request failed');
      throw err;
    }
  }

  // Common Redis commands
  async ping() {
    return await this.request('PING');
  }

  async get(key) {
    return await this.request('GET', key);
  }

  async set(key, value, options = {}) {
    const args = [key, value];
    if (options.EX) args.push('EX', options.EX);
    if (options.PX) args.push('PX', options.PX);
    if (options.NX) args.push('NX');
    if (options.XX) args.push('XX');
    return await this.request('SET', ...args);
  }

  async del(...keys) {
    return await this.request('DEL', ...keys);
  }

  async exists(...keys) {
    return await this.request('EXISTS', ...keys);
  }

  async incr(key) {
    return await this.request('INCR', key);
  }

  async expire(key, seconds) {
    return await this.request('EXPIRE', key, seconds);
  }

  async ttl(key) {
    return await this.request('TTL', key);
  }

  async hget(key, field) {
    return await this.request('HGET', key, field);
  }

  async hset(key, ...fieldValues) {
    return await this.request('HSET', key, ...fieldValues);
  }

  async hgetall(key) {
    return await this.request('HGETALL', key);
  }

  async hdel(key, ...fields) {
    return await this.request('HDEL', key, ...fields);
  }

  async lpush(key, ...values) {
    return await this.request('LPUSH', key, ...values);
  }

  async rpush(key, ...values) {
    return await this.request('RPUSH', key, ...values);
  }

  async lpop(key) {
    return await this.request('LPOP', key);
  }

  async rpop(key) {
    return await this.request('RPOP', key);
  }

  async llen(key) {
    return await this.request('LLEN', key);
  }

  // Utility methods to match redis client interface
  get isOpen() {
    return true; // HTTP client is always "open"
  }

  async disconnect() {
    // No persistent connection to close
    return 'OK';
  }

  async quit() {
    return this.disconnect();
  }
}

export async function getRedisClient() {
  if (connectionState === 'ready' && httpRedisClient) {
    return httpRedisClient;
  }
  
  if (connectionState === 'failed' || connectionState === 'connecting') {
    return null;
  }
  
  if (connectionState === 'idle') {
    // First, try to get HTTP credentials
    const restUrl = env.UPSTASH_REDIS_REST_URL;
    const restToken = env.UPSTASH_REDIS_REST_TOKEN;
    
    if (restUrl && restToken) {
      logger.info('Using Upstash Redis HTTP REST API...');
      connectionState = 'connecting';
      
      try {
        const client = new HttpRedisClient(restUrl, restToken);
        
        // Test the connection
        const pingResult = await client.ping();
        if (pingResult === 'PONG') {
          logger.info('✅ Redis HTTP client connected and ping test successful.');
          connectionState = 'ready';
          httpRedisClient = client;
          return httpRedisClient;
        } else {
          throw new Error(`Unexpected ping response: ${pingResult}`);
        }
        
      } catch (err) {
        logger.error({ err: err.message }, 'Redis HTTP connection failed.');
        connectionState = 'failed';
        return null;
      }
    }
    
    // Fallback: Try TCP connection if HTTP not configured
    if (!env.REDIS_URL) {
      logger.warn('Neither REDIS_URL nor Upstash HTTP credentials found. Caching will be disabled.');
      connectionState = 'failed';
      return null;
    }

    logger.info('HTTP Redis not configured, attempting TCP connection...');
    
    try {
      // Import Redis dynamically to avoid issues if not needed
      const { createClient } = await import('redis');
      
      connectionState = 'connecting';
      const client = createClient({
        url: env.REDIS_URL,
        socket: {
          connectTimeout: 15000,
          tls: { rejectUnauthorized: false }
        }
      });

      client.on('error', (err) => {
        logger.error({ err: err.message }, 'Redis TCP client error');
        connectionState = 'failed';
      });

      await client.connect();
      await client.ping();
      
      logger.info('✅ Redis TCP client connected successfully.');
      connectionState = 'ready';
      httpRedisClient = client;
      return client;
      
    } catch (err) {
      logger.error({ err: err.message }, 'Both HTTP and TCP Redis connections failed.');
      connectionState = 'failed';
      return null;
    }
  }
}

export async function testRedisConnection() {
  if (!env.UPSTASH_REDIS_REST_URL && !env.REDIS_URL) {
    logger.warn('Redis is not configured. Caching will be disabled.');
    return true;
  }

  try {
    const client = await getRedisClient();
    
    if (client) {
      // Test basic operations
      const testKey = `test:${Date.now()}`;
      await client.set(testKey, 'test-value', { EX: 10 });
      const testValue = await client.get(testKey);
      await client.del(testKey);
      
      if (testValue === 'test-value') {
        logger.info('✅ Redis connection and read/write test successful.');
        return true;
      } else {
        logger.warn('Redis connected but read/write test failed.');
        return true;
      }
    } else {
      logger.warn('Redis client not available. Pipeline will continue with caching disabled.');
      return true;
    }
  } catch (err) {
    logger.warn({ err: err.message }, 'Redis pre-flight check failed. Pipeline will continue with caching disabled.');
    return true;
  }
}

export async function closeRedisClient() {
  if (httpRedisClient) {
    try {
      await httpRedisClient.disconnect();
      logger.info('Redis client connection closed gracefully.');
    } catch (err) {
      logger.warn({ err: err.message }, 'Error closing Redis client.');
    } finally {
      httpRedisClient = null;
      connectionState = 'idle';
    }
  }
}
```

## 📄 src/utils/reportSections.js
*Lines: 210, Size: 7.63 KB*

```javascript
// apps/pipeline/src/utils/reportSections.js (version 5.1.0)
import { truncateString } from '@headlines/utils/src/server.js';
import { logger } from '@headlines/utils/src/logger.js';
import moment from 'moment';
import 'moment-duration-format';

const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m',
  grey: '\x1b[90m',
}

function calculateRate(numerator, denominator) {
  if (denominator === 0) return '0.00%'
  return ((numerator / denominator) * 100).toFixed(2) + '%'
}

function truncateSourceName(name) {
  if (!name) return 'N/A'
  const stopIndex = name.indexOf('(')
  return (stopIndex !== -1 ? name.substring(0, stopIndex) : name).trim()
}

function formatJudgeVerdictSummary(judgeVerdict) {
  if (!judgeVerdict) return ''
  const eventCount = judgeVerdict.event_judgements?.length || 0
  const oppCount = judgeVerdict.opportunity_judgements?.length || 0
  if (eventCount === 0 && oppCount === 0) return ''
  const getQualityCounts = (judgements) => {
    const counts = { positive: 0, negative: 0 }
    ;(judgements || []).forEach((j) => {
      const q = j.quality?.toLowerCase()
      if (q === 'excellent' || q === 'good') counts.positive++
      if (q === 'poor' || q === 'irrelevant') counts.negative++
    })
    return counts
  }
  const eventCounts = getQualityCounts(judgeVerdict.event_judgements)
  let summary = `  ${colors.magenta}Judge Verdict Summary:${colors.reset} ${eventCount} Events (${colors.green}${eventCounts.positive} OK${colors.reset}, ${colors.red}${eventCounts.negative} Bad${colors.reset})`
  return summary + '\n'
}

export function formatRunFunnel(runStats) {
  let section = `  ${colors.yellow}--- Funnel & Conversion (This Run) ---${colors.reset}\n`
  const headlineToEnrichRate = calculateRate(
    runStats.relevantHeadlines,
    runStats.freshHeadlinesFound
  )
  const enrichToEventRate = calculateRate(
    runStats.relevantArticles,
    runStats.relevantHeadlines
  )
  const signalToNoiseRatio = calculateRate(
    runStats.eventsSynthesized,
    runStats.freshHeadlinesFound
  )

  section += `  ${'Headlines Scraped:'.padEnd(30)} ${runStats.headlinesScraped}\n`
  section += `  ${'Fresh/Refreshed Articles:'.padEnd(30)} ${
    runStats.freshHeadlinesFound
  }\n`
  section += `  ${'Headlines Assessed:'.padEnd(30)} ${runStats.headlinesAssessed}\n`
  section += `  ${'  > Relevant for Enrichment:'.padEnd(30)} ${
    runStats.relevantHeadlines
  } (${colors.cyan}${headlineToEnrichRate}${colors.reset})\n`
  section += `  ${'Articles Enriched:'.padEnd(30)} ${
    runStats.enrichmentOutcomes?.length || 0
  }\n`
  section += `  ${'  > Relevant for Event:'.padEnd(30)} ${
    runStats.relevantArticles
  } (${colors.cyan}${enrichToEventRate}${colors.reset})\n`
  section += `  ${'Events Synthesized:'.padEnd(30)} ${runStats.eventsSynthesized}\n`
  section += `  ${colors.green}${'Notifications Sent:'.padEnd(30)} ${
    runStats.eventsEmailed
  }${colors.reset}\n`
  if (runStats.errors?.length > 0) {
    section += `  ${colors.red}${'Errors Encountered:'.padEnd(30)} ${
      runStats.errors.length
    }${colors.reset}\n`
  }
  section += `  ${colors.yellow}${'Overall Signal/Noise Ratio:'.padEnd(30)} ${signalToNoiseRatio}${
    colors.reset
  }\n`
  section += formatJudgeVerdictSummary(runStats.judgeVerdict)
  return section
}

export function formatTopEvents(runStats) {
  if (
    !runStats.synthesizedEventsForReport ||
    runStats.synthesizedEventsForReport.length === 0
  )
    return ''
  let section = `  ${colors.yellow}--- Top Synthesized Events (This Run) ---${colors.reset}\n`
  runStats.synthesizedEventsForReport.slice(0, 5).forEach((event) => {
    section += `  ${colors.green}[${String(event.highest_relevance_score).padStart(
      3
    )}]${colors.reset} "${truncateString(event.synthesized_headline, 70)}"\n`
  })
  return section + '\n'
}

export function formatTokenUsage(runStats) {
  if (!runStats.tokenUsage) return ''
  let section = `  ${colors.yellow}--- Token Usage & Cost (Estimate) ---${colors.reset}\n`
  let totalCost = 0
  const usage = runStats.tokenUsage
  const modelsWithUsage = Object.keys(usage).filter(
    (model) => usage[model].inputTokens > 0 || usage[model].outputTokens > 0
  )
  if (modelsWithUsage.length === 0) {
    section += `  No token usage recorded for this run.\n`
    return section
  }
  modelsWithUsage.forEach((model) => {
    const stats = usage[model]
    section += `  ${`Model: ${model}`.padEnd(40)}\n`
    section += `  ${'  Input Tokens:'.padEnd(25)} ${stats.inputTokens.toLocaleString()}\n`
    section += `  ${'  Output Tokens:'.padEnd(25)} ${stats.outputTokens.toLocaleString()}\n`
    section += `  ${'  Est. Cost:'.padEnd(25)} $${stats.cost.toFixed(4)}\n`
    totalCost += stats.cost
  })
  section += `  ------------------------------------------------\n`
  section += `  ${colors.green}${'Total Estimated Cost:'.padEnd(
    25
  )} $${totalCost.toFixed(4)}${colors.reset}\n`
  return section + '\n'
}

export function formatApiUsage(runStats) {
  if (!runStats.apiCalls) return ''
  let section = `  ${colors.yellow}--- Third-Party API Usage (Estimate) ---${colors.reset}\n`
  let totalCost = 0
  const usage = runStats.apiCalls
  const servicesWithUsage = Object.keys(usage).filter(
    (service) => usage[service].calls > 0
  )
  if (servicesWithUsage.length === 0) {
    section += `  No third-party API calls recorded for this run.\n`
    return section
  }
  servicesWithUsage.forEach((service) => {
    const stats = usage[service]
    const costString = stats.cost > 0 ? `$${stats.cost.toFixed(4)}` : '(Free)'
    section += `  ${`${service}:`.padEnd(25)} ${`${stats.calls.toLocaleString()} calls`.padEnd(
      15
    )} ${costString}\n`
    totalCost += stats.cost
  })
  section += `  ------------------------------------------------\n`
  section += `  ${colors.green}${'Total Estimated Cost:'.padEnd(
    25
  )} $${totalCost.toFixed(4)}${colors.reset}\n`
  return section + '\n'
}

export function formatContentScrapingFailures(runStats) {
  if (!runStats.enrichmentOutcomes || runStats.enrichmentOutcomes.length === 0) {
    return ''
  }

  const contentFailures = runStats.enrichmentOutcomes.filter(
    (outcome) =>
      outcome.outcome === 'High-Signal Failure' ||
      (outcome.outcome === 'Dropped' &&
        (outcome.assessment_article || '').includes('Enrichment Failed'))
  )

  if (contentFailures.length === 0) {
    return ''
  }

  const sources = [...new Set(contentFailures.map((f) => f.newspaper))]

  let section = `  ${colors.red}--- ACTION REQUIRED: Content Scraping Failures ---${colors.reset}\n`
  section += `  The following sources successfully scraped headlines but failed to extract article content for high-relevance items.\n`
  section += `  Their 'articleSelector' likely needs to be updated:\n`
  sources.forEach((sourceName) => {
    section += `  - ${sourceName}\n`
  })
  return section + '\n'
}

export async function formatStrugglingSources(runStats, dbStats) {
  const headlineFailures = (runStats.scraperHealth || []).filter(h => !h.success);
  const strugglingSources = new Map();

  headlineFailures.forEach(failure => {
    strugglingSources.set(failure.source, 'Scraped 0 headlines (Immediate Action Required)');
  });

  let section = `  ${colors.magenta}Actionable Source Health Alerts:${colors.reset}\n`
  if (strugglingSources.size > 0) {
    strugglingSources.forEach((reason, sourceName) => {
      section += `  ${colors.red}${`- ${truncateSourceName(sourceName)}:`.padEnd(
        25
      )}${reason}${colors.reset}\n`
    })
  } else {
    section += `  ${colors.green}  All sources are performing within expected parameters.${colors.reset}\n`
  }
  return section + '\n'
}

export function formatTopSources(dbStats) { return '' }

```
