// packages/auth/src/AuthProvider.js (version 7.1.0 - Admin No-Fetch)
'use client'

import { createContext, useState, useEffect, useCallback } from 'react'
import { useRouter, usePathname } from 'next/navigation'
import { toast } from 'sonner'
import { LoadingOverlay } from '../../ui/src/index.js'

const AuthContext = createContext(null)

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null)
  const [authStatus, setAuthStatus] = useState('verifying')
  const router = useRouter()
  const pathname = usePathname()
  
  // A more robust check for the admin app context
  const isAdminApp = typeof window !== 'undefined' && window.location.port === '3001';

  const fetchUser = useCallback(async () => {
    // DEFINITIVE FIX: For the admin app in development, create a mock user session
    // and IMMEDIATELY set status to 'authenticated'. DO NOT make an API call.
    if (isAdminApp && process.env.NODE_ENV === 'development') {
      setUser({ _id: 'dev_admin_id', firstName: 'Admin', role: 'admin' });
      setAuthStatus('authenticated');
      return;
    }

    // This block now only runs for the client application
    try {
      const res = await fetch('/api/subscribers/me');
      if (res.ok) {
        setUser(await res.json());
        setAuthStatus('authenticated');
      } else {
        setUser(null);
        setAuthStatus('unauthenticated');
      }
    } catch (error) {
      setUser(null);
      setAuthStatus('unauthenticated');
    }
  }, [isAdminApp]);

  useEffect(() => {
    fetchUser();
  }, [fetchUser]);

  const login = async (email, password) => {
    setAuthStatus('loading');
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });
      const data = await response.json();
      if (response.ok) {
        toast.success(`Welcome back, ${data.user.firstName}!`);
        window.location.assign('/events');
      } else {
        toast.error(data.error || 'Login failed.');
        setAuthStatus('unauthenticated');
      }
    } catch (error) {
      toast.error('An unexpected error occurred during login.');
      setAuthStatus('unauthenticated');
    }
  };

  const logout = async () => {
    await fetch('/api/auth/logout', { method: 'POST' });
    setUser(null);
    setAuthStatus('unauthenticated');
    toast.info('You have been logged out.');
    window.location.assign('/login');
  };

  const updateUserPreferences = async (updateData) => {
      console.log("Updating user preferences (placeholder):", updateData);
      setUser(currentUser => ({...currentUser, ...updateData}));
      toast.success("Preferences updated (local only).");
  };

  const value = { user, isLoading: authStatus === 'loading', login, logout, updateUserPreferences };

  // For the admin app, we can skip the verifying overlay as the user is mocked instantly.
  if (authStatus === 'verifying' && !isAdminApp) {
    return <LoadingOverlay isLoading={true} text="Verifying session..." />;
  }
  
  // If we are unauthenticated and not on the login page in the client app, the middleware will handle redirection.
  // For the admin app, we always render the children as auth is handled by the mock and server-side checks.
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export default AuthContext;
