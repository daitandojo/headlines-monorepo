# ðŸ“ PROJECT DIRECTORY STRUCTURE

Total: 6 files, 1 directories

```
headlines/
â”œâ”€â”€ ðŸ“ src/
â”‚   â”œâ”€â”€ ðŸ“„ AuthProvider.js
â”‚   â”œâ”€â”€ ðŸ“„ getCookies.js
â”‚   â”œâ”€â”€ ðŸ“„ index.js
â”‚   â”œâ”€â”€ ðŸ“„ useAuth.js
â”‚   â””â”€â”€ ðŸ“„ verifySession.js
â””â”€â”€ ðŸ“„ package.json
```

# ðŸ“‹ PROJECT METADATA

**Generated**: 2025-09-21T14:17:28.667Z
**Repository Path**: /home/mark/Repos/projects/headlines/packages/auth
**Total Files**: 6
**Package**: @headlines/auth@4.0.0
**Description**: Shared authentication logic for the Headlines monorepo.



---


## ðŸ“„ package.json
*Lines: 25, Size: 591 Bytes*

```json
{
  "name": "@headlines/auth",
  "version": "4.0.0",
  "description": "Shared authentication logic for the Headlines monorepo.",
  "main": "src/index.js",
  "type": "module",
  "license": "ISC",
  "exports": {
    ".": "./src/index.js",
    "./useAuth": "./src/useAuth.js",
    "./AuthProvider": "./src/AuthProvider.js"
  },
  "dependencies": {
    "@headlines/config": "workspace:*",
    "@headlines/actions": "workspace:*",
    "@headlines/ui": "workspace:*",
    "jose": "^5.4.1",
    "sonner": "^1.5.0"
  },
  "peerDependencies": {
    "react": "18.3.1",
    "next": "^14.2.0"
  }
}

```

## ðŸ“„ src/AuthProvider.js
*Lines: 99, Size: 2.74 KB*

```javascript
'use client'

import React, { createContext, useState, useEffect, useCallback } from 'react'
import { usePathname, useRouter } from 'next/navigation'
import { toast } from 'sonner'
import { LoadingOverlay } from '@headlines/ui'

async function getSubscriberMeClient() {
  const res = await fetch('/api/subscribers/me')
  if (res.ok) return res.json()
  return null
}

export const AuthContext = createContext(null)

export function AuthProvider({ children, appType }) {
  const [user, setUser] = useState(null)
  const [loading, setLoading] = useState(true)
  const router = useRouter()
  const pathname = usePathname()

  const fetchUser = useCallback(async () => {
    const data = await getSubscriberMeClient()
    setUser(data)
    setLoading(false)
  }, [])

  useEffect(() => {
    fetchUser()
  }, [fetchUser])

  useEffect(() => {
    if (!loading && !user && !pathname.startsWith('/login')) {
      router.push('/login')
    }
  }, [user, loading, pathname, router])

  const login = async (email, password) => {
    setLoading(true)
    // Both apps call the same canonical API route hosted by the client app
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })
    const data = await response.json()
    setLoading(false)
    if (response.ok) {
      toast.success('Login successful!')
      setUser(data.user)
      // Redirect based on which app this provider is in
      router.push(appType === 'admin' ? '/dashboard' : '/events')
    } else {
      toast.error('Login Failed', { description: data.error })
    }
  }

  const logout = async () => {
    await fetch('/api/auth/logout', { method: 'POST' })
    toast.info('You have been logged out.')
    setUser(null)
    router.push('/login')
  }

  const updateUserPreferences = async (updateData) => {
    if (!user) return
    try {
      const response = await fetch('/api/user/profile', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updateData),
      })
      const updatedUser = await response.json()
      if (!response.ok) {
        throw new Error(updatedUser.error || 'Server error')
      }
      setUser(updatedUser)
      toast.success('Preferences updated successfully.')
    } catch (error) {
      toast.error('Failed to update preferences', { description: error.message })
    }
  }

  const value = {
    user,
    isAuthenticated: !!user,
    loading,
    login,
    logout,
    updateUserPreferences,
  }

  if (loading && !pathname.startsWith('/login')) {
    return <LoadingOverlay isLoading={true} text="Initializing Session..." />
  }

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
}

```

## ðŸ“„ src/getCookies.js
*Lines: 36, Size: 791 Bytes*

```javascript
'use server'

/**
 * An environment-aware cookie accessor.
 */
export async function getCookies() {
  if (
    process.env.IS_PIPELINE_RUN === 'true' ||
    typeof window !== 'undefined' ||
    !process.env.NEXT_RUNTIME
  ) {
    // Return a mock for non-Next.js server environments or client-side
    return {
      get: () => undefined,
      getAll: () => [],
      has: () => false,
      set: () => {},
      delete: () => {},
    }
  }
  try {
    const { cookies } = await import('next/headers')
    return cookies()
  } catch (error) {
    console.error('Failed to import cookies from next/headers:', error.message)
    // Fallback mock
    return {
      get: () => undefined,
      getAll: () => [],
      has: () => false,
      set: () => {},
      delete: () => {},
    }
  }
}

```

## ðŸ“„ src/index.js
*Lines: 5, Size: 187 Bytes*

```javascript
import { verifySession, verifyAdmin, getUserIdFromSession } from './verifySession.js'

// This is the SERVER-ONLY entry point.
export { verifySession, verifyAdmin, getUserIdFromSession }

```

## ðŸ“„ src/useAuth.js
*Lines: 13, Size: 279 Bytes*

```javascript
'use client'

import { useContext } from 'react'
import { AuthContext } from './AuthProvider.js'

export const useAuth = () => {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}

```

## ðŸ“„ src/verifySession.js
*Lines: 59, Size: 1.57 KB*

```javascript
'use server'

import { getCookies } from './getCookies.js'
import * as jose from 'jose'
import { env } from '@headlines/config/server'
import { seedDevUser } from '@headlines/actions/seed/dev-user.js'

const JWT_COOKIE_NAME = 'headlines-jwt'

async function verifyToken(token) {
  if (!token) return { user: null, error: 'No token provided.' }
  try {
    const secret = new TextEncoder().encode(env.JWT_SECRET)
    const { payload } = await jose.jwtVerify(token, secret)
    return { user: payload, error: null }
  } catch (e) {
    return { user: null, error: 'Invalid or expired session token.' }
  }
}

export async function verifySession() {
  const cookieStore = await getCookies()
  const token = cookieStore.get(JWT_COOKIE_NAME)?.value
  return await verifyToken(token)
}

export async function getUserIdFromSession() {
  const { user } = await verifySession()
  return user ? user.userId : null
}

export async function verifyAdmin() {
  const { headers } = await import('next/headers')
  const headersList = headers()

  if (
    process.env.NODE_ENV === 'development' &&
    headersList.get('x-dev-mode') === 'true'
  ) {
    await seedDevUser()
    const devUser = {
      userId: '662f831abb28052123530a43',
      email: 'dev@headlines.dev',
      role: 'admin',
    }
    return { isAdmin: true, user: devUser, error: null }
  }

  const { user, error } = await verifySession()
  if (error || user?.role !== 'admin') {
    return {
      isAdmin: false,
      error: error || 'Administrator access required.',
      user: null,
    }
  }
  return { isAdmin: true, user, error: null }
}

```
