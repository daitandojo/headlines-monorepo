# 📁 PROJECT DIRECTORY STRUCTURE

Total: 12 files, 1 directories

```
headlines/
├── 📁 src/
│   ├── 📄 apiCallTracker.js
│   ├── 📄 auditLogger.js
│   ├── 📄 core.js
│   ├── 📄 helpers.js
│   ├── 📄 logger.js
│   ├── 📄 mailer.js
│   ├── 📄 next.js
│   ├── 📄 node.js
│   ├── 📄 pusher.js
│   ├── 📄 redisClient.js
│   └── 📄 tokenTracker.js
└── 📄 package.json
```

# 📋 PROJECT METADATA

**Generated**: 2025-09-29T22:40:44.845Z
**Repository Path**: /home/mark/Repos/projects/headlines/packages/utils-server
**Total Files**: 12
**Package**: @headlines/utils-server@3.0.0
**Description**: Server-only utilities for the Headlines monorepo.



---


## 📄 package.json
*Lines: 37, Size: 1.02 KB*

```json
{
  "name": "@headlines/utils-server",
  "version": "3.0.0",
  "description": "Server-only utilities for the Headlines monorepo.",
  "main": "src/index.js",
  "type": "module",
  "license": "ISC",
  "exports": {
    ".": "./src/node.js",
    "./node": "./src/node.js",
    "./next": "./src/next.js",
    "./logger": "./src/logger.js",
    "./helpers": "./src/helpers.js",
    "./tokenTracker": "./src/tokenTracker.js",
    "./apiCallTracker": "./src/apiCallTracker.js",
    "./auditLogger": "./src/auditLogger.js",
    "./redisClient": "./src/redisClient.js",
    "./mailer": "./src/mailer.js",
    "./pusher": "./src/pusher.js"
  },
  "dependencies": {
    "@headlines/config": "workspace:*",
    "@headlines/models": "workspace:*",
    "@upstash/redis": "^1.35.4",
    "cheerio": "^1.0.0-rc.12",
    "clsx": "^2.1.1",
    "moment": "^2.30.1",
    "nodemailer": "^6.9.14",
    "pino": "^9.2.0",
    "pino-pretty": "^11.2.1",
    "pusher": "^5.2.0",
    "redis": "^4.6.15",
    "server-only": "^0.0.1",
    "tailwind-merge": "^2.3.0"
  }
}

```

## 📄 src/apiCallTracker.js
*Lines: 37, Size: 854 Bytes*

```javascript
import { logger } from './logger.js'

const servicePricing = {
  serper_news: 2.5,
  serper_search: 2.5,
  newsapi_search: 0,
  wikipedia: 0,
}
class ApiCallTracker {
  constructor() {
    this.usage = {}
    this.reset()
  }
  reset() {
    this.usage = {}
    Object.keys(servicePricing).forEach((service) => {
      this.usage[service] = { calls: 0, cost: 0 }
    })
  }
  recordCall(service) {
    if (!service) return
    if (!this.usage[service]) {
      logger.warn(`API call recorded for an un-priced service: ${service}.`)
      this.usage[service] = { calls: 0, cost: 0 }
    }
    this.usage[service].calls += 1
    const pricePer1000 = servicePricing[service]
    if (pricePer1000) {
      this.usage[service].cost += pricePer1000 / 1000
    }
  }
  getStats() {
    return this.usage
  }
}
export const apiCallTracker = new ApiCallTracker()

```

## 📄 src/auditLogger.js
*Lines: 49, Size: 2.11 KB*

```javascript
import pino from 'pino';
import fs from 'fs';
import path from 'path';
import { Transform } from 'stream';
import { EOL } from 'os';
import moment from 'moment';
import { format } from 'util';
const COLORS = { reset: '\x1b[0m', cyan: '\x1b[36m', magenta: '\x1b[35m', yellow: '\x1b[33m', grey: '\x1b[90m' };
const humanAuditStream = new Transform({
  transform(chunk, enc, cb) {
    try {
      const logObject = JSON.parse(chunk);
      const { time, msg, context } = logObject;
      const timestamp = moment(time).format('HH:mm:ss.SSS');
      let output = `${COLORS.cyan}--- [${timestamp}] ${msg} ---${COLORS.reset}${EOL}`;
      if (context) {
        for (const [key, value] of Object.entries(context)) {
          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
          output += `  ${COLORS.yellow}${formattedKey}:${COLORS.reset}${EOL}`;
          output += `${COLORS.grey}${format(value).replace(/^/gm, '    > ')}${COLORS.reset}${EOL}${EOL}`;
        }
      }
      this.push(output);
    } catch (e) { this.push(chunk); }
    cb();
  },
});
let auditLoggerInstance;
export function initializeAuditLogger(logDirectory) {
  if (auditLoggerInstance) return auditLoggerInstance;
  if (!logDirectory) { throw new Error('[AuditLogger] Initialization failed: logDirectory must be provided.'); }
  if (!fs.existsSync(logDirectory)) fs.mkdirSync(logDirectory, { recursive: true });
  const auditLogFile = path.join(logDirectory, 'run_audit.log');
  try { fs.unlinkSync(auditLogFile); } catch (e) { if (e.code !== 'ENOENT') console.error('Could not clear old audit log file:', e); }
  const fileWriteStream = fs.createWriteStream(auditLogFile, { flags: 'a' });
  humanAuditStream.pipe(fileWriteStream);
  auditLoggerInstance = pino({ level: 'info' }, humanAuditStream);
  return auditLoggerInstance;
}
export const auditLogger = new Proxy({}, {
  get(target, prop) {
    if (auditLoggerInstance) { return auditLoggerInstance[prop]; }
    if (prop === 'info' || prop === 'warn' || prop === 'error' || prop === 'fatal' || prop === 'debug' || prop === 'trace') {
      return () => {};
    }
    return undefined;
  },
});

```

## 📄 src/core.js
*Lines: 10, Size: 319 Bytes*

```javascript
// File: packages/utils-server/src/index.js (version 3.2 - Unchanged)
export * from './auditLogger.js'
export * from './helpers.js'
export * from './logger.js'
export * from './redisClient.js'
export * from './tokenTracker.js'
export * from './apiCallTracker.js'
export * from './mailer.js'
export * from './pusher.js'

```

## 📄 src/helpers.js
*Lines: 60, Size: 2.07 KB*

```javascript
// File: packages/utils-server/src/helpers.js

/**
 * Creates a promise that rejects after a specified timeout.
 * @param {number} ms - The timeout duration in milliseconds.
 * @param {string} [customMessage] - An optional message for the timeout error.
 * @returns {Promise<never>} A promise that will reject.
 */
function promiseTimeout(ms, customMessage = 'Operation timed out.') {
  return new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error(customMessage));
    }, ms);
  });
}

/**
 * Wraps an async function in a try-catch block and a timeout race.
 * @param {Function} asyncFn - The async function to execute.
 * @param {object} [options] - Options object.
 * @param {Function} [options.errorHandler] - An optional custom error handler.
 * @param {number} [options.timeout=90000] - Timeout in milliseconds. Defaults to 90 seconds.
 * @returns {Promise<any|null>} The result of the async function or null/custom error result.
 */
export async function safeExecute(asyncFn, { errorHandler, timeout = 90000 } = {}) {
  try {
    // Race the async function against a timeout promise.
    return await Promise.race([
      asyncFn(),
      promiseTimeout(timeout, `safeExecute timed out after ${timeout / 1000}s`)
    ]);
  } catch (error) {
    if (errorHandler) {
      return errorHandler(error);
    }
    // Log the error centrally, so individual call sites don't have to.
    console.error(
      'An unexpected error occurred in a safeExecute block:',
      error
    );
    return null; // Return null on failure
  }
}

// ... (keep the smartStripHtml function)

/**
 * Strips scripts, styles, and other non-content tags from an HTML string.
 * @param {string} rawHtml - The raw HTML content.
 * @returns {Promise<string>} The cleaned body HTML.
 */
export async function smartStripHtml(rawHtml) {
  // Use dynamic import for cheerio to keep it a lightweight dependency
  const cheerio = await import('cheerio');
  const $ = cheerio.load(rawHtml);
  $(
    'script, style, link[rel="stylesheet"], noscript, svg, path, footer, header, nav'
  ).remove();
  return $('body').html();
}
```

## 📄 src/logger.js
*Lines: 107, Size: 2.79 KB*

```javascript
// packages/utils-server/src/logger.js
import pino from 'pino'
import fs from 'fs'
import path from 'path'
import { createRequire } from 'module'
const require = createRequire(import.meta.url)

const LOG_LEVEL = process.env.LOG_LEVEL || 'trace'
const IS_PRODUCTION = process.env.NODE_ENV === 'production'

let loggerInstance

const createSimpleLogger = () => {
  const simpleLogger = {}
  const levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal']
  levels.forEach((level) => {
    const consoleMethod = level === 'trace' || level === 'debug' ? 'log' : level
    simpleLogger[level] = (...args) => {
      console[consoleMethod](`[${level.toUpperCase()}]`, ...args)
    }
  })
  return simpleLogger
}

export function initializeLogger(logDirectory = null, extraStreams = []) {
  if (loggerInstance) {
    return loggerInstance
  }

  if (process.env.NEXT_RUNTIME) {
    console.log('Detected Next.js runtime. Initializing safe console logger.')
    loggerInstance = createSimpleLogger()
    return loggerInstance
  }

  const pinoPrettyPath = require.resolve('pino-pretty')
  const consoleTransport = pino.transport({
    target: pinoPrettyPath,
    options: {
      colorize: true,
      translateTime: 'HH:MM:ss',
      ignore:
        'pid,hostname,runStats,article,assessment,event,payload,details,context,embedding,finalAssessment,watchlistHits,hits,reasoning,enrichmentSources,source_articles,key_individuals,source',
      singleLine: true,
      messageFormat: '{msg}',
    },
  })

  const streams = [{ level: LOG_LEVEL, stream: consoleTransport }, ...extraStreams]

  loggerInstance = pino({ level: 'trace' }, pino.multistream(streams))
  return loggerInstance
}

export const logger = new Proxy(
  {},
  {
    get(target, prop) {
      if (loggerInstance) {
        return loggerInstance[prop]
      }
      return initializeLogger()[prop]
    },
  }
)

export function reinitializeLogger(logDirectory, extraStreams = []) {
  const pinoPrettyPath = require.resolve('pino-pretty')

  const consoleTransport = {
    level: LOG_LEVEL,
    target: pinoPrettyPath,
    options: {
      colorize: true,
      translateTime: 'HH:mm:ss',
      ignore: 'pid,hostname,context',
      singleLine: true,
      messageFormat: '{msg}',
    },
  }

  const logFile = path.join(logDirectory, 'run.log')
  const fileTransport = {
    level: 'trace',
    target: pinoPrettyPath,
    options: {
      colorize: false,
      // DEFINITIVE FIX: Use 'mm' for minutes and 'MM' for month.
      translateTime: 'YYYY/MM/DD HH:mm:ss',
      ignore: 'pid,hostname',
      destination: logFile,
      mkdir: true,
      append: false,
    },
  }

  const allStreams = [
    pino.transport(consoleTransport),
    pino.transport(fileTransport),
    ...extraStreams,
  ]

  loggerInstance = pino({ level: 'trace' }, pino.multistream(allStreams))

  return loggerInstance
}

```

## 📄 src/mailer.js
*Lines: 80, Size: 2.55 KB*

```javascript
// Full Path: headlines/packages/utils-server/src/mailer.js
import nodemailer from 'nodemailer'
import { logger } from './logger.js'
import { safeExecute } from './helpers.js'
import { SMTP_CONFIG } from '@headlines/config'
import { Subscriber } from '@headlines/models'

// Cache for admin emails to avoid hitting the DB for every single email sent.
let adminEmailsCache = null
let cacheTimestamp = 0
const CACHE_TTL = 1000 * 60 * 5 // 5 minutes

async function getAdminEmails() {
  if (adminEmailsCache && Date.now() - cacheTimestamp < CACHE_TTL) {
    return adminEmailsCache
  }

  const admins = await Subscriber.find({ role: 'admin', isActive: true })
    .select('email')
    .lean()
  adminEmailsCache = admins.map((admin) => admin.email)
  cacheTimestamp = Date.now()

  return adminEmailsCache
}

async function sendEmail(mailOptions, emailType) {
  if (!SMTP_CONFIG?.auth?.user || !SMTP_CONFIG?.auth?.pass) {
    logger.error(`❌ [${emailType} Mailer] SMTP authentication not fully configured.`)
    return { error: 'SMTP authentication not fully configured.' }
  }
  const transporter = nodemailer.createTransport(SMTP_CONFIG)
  const sendResult = await safeExecute(() => transporter.sendMail(mailOptions), {
    errorHandler: (error) => ({ errorOccurred: true, details: error.message }),
  })
  if (sendResult && sendResult.errorOccurred) {
    logger.error(`❌ [${emailType} Mailer] Nodemailer SMTP error:`, {
      details: sendResult.details,
    })
    return { error: `SMTP Error: ${sendResult.details}` }
  }
  logger.info(
    `✅ [${emailType} Mailer] Email sent successfully to ${mailOptions.to}. BCC: ${mailOptions.bcc || 'None'}`
  )
  return { success: true }
}

export async function sendGenericEmail({ to, subject, html, emailType = 'Generic' }) {
  if (!to) {
    logger.error(`❌ [${emailType} Mailer] Invalid 'to' address provided.`)
    return false
  }

  const mailOptions = {
    from: `"${SMTP_CONFIG.fromName}" <${SMTP_CONFIG.fromAddress}>`,
    to,
    subject,
    html,
  }

  // --- START DEFINITIVE FIX ---
  // Apply BCC logic ONLY for non-supervisor reports.
  if (emailType !== 'SupervisorReport') {
    const allAdminEmails = await getAdminEmails()

    // Filter out the primary recipient from the BCC list if they are an admin.
    const bccList = allAdminEmails.filter(
      (adminEmail) => adminEmail.toLowerCase() !== to.toLowerCase()
    )

    if (bccList && bccList.length > 0) {
      mailOptions.bcc = bccList.join(',')
    }
  }
  // --- END DEFINITIVE FIX ---

  const result = await sendEmail(mailOptions, emailType)
  return result.success || false
}

```

## 📄 src/next.js
*Lines: 20, Size: 378 Bytes*

```javascript
import 'server-only'

// Explicitly re-export all functions from the core barrel file.
export {
  apiCallTracker,
  auditLogger,
  initializeAuditLogger,
  safeExecute,
  smartStripHtml,
  logger,
  initializeLogger,
  reinitializeLogger,
  sendGenericEmail,
  configurePusher,
  triggerRealtimeEvent,
  getRedisClient,
  testRedisConnection,
  tokenTracker,
} from './core.js'

```

## 📄 src/node.js
*Lines: 3, Size: 76 Bytes*

```javascript
// This is the default, Node.js-safe entry point.
export * from './core.js'

```

## 📄 src/pusher.js
*Lines: 37, Size: 1.13 KB*

```javascript
import Pusher from 'pusher'
import { logger } from './logger.js'
import { env } from '@headlines/config'
let pusher
let isRealtimeConfigured = false
export function configurePusher() {
  if (isRealtimeConfigured) return
  const { PUSHER_APP_ID, PUSHER_KEY, PUSHER_SECRET, PUSHER_CLUSTER } = env
  if (PUSHER_APP_ID && PUSHER_KEY && PUSHER_SECRET && PUSHER_CLUSTER) {
    pusher = new Pusher({
      appId: PUSHER_APP_ID,
      key: PUSHER_KEY,
      secret: PUSHER_SECRET,
      cluster: PUSHER_CLUSTER,
      useTLS: true,
    })
    isRealtimeConfigured = true
    logger.info('✅ Real-time notification service (Pusher) configured.')
  } else {
    logger.warn(
      'Pusher credentials not fully configured. Real-time updates will be disabled.'
    )
  }
}
export async function triggerRealtimeEvent(channel, event, data) {
  if (!isRealtimeConfigured || !pusher) return
  try {
    logger.info(`📢 Streaming new item on channel '${channel}' with event '${event}'.`)
    await pusher.trigger(channel, event, data)
  } catch (error) {
    logger.error(
      { err: error, channel, event },
      'Failed to trigger Pusher real-time event.'
    )
  }
}

```

## 📄 src/redisClient.js
*Lines: 66, Size: 1.88 KB*

```javascript
// packages/utils-server/src/redisClient.js
import { logger } from './logger.js'
import { Redis } from '@upstash/redis'

let redisClient
let connectionState = 'idle'

export async function getRedisClient(env) {
  if (connectionState === 'ready' && redisClient) {
    return redisClient
  }
  if (connectionState === 'failed' || connectionState === 'connecting') {
    return null
  }
  if (connectionState === 'idle') {
    if (!env || !env.UPSTASH_REDIS_REST_URL || !env.UPSTASH_REDIS_REST_TOKEN) {
      logger.warn(
        'UPSTASH_REDIS_REST_URL and/or TOKEN not found in provided env. Caching will be disabled.'
      )
      connectionState = 'failed'
      return null
    }
    try {
      connectionState = 'connecting'
      const client = new Redis({
        url: env.UPSTASH_REDIS_REST_URL,
        token: env.UPSTASH_REDIS_REST_TOKEN,
      })
      await client.ping()
      logger.info('✅ Upstash Redis client connected successfully.')
      connectionState = 'ready'
      redisClient = client
      return client
    } catch (err) {
      logger.error({ err: err.message }, 'Upstash Redis connection failed.')
      connectionState = 'failed'
      return null
    }
  }
}

export async function testRedisConnection(env) {
  if (!env || !env.UPSTASH_REDIS_REST_URL) {
    logger.warn('Redis is not configured. Caching will be disabled.')
    return true
  }
  try {
    const client = await getRedisClient(env)
    if (client) {
      const testKey = `test:${Date.now()}`
      await client.set(testKey, 'test-value', { ex: 10 })
      const testValue = await client.get(testKey)
      await client.del(testKey)
      if (testValue === 'test-value') {
        logger.info('✅ Redis connection and read/write test successful.')
        return true
      }
      return false
    }
    return true
  } catch (err) {
    logger.warn({ err: err.message }, 'Redis pre-flight check failed.')
    return true
  }
}

```

## 📄 src/tokenTracker.js
*Lines: 46, Size: 1.35 KB*

```javascript
import { logger } from './logger.js'

const modelPricing = {
  'gpt-5-nano': { input: 0.15, output: 0.4 },
  'gpt-5-mini': { input: 0.5, output: 2.5 },
  'gpt-4o-mini': { input: 0.15, output: 0.6 },
}

class TokenTracker {
  constructor() {
    this.usage = {}
    this.reset()
  }
  initializeModels(modelKeys = []) {
    this.usage = {}
    const allKnownModels = new Set([...Object.keys(modelPricing), ...modelKeys])
    allKnownModels.forEach((model) => {
      this.usage[model] = { inputTokens: 0, outputTokens: 0, cost: 0 }
    })
  }
  reset() {
    this.initializeModels()
  }
  recordUsage(model, usageData) {
    if (!usageData || !model) return
    const { prompt_tokens, completion_tokens } = usageData
    if (!this.usage[model]) {
      logger.warn(`Token usage recorded for an un-priced model: ${model}.`)
      this.usage[model] = { inputTokens: 0, outputTokens: 0, cost: 0 }
    }
    this.usage[model].inputTokens += prompt_tokens || 0
    this.usage[model].outputTokens += completion_tokens || 0
    const pricing = modelPricing[model]
    if (pricing) {
      const inputCost = ((prompt_tokens || 0) / 1000000) * pricing.input
      const outputCost = ((completion_tokens || 0) / 1000000) * pricing.output
      this.usage[model].cost += inputCost + outputCost
    }
  }
  getStats() {
    return this.usage
  }
}

export const tokenTracker = new TokenTracker()

```
