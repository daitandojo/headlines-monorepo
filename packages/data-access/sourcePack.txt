# ðŸ“ PROJECT DIRECTORY STRUCTURE

Total: 25 files, 3 directories

```
headlines/
â”œâ”€â”€ ðŸ“ src/
â”‚   â”œâ”€â”€ ðŸ“ core/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ admin.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ aiSourceDiscovery.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ articles.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ auth.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ chat.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ dashboard.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ email.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ events.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ export.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ knowledge.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ opportunities.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ pipeline.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ relationships.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ settings.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ subscriber.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ upload.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ userSettings.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ verdicts.js
â”‚   â”‚   â””â”€â”€ ðŸ“„ watchlist.js
â”‚   â”œâ”€â”€ ðŸ“ seed/
â”‚   â”‚   â””â”€â”€ ðŸ“„ dev-user.js
â”‚   â”œâ”€â”€ ðŸ“„ dbConnect.js
â”‚   â”œâ”€â”€ ðŸ“„ index.js
â”‚   â”œâ”€â”€ ðŸ“„ queryBuilder.js
â”‚   â””â”€â”€ ðŸ“„ revalidate.js
â””â”€â”€ ðŸ“„ package.json
```

# ðŸ“‹ PROJECT METADATA

**Generated**: 2025-09-29T13:20:36.405Z
**Repository Path**: /home/mark/Repos/projects/headlines/packages/data-access
**Total Files**: 25
**Package**: @headlines/data-access@1.0.0
**Description**: Shared, server-only data access logic for the Headlines monorepo.



---


## ðŸ“„ package.json
*Lines: 23, Size: 627 Bytes*

```json
{
  "name": "@headlines/data-access",
  "version": "1.0.0",
  "description": "Shared, server-only data access logic for the Headlines monorepo.",
  "main": "src/index.js",
  "type": "module",
  "license": "ISC",
  "exports": {
    ".": "./src/index.js",
    "./dbConnect.js": "./src/dbConnect.js",
    "./seed/dev-user.js": "./src/seed/dev-user.js"
  },
  "dependencies": {
    "@headlines/ai-services": "workspace:*",
    "@headlines/config": "workspace:*",
    "@headlines/models": "workspace:*",
    "@pinecone-database/pinecone": "^6.1.2",
    "bcryptjs": "^3.0.2",
    "mongoose": "^8.18.1",
    "openai": "^5.22.0"
  }
}

```

## ðŸ“„ src/core/admin.js
*Lines: 232, Size: 6.72 KB*

```javascript
'use server'

import {
  Subscriber,
  Country,
  Source,
  WatchlistEntity,
  WatchlistSuggestion,
  SourceSuggestion,
} from '@headlines/models'
import { buildQuery } from '../queryBuilder.js'

export async function createSubscriber(userData) {
  try {
    await dbConnect();
    const newUser = new Subscriber(userData)
    await newUser.save()
    return { success: true, subscriber: JSON.parse(JSON.stringify(newUser)) }
  } catch (e) {
    if (e.code === 11000)
      return { success: false, error: 'A user with this email already exists.' }
    return { success: false, error: 'Failed to create subscriber.' }
  }
}

export async function updateSubscriber(userId, updateData) {
  try {
    await dbConnect();
    if (updateData.password === '') delete updateData.password
    const user = await Subscriber.findByIdAndUpdate(
      userId,
      { $set: updateData },
      { new: true, runValidators: true }
    ).lean()
    if (!user) return { success: false, error: 'User not found.' }
    return { success: true, subscriber: JSON.parse(JSON.stringify(user)) }
  } catch (e) {
    console.error('[updateSubscriber Error]', e)
    return { success: false, error: 'Failed to update subscriber.' }
  }
}

export async function deleteSubscriber(userId) {
  try {
    await dbConnect();
    const result = await Subscriber.findByIdAndDelete(userId)
    if (!result) return { success: false, error: 'User not found.' }
    return { success: true }
  } catch (e) {
    console.error('[deleteSubscriber Error]', e)
    return { success: false, error: 'Failed to delete subscriber.' }
  }
}

export async function createCountry(countryData) {
  try {
    await dbConnect();
    const newCountry = new Country(countryData)
    await newCountry.save()
    return { success: true, country: JSON.parse(JSON.stringify(newCountry)) }
  } catch (e) {
    if (e.code === 11000) return { success: false, error: 'Country already exists.' }
    return { success: false, error: 'Failed to create country.' }
  }
}

export async function updateCountry(countryId, updateData) {
  try {
    await dbConnect();
    const country = await Country.findByIdAndUpdate(
      countryId,
      { $set: updateData },
      { new: true }
    ).lean()
    if (!country) return { success: false, error: 'Country not found.' }
    return { success: true, country: JSON.parse(JSON.stringify(country)) }
  } catch (e) {
    return { success: false, error: 'Failed to update country.' }
  }
}

export async function createSource(sourceData) {
  try {
    await dbConnect();
    const newSource = new Source(sourceData)
    await newSource.save()
    return { success: true, source: JSON.parse(JSON.stringify(newSource)) }
  } catch (e) {
    if (e.code === 11000)
      return { success: false, error: 'A source with this name already exists.' }
    return { success: false, error: 'Failed to create source.' }
  }
}

export async function updateSource(sourceId, updateData) {
  try {
    await dbConnect();
    const updatedSource = await Source.findByIdAndUpdate(
      sourceId,
      { $set: updateData },
      { new: true }
    ).lean()
    if (!updatedSource) return { success: false, error: 'Source not found.' }
    return { success: true, source: JSON.parse(JSON.stringify(updatedSource)) }
  } catch (e) {
    return { success: false, error: 'Failed to update source.' }
  }
}

export const getAllCountries = async () => {
  try {
    await dbConnect();
    const countries = await Country.aggregate([
      { $match: {} },
      {
        $lookup: {
          from: 'synthesized_events',
          localField: 'name',
          foreignField: 'country',
          as: 'events',
        },
      },
      {
        $lookup: {
          from: 'sources',
          localField: 'name',
          foreignField: 'country',
          as: 'sources',
        },
      },
      {
        $project: {
          name: 1,
          isoCode: 1,
          status: 1,
          eventCount: { $size: '$events' },
          sourceCount: { $size: '$sources' },
          activeSourceCount: {
            $size: {
              $filter: {
                input: '$sources',
                as: 'source',
                cond: { $eq: ['$$source.status', 'active'] },
              },
            },
          },
        },
      },
    ])
    return { success: true, data: JSON.parse(JSON.stringify(countries)) }
  } catch (e) {
    return { success: false, error: 'Failed to fetch countries.' }
  }
}

export const getAllSubscribers = async ({
  page = 1,
  filters = {},
  sort = 'createdAt_desc',
}) => {
  try {
    await dbConnect();
    const { queryFilter, sortOptions } = await buildQuery(Subscriber, { filters, sort })
    const SUBSCRIBERS_PER_PAGE = 50
    const skipAmount = (page - 1) * SUBSCRIBERS_PER_PAGE
    const [subscribers, total] = await Promise.all([
      Subscriber.find(queryFilter)
        .sort(sortOptions)
        .skip(skipAmount)
        .limit(SUBSCRIBERS_PER_PAGE)
        .lean(),
      Subscriber.countDocuments(queryFilter),
    ])
    return { success: true, data: JSON.parse(JSON.stringify(subscribers)), total }
  } catch (e) {
    console.error('[getAllSubscribers Error]', e)
    return { success: false, error: 'Failed to fetch subscribers.' }
  }
}

export const getAllSources = async () => {
  try {
    await dbConnect();
    const sources = await Source.find({}).sort({ country: 1, name: 1 }).lean()
    return { success: true, data: JSON.parse(JSON.stringify(sources)) }
  } catch (e) {
    return { success: false, error: 'Failed to fetch sources.' }
  }
}

export const getAllWatchlistEntities = async ({
  page = 1,
  filters = {},
  sort = 'name_asc',
} = {}) => {
  try {
    const { queryFilter, sortOptions } = await buildQuery(WatchlistEntity, {
      filters,
      sort,
    })
    const ITEMS_PER_PAGE = 50 // A reasonable default
    const skipAmount = (page - 1) * ITEMS_PER_PAGE

    const [entities, total] = await Promise.all([
      WatchlistEntity.find(queryFilter)
        .sort(sortOptions)
        .skip(skipAmount)
        .limit(ITEMS_PER_PAGE)
        .lean(),
      WatchlistEntity.countDocuments(queryFilter),
    ])

    return { success: true, data: JSON.parse(JSON.stringify(entities)), total }
  } catch (e) {
    console.error('[getAllWatchlistEntities Error]', e)
    return { success: false, error: 'Failed to fetch watchlist entities.' }
  }
}

export const getSuggestions = async () => {
  try {
    await dbConnect();
    const [watchlistSuggestions, sourceSuggestions] = await Promise.all([
      WatchlistSuggestion.find({ status: 'candidate' }).sort({ createdAt: -1 }).lean(),
      SourceSuggestion.find({ status: 'pending' }).sort({ createdAt: -1 }).lean(),
    ])
    return { success: true, data: { watchlistSuggestions, sourceSuggestions } }
  } catch (e) {
    return { success: false, error: 'Failed to fetch suggestions.' }
  }
}

```

## ðŸ“„ src/core/aiSourceDiscovery.js
*Lines: 35, Size: 1.1 KB*

```javascript
// packages/data-access/src/actions/aiSourceDiscovery.js
import { testSourceConfig as scrapeUrl } from './scrape.js'
import { callLanguageModel } from '@headlines/ai-services'
import { instructionSourceDiscovery } from '@headlines/prompts'
// DEFINITIVE FIX: Import from the server-only entry point of the config package.
import { settings } from '@headlines/config'

const AI_AGENT_MODEL = settings.LLM_MODEL_UTILITY

export async function suggestSections(url) {
  const scrapeResult = {
    success: true,
    content: '<div>Mock Content</div>',
  }

  try {
    const data = await callLanguageModel({
      modelName: AI_AGENT_MODEL,
      systemPrompt: instructionSourceDiscovery,
      userContent: `Analyze the HTML from ${url}:\n\n${scrapeResult.content}`,
      isJson: true,
    })
    return { success: true, data: data.suggestions }
  } catch (e) {
    return { success: false, error: 'AI agent failed to suggest sections.' }
  }
}

export async function suggestSelector(url, targetType) {
  return {
    success: true,
    data: { selector: `div.${targetType}`, confidence: 0.9, sample: 'Sample Text' },
  }
}

```

## ðŸ“„ src/core/articles.js
*Lines: 71, Size: 2.14 KB*

```javascript
'use server'

import { Article } from '@headlines/models'
import { buildQuery } from '../queryBuilder.js'
import dbConnect from '../dbConnect.js' // Make sure this is imported
import mongoose from 'mongoose'

const ARTICLES_PER_PAGE = 50

export async function getArticles({
  page = 1,
  filters = {},
  sort = 'date_desc',
  userId = null,
}) {
  await dbConnect() // <-- ADD THIS BACK
  let { queryFilter, sortOptions } = await buildQuery(Article, {
    filters,
    sort,
    userId,
  })
  // ... rest of the function is the same
  const [articles, total] = await Promise.all([
    Article.find(queryFilter)
      .sort(sortOptions)
      .skip((page - 1) * ARTICLES_PER_PAGE)
      .limit(ARTICLES_PER_PAGE)
      .lean(),
    Article.countDocuments(queryFilter),
  ])
  // ...
  return { success: true, data: JSON.parse(JSON.stringify(articles)), total }
}

export async function getTotalArticleCount({ filters = {}, userId = null }) {
  await dbConnect() // <-- ADD THIS BACK
  const { queryFilter } = await buildQuery(Article, { filters, userId })
  const total = await Article.countDocuments(queryFilter)
  return { success: true, total }
}

export async function updateArticle(articleId, updateData) {
  await dbConnect() // <-- ADD THIS BACK
  const article = await Article.findByIdAndUpdate(
    articleId,
    { $set: updateData },
    { new: true }
  ).lean()
  if (!article) return { success: false, error: 'Article not found.' }
  return { success: true, data: JSON.parse(JSON.stringify(article)) }
}

export async function deleteArticle(articleId) {
  await dbConnect() // <-- ADD THIS BACK
  const result = await Article.findByIdAndDelete(articleId)
  if (!result) return { success: false, error: 'Article not found.' }
  return { success: true }
}

export async function getArticleDetails(articleId) {
  await dbConnect() // <-- ADD THIS BACK
  if (!mongoose.Types.ObjectId.isValid(articleId)) {
    return { success: false, error: 'Invalid ID format.' }
  }
  const article = await Article.findById(articleId).lean()
  if (!article) {
    return { success: false, error: 'Article not found.' }
  }
  return { success: true, data: JSON.parse(JSON.stringify(article)) }
}

```

## ðŸ“„ src/core/auth.js
*Lines: 36, Size: 1.04 KB*

```javascript
// File: packages/data-access/src/actions/auth.js (version 2.1 - Connection Centralized)
import { Subscriber } from '@headlines/models'
import bcrypt from 'bcryptjs'

export async function loginUser({ email, password }) {
  if (!email || !password) {
    return { success: false, error: 'Email and password are required.' }
  }

  try {
    await dbConnect();
    const user = await Subscriber.findOne({
      email: email.toLowerCase().trim(),
      isActive: true,
    })
      .select('+password')
      .lean()

    if (!user) {
      return { success: false, error: 'Invalid credentials or inactive account.' }
    }

    const isPasswordMatch = await bcrypt.compare(password, user.password)

    if (!isPasswordMatch) {
      return { success: false, error: 'Invalid credentials or inactive account.' }
    }

    const { password: _, ...userPayload } = user
    return { success: true, user: userPayload }
  } catch (error) {
    console.error('[loginUser Action Error]', error)
    return { success: false, error: 'An internal server error occurred.' }
  }
}

```

## ðŸ“„ src/core/chat.js
*Lines: 27, Size: 1.1 KB*

```javascript
// packages/data-access/src/actions/chat.js (version 2.0.0)
import { callLanguageModel } from '@headlines/ai-services'
import { settings } from '@headlines/config'

const TITLE_GENERATOR_MODEL = settings.LLM_MODEL_UTILITY

const TITLE_GENERATOR_PROMPT = `You are a title generation AI. Your task is to read a conversation and create a concise, 5-word-or-less title that accurately summarizes the main topic. Example Title: "Anders Holch Povlsen's Bestseller"`

export async function generateChatTitle(messages) {
  if (!messages || messages.length < 2) {
    return { success: false, error: 'Not enough messages to generate a title.' }
  }
  try {
    const conversationText = messages.map((m) => `${m.role}: ${m.content}`).join('\n')
    const title = await callLanguageModel({
      modelName: TITLE_GENERATOR_MODEL,
      systemPrompt: TITLE_GENERATOR_PROMPT,
      userContent: conversationText,
      isJson: false,
    })
    const cleanedTitle = title.trim().replace(/"/g, '')
    return { success: true, title: cleanedTitle }
  } catch (error) {
    return { success: false, error: 'Failed to generate title.' }
  }
}

```

## ðŸ“„ src/core/dashboard.js
*Lines: 105, Size: 2.77 KB*

```javascript
// File: packages/data-access/src/actions/dashboard.js
import {
  Source,
  Subscriber,
  WatchlistEntity,
  Article,
  SynthesizedEvent,
  Opportunity,
  Country,
} from '@headlines/models'
import dbConnect from '../dbConnect.js'

export async function getDashboardStats() {
  try {
    await dbConnect()
    const [
      sourceStats,
      userStats,
      watchlistStats,
      articleStats,
      eventStats,
      opportunityStats,
    ] = await Promise.all([
      Source.aggregate([
        {
          $group: {
            _id: null,
            total: { $sum: 1 },
            active: { $sum: { $cond: [{ $eq: ['$status', 'active'] }, 1, 0] } },
          },
        },
      ]),
      Subscriber.aggregate([
        {
          $group: {
            _id: null,
            total: { $sum: 1 },
            active: { $sum: { $cond: ['$isActive', 1, 0] } },
          },
        },
      ]),
      WatchlistEntity.aggregate([{ $group: { _id: null, total: { $sum: 1 } } }]),
      Article.aggregate([{ $group: { _id: null, total: { $sum: 1 } } }]),
      SynthesizedEvent.aggregate([{ $group: { _id: null, total: { $sum: 1 } } }]),
      Opportunity.aggregate([{ $group: { _id: null, total: { $sum: 1 } } }]),
    ])

    const stats = {
      sources: sourceStats[0] || { total: 0, active: 0 },
      users: userStats[0] || { total: 0, active: 0 },
      watchlist: watchlistStats[0] || { total: 0 },
      articles: articleStats[0] || { total: 0 },
      events: eventStats[0] || { total: 0 },
      opportunities: opportunityStats[0] || { total: 0 },
    }

    delete stats.sources._id // Clean up aggregation artifact
    delete stats.users._id
    delete stats.watchlist._id
    delete stats.articles._id
    delete stats.events._id
    delete stats.opportunities._id

    return { success: true, data: stats }
  } catch (e) {
    return { success: false, error: 'Failed to fetch dashboard stats.' }
  }
}

// This is the missing function
export async function getGlobalCountries() {
  try {
    await dbConnect()
    const countries = await Country.aggregate([
      { $match: { status: 'active' } },
      {
        $lookup: {
          from: 'synthesized_events',
          localField: 'name',
          foreignField: 'country',
          as: 'events',
        },
      },
      {
        $project: {
          name: 1,
          isoCode: 1,
          count: { $size: '$events' },
        },
      },
      // --- ADD THIS STAGE TO FILTER OUT ZERO-COUNT COUNTRIES ---
      {
        $match: {
          count: { $gt: 0 },
        },
      },
      // ---------------------------------------------------------
      { $sort: { name: 1 } },
    ])
    return { success: true, data: JSON.parse(JSON.stringify(countries)) }
  } catch (e) {
    return { success: false, error: 'Failed to fetch global countries.' }
  }
}

```

## ðŸ“„ src/core/email.js
*Lines: 46, Size: 1.57 KB*

```javascript
// packages/data-access/src/actions/email.js (version 1.0)
import { SynthesizedEvent, Opportunity, Article } from '@headlines/models'
import dbConnect from '../dbConnect.js'
// This import will need a proper mailer service setup, for now we mock it.
// import { sendSingleItemEmail } from '@/lib/mailer';

async function sendItemByEmail(itemId, itemType) {
  try {
    await dbConnect()

    let item
    const modelMap = {
      event: SynthesizedEvent,
      opportunity: Opportunity,
      article: Article,
    }

    const Model = modelMap[itemType]
    if (!Model) return { success: false, error: 'Invalid item type.' }

    item = await Model.findById(itemId).lean()
    if (!item) return { success: false, error: 'Item not found.' }

    // In a real implementation, you would format this into a nice HTML email.
    const emailContent = `
            <h1>Item Reminder</h1>
            <p><strong>Type:</strong> ${itemType}</p>
            <p><strong>ID:</strong> ${itemId}</p>
            <pre>${JSON.stringify(item, null, 2)}</pre>
        `

    console.log(`--- SIMULATING EMAIL ---`)
    console.log(`TO: User ${userId}`)
    console.log(`SUBJECT: Your Requested Item: ${item.headline || item.reachOutTo}`)
    console.log(emailContent)
    // await sendSingleItemEmail(userId, `Your Requested Item: ${item.headline || item.reachOutTo}`, emailContent);

    return { success: true, message: 'Item has been sent to your email.' }
  } catch (e) {
    console.error('[sendItemByEmail Error]:', e)
    return { success: false, error: 'Failed to send item by email.' }
  }
}

export { sendItemByEmail }

```

## ðŸ“„ src/core/events.js
*Lines: 75, Size: 2.41 KB*

```javascript
'use server'

import dbConnect from '../dbConnect.js'
import { SynthesizedEvent, Article, Opportunity } from '@headlines/models'
import { buildQuery } from '../queryBuilder.js'
import mongoose from 'mongoose'

const EVENTS_PER_PAGE = 50

export async function getEvents({
  page = 1,
  filters = {},
  sort = 'createdAt_desc',
  userId = null,
}) {
  await dbConnect() // <-- ADD THIS LINE
  const { queryFilter, sortOptions } = await buildQuery(SynthesizedEvent, {
    filters,
    sort,
    userId,
  })
  const skipAmount = (page - 1) * EVENTS_PER_PAGE

  const [events, total] = await Promise.all([
    SynthesizedEvent.find(queryFilter)
      .select('-synthesized_summary')
      .sort(sortOptions)
      .skip(skipAmount)
      .limit(EVENTS_PER_PAGE)
      .lean(),
    SynthesizedEvent.countDocuments(queryFilter),
  ])
  return { success: true, data: JSON.parse(JSON.stringify(events)), total }
}

export async function getEventDetails(eventId) {
  await dbConnect() // <-- ADD THIS LINE
  if (!mongoose.Types.ObjectId.isValid(eventId))
    return { success: false, error: 'Invalid event ID' }
  const event = await SynthesizedEvent.findById(eventId)
    .populate({ path: 'relatedOpportunities', model: Opportunity, select: 'reachOutTo' })
    .lean()
  if (!event) return { success: false, error: 'Event not found' }
  return { success: true, data: JSON.parse(JSON.stringify(event)) }
}

export async function updateEvent(eventId, updateData) {
  await dbConnect() // <-- ADD THIS LINE
  if (!mongoose.Types.ObjectId.isValid(eventId))
    return { success: false, error: 'Invalid event ID' }
  const event = await SynthesizedEvent.findByIdAndUpdate(
    eventId,
    { $set: updateData },
    { new: true, runValidators: true }
  ).lean()
  if (!event) return { success: false, error: 'Event not found.' }
  return { success: true, data: JSON.parse(JSON.stringify(event)) }
}

export async function deleteEvent(eventId) {
  await dbConnect() // <-- ADD THIS LINE
  if (!mongoose.Types.ObjectId.isValid(eventId))
    return { success: false, error: 'Invalid event ID' }
  const result = await SynthesizedEvent.findByIdAndDelete(eventId)
  if (!result) return { success: false, error: 'Event not found.' }
  await Promise.all([
    Opportunity.updateMany({ events: eventId }, { $pull: { events: eventId } }),
    Article.updateMany(
      { synthesizedEventId: eventId },
      { $unset: { synthesizedEventId: '' } }
    ),
  ])
  return { success: true }
}

```

## ðŸ“„ src/core/export.js
*Lines: 262, Size: 8.07 KB*

```javascript
// packages/data-access/src/actions/export.js
import { Opportunity, Subscriber, SynthesizedEvent, Article } from '@headlines/models'
import { buildQuery } from '../queryBuilder.js'
import dbConnect from '../dbConnect.js'

// --- Helper Functions ---

function escapeXml(str) {
  if (str === null || str === undefined) return ''
  return String(str).replace(/[<>&'"]/g, (c) => {
    switch (c) {
      case '<':
        return '&lt;'
      case '>':
        return '&gt;'
      case '&':
        return '&amp;'
      case "'":
        return '&apos;'
      case '"':
        return '&quot;'
    }
  })
}

function convertToCSV(data, columns) {
  if (!data || data.length === 0) return ''
  const headers = columns.map((c) => c.header)
  const csvRows = [headers.join(',')]
  for (const row of data) {
    const values = headers.map((header) => {
      const column = columns.find((c) => c.header === header)
      let value = column ? row[column.key] : ''
      if (column && column.key.includes('.')) {
        value = column.key.split('.').reduce((o, i) => (o ? o[i] : ''), row)
      }
      if (value === null || value === undefined) value = ''
      if (Array.isArray(value)) value = value.join('; ')
      const stringValue = String(value)
      const escaped = stringValue.replace(/"/g, '""')
      if (escaped.includes(',')) return `"${escaped}"`
      return escaped
    })
    csvRows.push(values.join(','))
  }
  return csvRows.join('\n')
}

function convertToExcelXML(data, columns) {
  let xml = `<?xml version="1.0"?>
    <?mso-application progid="Excel.Sheet"?>
    <Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"
     xmlns:o="urn:schemas-microsoft-com:office:office"
     xmlns:x="urn:schemas-microsoft-com:office:excel"
     xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet"
     xmlns:html="http://www.w3.org/TR/REC-html40">
     <Worksheet ss:Name="Export">
      <Table>`

  xml += '<Row>'
  columns.forEach((col) => {
    xml += `<Cell ss:StyleID="s1"><Data ss:Type="String">${escapeXml(col.header)}</Data></Cell>`
  })
  xml += '</Row>'

  data.forEach((row) => {
    xml += '<Row>'
    columns.forEach((col) => {
      let value = col.key.split('.').reduce((o, i) => (o ? o[i] : ''), row)
      if (value === null || value === undefined) value = ''
      if (Array.isArray(value)) value = value.join('; ')

      let type = typeof value === 'number' ? 'Number' : 'String'
      if (value instanceof Date) {
        type = 'DateTime'
        value = value.toISOString()
      }

      xml += `<Cell><Data ss:Type="${type}">${escapeXml(value)}</Data></Cell>`
    })
    xml += '</Row>'
  })

  xml += `</Table><Styles><Style ss:ID="s1"><Font ss:Bold="1"/></Style></Styles></Worksheet></Workbook>`
  return xml
}

// --- Generic Exporter ---
async function genericExporter({ model, columns, filters, sort, fileType }) {
  try {
    await dbConnect()
    const { queryFilter, sortOptions } = await buildQuery(model, {
      filters,
      sort,
      baseQuery: {},
    })
    const dataToExport = await model.find(queryFilter).sort(sortOptions).lean()

    if (fileType === 'csv') {
      const csv = convertToCSV(dataToExport, columns)
      return { success: true, data: csv, contentType: 'text/csv' }
    } else if (fileType === 'xlsx') {
      const xml = convertToExcelXML(dataToExport, columns)
      return { success: true, data: xml, contentType: 'application/vnd.ms-excel' }
    }
    return { success: false, error: 'Invalid file type.' }
  } catch (e) {
    return { success: false, error: `Failed to generate export: ${e.message}` }
  }
}

// --- Specific Implementations ---

export const exportOpportunitiesToCSV = async (params) =>
  genericExporter({
    ...params,
    model: Opportunity,
    columns: [
      { header: 'Country', key: 'basedIn' },
      { header: 'City', key: 'city' },
      { header: 'Contact', key: 'reachOutTo' },
      { header: 'Wealth ($M)', key: 'likelyMMDollarWealth' },
      { header: 'Email', key: 'contactDetails.email' },
      { header: 'Reason', key: 'whyContact' },
      { header: 'Created', key: 'createdAt' },
    ],
    fileType: 'csv',
  })

export const exportOpportunitiesToXLSX = async (params) =>
  genericExporter({
    ...params,
    model: Opportunity,
    columns: [
      { header: 'Country', key: 'basedIn' },
      { header: 'City', key: 'city' },
      { header: 'Contact', key: 'reachOutTo' },
      { header: 'Wealth ($M)', key: 'likelyMMDollarWealth' },
      { header: 'Email', key: 'contactDetails.email' },
      { header: 'Reason', key: 'whyContact' },
      { header: 'Created', key: 'createdAt' },
    ],
    fileType: 'xlsx',
  })

export const exportUsersToCSV = async (params) =>
  genericExporter({
    ...params,
    model: Subscriber,
    columns: [
      { header: 'Email', key: 'email' },
      { header: 'FirstName', key: 'firstName' },
      { header: 'LastName', key: 'lastName' },
      { header: 'IsActive', key: 'isActive' },
      { header: 'Role', key: 'role' },
      { header: 'Tier', key: 'subscriptionTier' },
      { header: 'Created', key: 'createdAt' },
    ],
    fileType: 'csv',
  })

export const exportUsersToXLSX = async (params) =>
  genericExporter({
    ...params,
    model: Subscriber,
    columns: [
      { header: 'Email', key: 'email' },
      { header: 'FirstName', key: 'firstName' },
      { header: 'LastName', key: 'lastName' },
      { header: 'IsActive', key: 'isActive' },
      { header: 'Role', key: 'role' },
      { header: 'Tier', key: 'subscriptionTier' },
      { header: 'Created', key: 'createdAt' },
    ],
    fileType: 'xlsx',
  })

export const exportEventsToCSV = async (params) =>
  genericExporter({
    ...params,
    model: SynthesizedEvent,
    columns: [
      { header: 'Headline', key: 'synthesized_headline' },
      { header: 'Summary', key: 'synthesized_summary' },
      { header: 'Score', key: 'highest_relevance_score' },
      { header: 'Country', key: 'country' },
      { header: 'Created', key: 'createdAt' },
    ],
    fileType: 'csv',
  })

export const exportEventsToXLSX = async (params) =>
  genericExporter({
    ...params,
    model: SynthesizedEvent,
    columns: [
      { header: 'Headline', key: 'synthesized_headline' },
      { header: 'Summary', key: 'synthesized_summary' },
      { header: 'Score', key: 'highest_relevance_score' },
      { header: 'Country', key: 'country' },
      { header: 'Created', key: 'createdAt' },
    ],
    fileType: 'xlsx',
  })

export const exportArticlesToCSV = async (params) =>
  genericExporter({
    ...params,
    model: Article,
    columns: [
      { header: 'Headline', key: 'headline' },
      { header: 'Newspaper', key: 'newspaper' },
      { header: 'Country', key: 'country' },
      { header: 'Headline Score', key: 'relevance_headline' },
      { header: 'Article Score', key: 'relevance_article' },
      { header: 'Link', key: 'link' },
      { header: 'Created', key: 'createdAt' },
    ],
    fileType: 'csv',
  })

export const exportArticlesToXLSX = async (params) =>
  genericExporter({
    ...params,
    model: Article,
    columns: [
      { header: 'Headline', key: 'headline' },
      { header: 'Newspaper', key: 'newspaper' },
      { header: 'Country', key: 'country' },
      { header: 'Headline Score', key: 'relevance_headline' },
      { header: 'Article Score', key: 'relevance_article' },
      { header: 'Link', key: 'link' },
      { header: 'Created', key: 'createdAt' },
    ],
    fileType: 'xlsx',
  })

// --- Generic Exporter ---
export async function generateExport({ model, columns, filters, sort, fileType }) {
  await dbConnect()
  const { queryFilter, sortOptions } = await buildQuery(model, {
    filters,
    sort,
    baseQuery: {},
  })
  const dataToExport = await model.find(queryFilter).sort(sortOptions).lean()

  if (fileType === 'csv') {
    const csv = convertToCSV(dataToExport, columns)
    return { success: true, data: csv, contentType: 'text/csv', extension: 'csv' }
  } else if (fileType === 'xlsx') {
    const xml = convertToExcelXML(dataToExport, columns)
    return {
      success: true,
      data: xml,
      contentType: 'application/vnd.ms-excel',
      extension: 'xls',
    }
  }
  throw new Error('Invalid file type specified for export.')
}

```

## ðŸ“„ src/core/knowledge.js
*Lines: 81, Size: 2.63 KB*

```javascript
// src/actions/knowledge.js (Corrected)
import { Pinecone } from '@pinecone-database/pinecone'
import mongoose from 'mongoose'
import dbConnect from '../dbConnect.js'
import { Article } from '@headlines/models'
import { generateEmbedding } from '@headlines/ai-services'
import { env } from '@headlines/config'

let pineconeIndex
function getPineconeIndex() {
  if (!pineconeIndex) {
    const pc = new Pinecone({ apiKey: env.PINECONE_API_KEY })
    pineconeIndex = pc.index(env.PINECONE_INDEX_NAME)
  }
  return pineconeIndex
}

export async function addKnowledge(data) {
  const { headline, business_summary, source, country, link } = data
  console.log(`[Add Knowledge] Attempting to add new knowledge: "${headline}"`)

  if (!headline || !business_summary || !source || !country || !link) {
    console.error('[Add Knowledge] Validation failed: Missing required fields.')
    return { success: false, message: 'All fields are required.' }
  }

  try {
    const index = getPineconeIndex()
    await dbConnect()
    console.log('[Add Knowledge] Database connected.')

    console.log('[Add Knowledge] Generating embedding...')
    const textToEmbed = `${headline}\n${business_summary}`
    const embedding = await generateEmbedding(textToEmbed)
    console.log('[Add Knowledge] Embedding generated successfully.')

    const newArticle = new Article({
      _id: new mongoose.Types.ObjectId(),
      headline,
      link,
      newspaper: source,
      source: 'Manual Upload',
      country,
      relevance_headline: 100,
      assessment_headline: 'Manually uploaded by user.',
      relevance_article: 100,
      assessment_article: business_summary,
      embedding: embedding,
      key_individuals: [],
    })
    console.log('[Add Knowledge] MongoDB document created.')

    await newArticle.save()
    console.log('[Add Knowledge] Saved to MongoDB.')

    const key_individual_names = (newArticle.key_individuals || []).map((p) => p.name)

    await index.upsert([
      {
        id: newArticle._id.toString(),
        values: embedding,
        metadata: {
          headline: newArticle.headline,
          summary: newArticle.assessment_article,
          newspaper: newArticle.newspaper,
          country: newArticle.country,
          key_individuals: key_individual_names,
        },
      },
    ])
    console.log('[Add Knowledge] Upserted to Pinecone.')

    console.log('[Add Knowledge] Revalidation responsibility moved to API routes.')

    return { success: true, message: 'Knowledge successfully added and embedded.' }
  } catch (error) {
    console.error('[Add Knowledge Error]', error)
    return { success: false, message: 'Failed to add knowledge.' }
  }
}

```

## ðŸ“„ src/core/opportunities.js
*Lines: 86, Size: 2.89 KB*

```javascript
// File: packages/data-access/src/actions/opportunities.js (Corrected Sorting)

import dbConnect from '../dbConnect.js'
import { Opportunity } from '@headlines/models'
import { buildQuery } from '../queryBuilder.js'
import mongoose from 'mongoose'

const OPPORTUNITIES_PER_PAGE = 50

export async function getTotalOpportunitiesCount({ filters = {}, userId = null }) {
  await dbConnect()
  const { queryFilter } = await buildQuery(Opportunity, { filters, userId })
  const total = await Opportunity.countDocuments(queryFilter)
  return { success: true, total }
}

export async function getOpportunities({
  page = 1,
  filters = {},
  sort = 'date_desc',
  userId = null,
}) {
  await dbConnect()
  let { queryFilter, sortOptions } = await buildQuery(Opportunity, {
    filters,
    sort,
    userId,
  })

  // --- START: OPPORTUNITY-SPECIFIC SORTING FIX ---
  // If we are sorting by size, we MUST exclude documents where the
  // wealth is null, undefined, or 0, as they would otherwise sort first.
  if (sort === 'size_desc') {
    if (queryFilter.$and) {
      queryFilter.$and.push({ likelyMMDollarWealth: { $gt: 0 } })
    } else if (Object.keys(queryFilter).length > 0) {
      queryFilter = { $and: [queryFilter, { likelyMMDollarWealth: { $gt: 0 } }] }
    } else {
      queryFilter = { likelyMMDollarWealth: { $gt: 0 } }
    }
  }
  // --- END: OPPORTUNITY-SPECIFIC SORTING FIX ---

  const skipAmount = (page - 1) * OPPORTUNITIES_PER_PAGE
  const [opportunities, total] = await Promise.all([
    Opportunity.find(queryFilter)
      .populate({ path: 'events', select: 'synthesized_headline', options: { limit: 1 } })
      .sort(sortOptions)
      .skip(skipAmount)
      .limit(OPPORTUNITIES_PER_PAGE)
      .lean(),
    Opportunity.countDocuments(queryFilter),
  ])
  return { success: true, data: JSON.parse(JSON.stringify(opportunities)), total }
}

export async function getOpportunityDetails(opportunityId) {
  if (!mongoose.Types.ObjectId.isValid(opportunityId)) {
    return { success: false, error: 'Invalid ID format.' }
  }
  await dbConnect()
  const opportunity = await Opportunity.findById(opportunityId)
    .populate({ path: 'events', options: { sort: { createdAt: -1 } } })
    .lean()
  if (!opportunity) return { success: false, error: 'Opportunity not found.' }
  return { success: true, data: JSON.parse(JSON.stringify(opportunity)) }
}

export async function updateOpportunity(oppId, updateData) {
  await dbConnect()
  const opp = await Opportunity.findByIdAndUpdate(
    oppId,
    { $set: updateData },
    { new: true, runValidators: true }
  ).lean()
  if (!opp) return { success: false, error: 'Opportunity not found.' }
  return { success: true, data: JSON.parse(JSON.stringify(opp)) }
}

export async function deleteOpportunity(oppId) {
  await dbConnect()
  const result = await Opportunity.findByIdAndDelete(oppId)
  if (!result) return { success: false, error: 'Opportunity not found.' }
  return { success: true }
}

```

## ðŸ“„ src/core/pipeline.js
*Lines: 116, Size: 3.37 KB*

```javascript
// packages/data-access/src/actions/pipeline.js (version 1.0.0)
import {
  Source,
  Article,
  SynthesizedEvent,
  Opportunity,
  WatchlistEntity,
  WatchlistSuggestion,
} from '@headlines/models'
import dbConnect from '../dbConnect.js'

// --- Source Analytics & Status ---
export async function updateSourceAnalyticsBatch(bulkOps) {
  if (!bulkOps || bulkOps.length === 0) return { success: true, modifiedCount: 0 }
  try {
    await dbConnect()
    const result = await Source.bulkWrite(bulkOps)
    return { success: true, modifiedCount: result.modifiedCount }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function findSourcesForScraping(queryCriteria) {
  try {
    await dbConnect()
    const sources = await Source.find(queryCriteria).lean()
    return { success: true, data: JSON.parse(JSON.stringify(sources)) }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

// --- Housekeeping ---
export async function performHousekeeping(deletionCriteria) {
  try {
    await dbConnect()
    const result = await Article.deleteMany(deletionCriteria)
    return { success: true, deletedCount: result.deletedCount }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

// --- Data Commits ---
export async function bulkWriteEvents(eventOps) {
  if (!eventOps || eventOps.length === 0)
    return { success: true, upsertedCount: 0, modifiedCount: 0 }
  try {
    await dbConnect()
    const result = await SynthesizedEvent.bulkWrite(eventOps, { ordered: false })
    return {
      success: true,
      upsertedCount: result.upsertedCount,
      modifiedCount: result.modifiedCount,
    }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function bulkWriteArticles(articleOps) {
  if (!articleOps || articleOps.length === 0) return { success: true, result: null }
  try {
    await dbConnect()
    const result = await Article.bulkWrite(articleOps, { ordered: false })
    return { success: true, result }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function findEventsByKeys(eventKeys) {
  try {
    await dbConnect()
    const events = await SynthesizedEvent.find({ event_key: { $in: eventKeys } }).lean()
    return { success: true, data: JSON.parse(JSON.stringify(events)) }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function findArticlesByLinks(links) {
  try {
    await dbConnect()
    const articles = await Article.find({ link: { $in: links } })
      .select('link _id')
      .lean()
    return { success: true, data: JSON.parse(JSON.stringify(articles)) }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

// --- Watchlist Suggestions ---
export async function getActiveWatchlistEntityNames() {
  try {
    await dbConnect()
    const entities = await WatchlistEntity.find({}).select('name').lean()
    return { success: true, data: entities }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function bulkWriteWatchlistSuggestions(bulkOps) {
  if (!bulkOps || bulkOps.length === 0) return { success: true, result: null }
  try {
    await dbConnect()
    const result = await WatchlistSuggestion.bulkWrite(bulkOps)
    return { success: true, result }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

```

## ðŸ“„ src/core/relationships.js
*Lines: 52, Size: 1.74 KB*

```javascript
// packages/data-access/src/actions/relationships.js (version 2.0.0)
import { SynthesizedEvent, Opportunity } from '@headlines/models'
import dbConnect from '../dbConnect.js'
import { revalidatePath } from '../revalidate.js'
import mongoose from 'mongoose'

export async function linkOpportunityToEvent(eventId, opportunityId) {
  if (
    !mongoose.Types.ObjectId.isValid(eventId) ||
    !mongoose.Types.ObjectId.isValid(opportunityId)
  ) {
    return { success: false, error: 'Invalid ID format.' }
  }
  try {
    await dbConnect()
    await Promise.all([
      SynthesizedEvent.findByIdAndUpdate(eventId, {
        $addToSet: { relatedOpportunities: opportunityId },
      }),
      Opportunity.findByIdAndUpdate(opportunityId, { $addToSet: { events: eventId } }),
    ])
    await revalidatePath('/admin/events')
    await revalidatePath('/admin/opportunities')
    return { success: true, message: 'Relationship linked.' }
  } catch (e) {
    return { success: false, error: 'Database operation failed.' }
  }
}

export async function unlinkOpportunityFromEvent(eventId, opportunityId) {
  if (
    !mongoose.Types.ObjectId.isValid(eventId) ||
    !mongoose.Types.ObjectId.isValid(opportunityId)
  ) {
    return { success: false, error: 'Invalid ID format.' }
  }
  try {
    await dbConnect()
    await Promise.all([
      SynthesizedEvent.findByIdAndUpdate(eventId, {
        $pull: { relatedOpportunities: opportunityId },
      }),
      Opportunity.findByIdAndUpdate(opportunityId, { $pull: { events: eventId } }),
    ])
    await revalidatePath('/admin/events')
    await revalidatePath('/admin/opportunities')
    return { success: true, message: 'Relationship unlinked.' }
  } catch (e) {
    return { success: false, error: 'Database operation failed.' }
  }
}

```

## ðŸ“„ src/core/settings.js
*Lines: 39, Size: 1.22 KB*

```javascript
// packages/data-access/src/actions/settings.js (version 2.0.1)
import { Setting } from '@headlines/models'
import dbConnect from '../dbConnect.js'
import { revalidatePath } from '../revalidate.js'

export async function getSettings() {
  try {
    await dbConnect()
    const settings = await Setting.find({}).sort({ key: 1 }).lean()
    return { success: true, data: JSON.parse(JSON.stringify(settings)) }
  } catch (e) {
    return { success: false, error: 'Failed to fetch settings.' }
  }
}

export async function updateSettings(settingsData) {
  try {
    await dbConnect()
    const bulkOps = settingsData.map((setting) => {
      let castValue = setting.value
      if (setting.type === 'number') castValue = Number(setting.value)
      if (setting.type === 'boolean') castValue = Boolean(setting.value)
      return {
        updateOne: {
          filter: { _id: setting._id },
          update: { $set: { value: castValue } },
        },
      }
    })
    if (bulkOps.length > 0) {
      await Setting.bulkWrite(bulkOps)
    }
    await revalidatePath('/admin/settings')
    return { success: true, message: `${bulkOps.length} settings updated.` }
  } catch (e) {
    return { success: false, error: 'Failed to update settings.' }
  }
}

```

## ðŸ“„ src/core/subscriber.js
*Lines: 53, Size: 1.82 KB*

```javascript
// packages/data-access/src/actions/subscriber.js (Corrected)
import { Subscriber, PushSubscription } from '@headlines/models'
import dbConnect from '../dbConnect.js'

export async function getCurrentSubscriber(userId) {
  if (!userId) return { success: false, error: 'User ID is required' }
  try {
    await dbConnect()
    const user = await Subscriber.findById(userId).lean()
    if (!user) return { success: false, error: 'User not found' }
    return { success: true, data: JSON.parse(JSON.stringify(user)) }
  } catch (e) {
    return { success: false, error: 'Database error.' }
  }
}

export async function savePushSubscription(subscription, userId) {
  if (!userId) return { success: false, error: 'Authentication required' }
  if (!subscription || !subscription.endpoint)
    return { success: false, error: 'Invalid subscription object.' }
  try {
    await dbConnect()
    await PushSubscription.updateOne(
      { endpoint: subscription.endpoint },
      { $set: { ...subscription, subscriberId: userId } },
      { upsert: true }
    )
    return { success: true, message: 'Subscription saved.' }
  } catch (e) {
    return { success: false, error: 'Failed to save subscription.' }
  }
}

export async function updateUserProfile({ userId, updateData }) {
  if (!userId) return { success: false, error: 'User ID is required.' }
  if (!updateData) return { success: false, error: 'No update data provided.' }

  try {
    await dbConnect()
    const updatedUser = await Subscriber.findByIdAndUpdate(
      userId,
      { $set: updateData },
      { new: true }
    )
      .select('-password')
      .lean()
    if (!updatedUser) return { success: false, error: 'User not found.' }
    return { success: true, user: JSON.parse(JSON.stringify(updatedUser)) }
  } catch (error) {
    return { success: false, error: 'Failed to update profile.' }
  }
}

```

## ðŸ“„ src/core/upload.js
*Lines: 55, Size: 1.66 KB*

```javascript
// packages/data-access/src/actions/upload.js (version 2.0.0)
import { revalidatePath } from '../revalidate.js'
import { SynthesizedEvent, Opportunity } from '@headlines/models'

export async function processUploadedArticle(item, userId) {
  if (!userId) {
    return { success: false, error: 'Authentication required' }
  }

  try {
    const enrichedArticle = {
      ...item,
      relevance_article: 100,
      assessment_article: item.article,
      articleContent: { contents: [item.article] },
      newspaper: 'Manual Upload',
      country: 'Denmark',
      key_individuals: [],
    }

    const synthesizedResult = await synthesizeEvent([enrichedArticle], [], '', '')
    if (!synthesizedResult || !synthesizedResult.headline) {
      throw new Error('AI failed to synthesize an event from the provided text.')
    }

    const eventToSave = new SynthesizedEvent({
      ...synthesizedResult,
      event_key: `manual-${new Date().toISOString()}`,
      highest_relevance_score: 100,
      source_articles: [
        { headline: item.headline, link: '#manual', newspaper: 'Manual Upload' },
      ],
    })

    const opportunitiesToSave = await generateOpportunitiesFromEvent(eventToSave, [
      enrichedArticle,
    ])

    await eventToSave.save()
    if (opportunitiesToSave.length > 0) {
      await Opportunity.insertMany(
        opportunitiesToSave.map((opp) => ({ ...opp, events: [eventToSave._id] }))
      )
    }

    await revalidatePath('/events')
    await revalidatePath('/opportunities')

    return { success: true, event: eventToSave.synthesized_headline }
  } catch (e) {
    console.error('[Upload Action Error]:', e)
    return { success: false, error: e.message }
  }
}

```

## ðŸ“„ src/core/userSettings.js
*Lines: 25, Size: 745 Bytes*

```javascript
// packages/data-access/src/actions/userSettings.js (Corrected)
import { Subscriber } from '@headlines/models'
import dbConnect from '../dbConnect.js'

export async function clearDiscardedItems(userId) {
  if (!userId) {
    return { success: false, error: 'User ID is required.' }
  }
  try {
    await dbConnect()
    await Subscriber.findByIdAndUpdate(userId, {
      $set: {
        'discardedItems.articles': [],
        'discardedItems.events': [],
        'discardedItems.opportunities': [],
      },
    })

    return { success: true, message: 'Your discarded items have been cleared.' }
  } catch (e) {
    console.error('[clearDiscardedItems Error]:', e)
    return { success: false, error: 'Failed to clear discarded items.' }
  }
}

```

## ðŸ“„ src/core/verdicts.js
*Lines: 38, Size: 1.4 KB*

```javascript
// packages/data-access/src/actions/verdicts.js (version 1.1.0)
import { RunVerdict, SynthesizedEvent, Opportunity } from '@headlines/models'
import dbConnect from '../dbConnect.js'

export async function getRecentRunVerdicts() {
  try {
    await dbConnect()
    // MODIFICATION: Select the entire 'runStats' object instead of individual fields.
    // This provides the detailed data needed for the new dashboard view, including
    // relevantHeadlines and enrichmentOutcomes for funnel analysis.
    const verdicts = await RunVerdict.find({})
      .sort({ createdAt: -1 })
      .limit(5)
      .select('runStats createdAt')
      .lean()
    return { success: true, data: JSON.parse(JSON.stringify(verdicts)) }
  } catch (e) {
    return { success: false, error: 'Failed to fetch run verdicts.' }
  }
}

export async function getRunVerdictById(runId) {
  const { isAdmin, error } = await verifyAdmin()
  if (!isAdmin) return { success: false, error }

  try {
    await dbConnect()
    const verdict = await RunVerdict.findById(runId)
      .populate({ path: 'generatedEvents', model: SynthesizedEvent })
      .populate({ path: 'generatedOpportunities', model: Opportunity })
      .lean()
    if (!verdict) return { success: false, error: 'Verdict not found.' }
    return { success: true, data: JSON.parse(JSON.stringify(verdict)) }
  } catch (e) {
    return { success: false, error: 'Failed to fetch verdict details.' }
  }
}

```

## ðŸ“„ src/core/watchlist.js
*Lines: 113, Size: 3.69 KB*

```javascript
// packages/data-access/src/actions/watchlist.js (Corrected)
import { WatchlistEntity, Article, WatchlistSuggestion } from '@headlines/models'
import dbConnect from '../dbConnect.js'

export async function createWatchlistEntity(entityData) {
  try {
    await dbConnect()
    const newEntity = new WatchlistEntity(entityData)
    await newEntity.save()
    return { success: true, entity: JSON.parse(JSON.stringify(newEntity)) }
  } catch (e) {
    if (e.code === 11000)
      return { success: false, error: 'An entity with this name already exists.' }
    return { success: false, error: 'Failed to create entity.' }
  }
}

export async function updateWatchlistEntity(entityId, updateData) {
  try {
    await dbConnect()
    if (updateData.searchTerms && Array.isArray(updateData.searchTerms)) {
      updateData.searchTerms = [
        ...new Set(
          updateData.searchTerms.map((t) => t.toLowerCase().trim()).filter(Boolean)
        ),
      ]
      const entity = await WatchlistEntity.findById(entityId).select('name').lean()
      const allTerms = [entity.name, ...updateData.searchTerms]
        .map((t) => t.toLowerCase().trim())
        .filter(Boolean)
      const uniqueTerms = [...new Set(allTerms)]
      if (uniqueTerms.length > 0) {
        const termRegexes = uniqueTerms.map(
          (term) =>
            new RegExp(`\\b${term.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\b`, 'i')
        )
        updateData.hitCount = await Article.countDocuments({
          headline: { $in: termRegexes },
        })
      } else {
        updateData.hitCount = 0
      }
    }
    const entity = await WatchlistEntity.findByIdAndUpdate(
      entityId,
      { $set: updateData },
      { new: true }
    ).lean()
    if (!entity) return { success: false, error: 'Entity not found.' }
    return { success: true, entity: JSON.parse(JSON.stringify(entity)) }
  } catch (e) {
    return { success: false, error: 'Failed to update entity.' }
  }
}

export async function deleteWatchlistEntity(entityId) {
  try {
    await dbConnect()
    const result = await WatchlistEntity.findByIdAndDelete(entityId)
    if (!result) return { success: false, error: 'Entity not found.' }
    return { success: true }
  } catch (e) {
    return { success: false, error: 'Failed to delete entity.' }
  }
}

export async function updateWatchlistSuggestion(suggestionId, updateData) {
  try {
    await dbConnect()
    const suggestion = await WatchlistSuggestion.findByIdAndUpdate(
      suggestionId,
      { $set: updateData },
      { new: true }
    ).lean()
    if (!suggestion) return { success: false, error: 'Suggestion not found.' }
    return { success: true, data: JSON.parse(JSON.stringify(suggestion)) }
  } catch (e) {
    return { success: false, error: 'Failed to update suggestion.' }
  }
}

export async function processWatchlistSuggestion({ suggestionId, action }) {
  try {
    await dbConnect()
    const suggestion = await WatchlistSuggestion.findById(suggestionId)
    if (!suggestion) return { success: false, error: 'Suggestion not found.' }
    suggestion.status = action
    await suggestion.save()
    if (action === 'approved') {
      await WatchlistEntity.updateOne(
        { name: suggestion.name },
        {
          $setOnInsert: {
            name: suggestion.name,
            type: suggestion.type,
            country: suggestion.country,
            context: suggestion.rationale,
            searchTerms: suggestion.searchTerms,
            status: 'active',
          },
        },
        { upsert: true }
      )
    }
    return {
      success: true,
      message: `Watchlist suggestion for "${suggestion.name}" was ${action}.`,
    }
  } catch (e) {
    return { success: false, error: 'Failed to process suggestion.' }
  }
}

```

## ðŸ“„ src/dbConnect.js
*Lines: 38, Size: 1.26 KB*

```javascript
// File: packages/data-access/src/dbConnect.js (Final, Robust Version)
import mongoose from 'mongoose'
import { env } from '@headlines/config/next' // Use the Next.js entry point

const MONGO_URI = env.MONGO_URI

if (!MONGO_URI) {
  throw new Error('Please define the MONGO_URI environment variable inside .env.local')
}

/**
 * An idempotent function to connect to MongoDB.
 * It relies on Mongoose's built-in connection management to avoid creating multiple connections.
 * If a connection is already established or pending, Mongoose will reuse it.
 */
async function dbConnect() {
  // Check if we have a connection to the database
  // readyState 1 means connected.
  if (mongoose.connection.readyState >= 1) {
    return
  }

  // If no connection is active, create one. Mongoose handles pooling and prevents duplicates.
  // This will return a promise that resolves on successful connection.
  try {
    console.log('[dbConnect] No active connection. Attempting to connect...')
    await mongoose.connect(MONGO_URI, {
      bufferCommands: false, // Recommended for serverless environments
    })
    console.log('[dbConnect] MongoDB connection successful.')
  } catch (e) {
    console.error('[dbConnect] MongoDB connection failed:', e)
    throw e
  }
}

export default dbConnect

```

## ðŸ“„ src/index.js
*Lines: 25, Size: 815 Bytes*

```javascript
// This file is the default, Node.js-safe entry point.
// It should only contain re-exports from the /core directory.

export * from './core/admin.js'
export * from './core/articles.js'
export * from './core/auth.js'
export * from './core/chat.js'
export * from './core/dashboard.js'
export * from './core/email.js'
export * from './core/events.js'
export * from './core/export.js'
export * from './core/knowledge.js'
export * from './core/opportunities.js'
export * from './core/pipeline.js'
export * from './core/relationships.js'
export * from './core/settings.js'
export * from './core/subscriber.js'
export * from './core/upload.js'
export * from './core/userSettings.js'
export * from './core/verdicts.js'
export * from './core/watchlist.js'

export * from './queryBuilder.js'
export * from './revalidate.js'

```

## ðŸ“„ src/queryBuilder.js
*Lines: 98, Size: 2.96 KB*

```javascript
'use server'

import { Subscriber } from '@headlines/models'
import dbConnect from './dbConnect.js' // Import dbConnect

export async function buildQuery(
  model,
  { filters = {}, sort = 'date_desc', baseQuery = {}, userId = null }
) {
  await dbConnect()
  const andConditions = [{ ...baseQuery }]
  let user = null

  // --- START OF THE FIX ---
  // Only attempt to fetch the user if a valid userId is provided.
  if (userId) {
    user = await Subscriber.findById(userId)
      .select('discardedItems favoritedItems countries role')
      .lean()
  }
  // --- END OF THE FIX ---

  const countryField = model.schema.paths.basedIn ? 'basedIn' : 'country'

  // --- HIERARCHICAL FILTERING LOGIC ---
  if (user) {
    if (user.role === 'admin') {
      if (filters.country) {
        andConditions.push({ [countryField]: { $in: filters.country.split(',') } })
      }
    } else {
      const subscribedCountries = (user.countries || [])
        .filter((c) => c.active)
        .map((c) => c.name)
      if (subscribedCountries.length > 0) {
        andConditions.push({ [countryField]: { $in: subscribedCountries } })
      } else {
        andConditions.push({ [countryField]: { $in: [] } }) // See nothing
      }
    }

    if (user?.discardedItems) {
      const modelName = model.modelName.toLowerCase()
      const discardedIds = user.discardedItems[`${modelName}s`]
      if (discardedIds && discardedIds.length > 0) {
        andConditions.push({ _id: { $nin: discardedIds } })
      }
    }
  } else if (filters.country) {
    andConditions.push({ [countryField]: { $in: filters.country.split(',') } })
  }

  // --- Other Filters ---
  if (filters.q) {
    const searchRegex = { $regex: filters.q, $options: 'i' }
    const orConditions = [
      { headline: searchRegex },
      { synthesized_headline: searchRegex },
      { reachOutTo: searchRegex },
    ].filter((cond) => model.schema.paths[Object.keys(cond)[0]])

    if (orConditions.length > 0) andConditions.push({ $or: orConditions })
  }

  if (filters.category) andConditions.push({ eventClassification: filters.category })
  if (filters.withEmail)
    andConditions.push({ 'contactDetails.email': { $exists: true, $ne: null, $ne: '' } })

  if (user?.favoritedItems && filters.favoritesOnly) {
    const modelName = model.modelName.toLowerCase()
    const favoritedIds = user.favoritedItems[`${modelName}s`] || []
    andConditions.push({ _id: { $in: favoritedIds } })
  }

  const queryFilter =
    andConditions.length > 1 ? { $and: andConditions } : andConditions[0] || {}

  const sortOptions = {}
  if (sort) {
    let [key, direction] = sort.split('_')
    const sortKeyMap = {
      date: 'createdAt',
      relevance: 'highest_relevance_score',
      size: 'likelyMMDollarWealth',
    }
    key = sortKeyMap[key] || key
    if (key && direction) {
      sortOptions[key] = direction === 'desc' ? -1 : 1
    } else {
      sortOptions.createdAt = -1
    }
  } else {
    sortOptions.createdAt = -1
  }

  return { queryFilter, sortOptions }
}

```

## ðŸ“„ src/revalidate.js
*Lines: 24, Size: 929 Bytes*

```javascript
// packages/data-access/src/revalidate.js (version 2.0.0)
/**
 * An environment-aware revalidation function.
 * This function is now async to handle the dynamic import safely.
 * @param {string} path - The path to revalidate.
 * @param {('layout'|'page')} [type] - The type of revalidation.
 */
export async function revalidatePath(path, type) {
  // In the pipeline environment, this function is a no-op.
  if (process.env.IS_PIPELINE_RUN === 'true') {
    return
  }

  try {
    // This dynamic import will only succeed in a Next.js environment.
    // By placing it inside an async function, we avoid top-level await issues.
    const { revalidatePath: nextRevalidate } = await import('next/cache')
    return nextRevalidate(path, type)
  } catch (e) {
    // This catch block handles cases where it might be run in an unexpected env.
    console.log('[data-access] Failed to import next/cache. Revalidation skipped.')
  }
}

```

## ðŸ“„ src/seed/dev-user.js
*Lines: 59, Size: 1.91 KB*

```javascript
// packages/data-access/src/seed/dev-user.js (version 2.0.0 - Standalone Safe)
import { Subscriber } from '../../../models/src/index.js'
import dbConnect from '../dbConnect.js'
import mongoose from 'mongoose'
// We cannot use a logger here as this might be called before initialization
// import { logger } from '../../../utils/src/server.js';

const DEV_USER_ID = '662f831abb28052123530a43'
const DEV_USER_EMAIL = 'dev@headlines.dev'

export async function seedDevUser() {
  console.log(`[Seed] Seeding development user: ${DEV_USER_EMAIL}...`)
  try {
    await dbConnect()

    const devUser = {
      _id: new mongoose.Types.ObjectId(DEV_USER_ID),
      email: DEV_USER_EMAIL,
      password: 'devpassword', // This will be hashed by the pre-save hook
      firstName: 'Dev',
      lastName: 'User',
      role: 'admin',
      isActive: true,
      countries: [],
      subscriptionTier: 'enterprise',
      isLifetimeFree: true,
    }

    const result = await Subscriber.updateOne(
      { _id: devUser._id },
      { $set: devUser },
      { upsert: true }
    )

    if (result.upsertedCount > 0) {
      console.log(`[Seed] âœ… Successfully created development user.`)
    } else {
      console.log(`[Seed] âœ… Development user is already up-to-date.`)
    }
    return { success: true }
  } catch (error) {
    console.error('[Seed] âŒ Failed to seed development user:', error)
    // Close connection on error if it's open and this is a standalone script run
    if (mongoose.connection.readyState === 1 && import.meta.url.startsWith('file:')) {
        await mongoose.disconnect();
    }
    return { success: false, error: error.message }
  }
}

// Allow script to be run directly from the command line
if (import.meta.url.startsWith('file://') && process.argv[1] === import.meta.url.substring(7)) {
    seedDevUser().finally(() => {
        if (mongoose.connection.readyState === 1) {
            mongoose.disconnect();
        }
    });
}

```
