# ðŸ“ PROJECT DIRECTORY STRUCTURE

Total: 30 files, 3 directories

```
headlines/
â”œâ”€â”€ ðŸ“ src/
â”‚   â”œâ”€â”€ ðŸ“ core/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ admin.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ aiSourceDiscovery.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ articles.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ auth.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ chat.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ dashboard.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ email.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ events.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ export.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ index.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ knowledge.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ maintenance.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ opportunities.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ pipeline.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ relationships.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ settings.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ subscriber.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ upload.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ userSettings.js
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ verdicts.js
â”‚   â”‚   â””â”€â”€ ðŸ“„ watchlist.js
â”‚   â”œâ”€â”€ ðŸ“ seed/
â”‚   â”‚   â””â”€â”€ ðŸ“„ dev-user.js
â”‚   â”œâ”€â”€ ðŸ“„ dbConnect.js
â”‚   â”œâ”€â”€ ðŸ“„ dbConnect.next.js
â”‚   â”œâ”€â”€ ðŸ“„ dbConnectCore.js
â”‚   â”œâ”€â”€ ðŸ“„ index.js
â”‚   â”œâ”€â”€ ðŸ“„ next.js
â”‚   â”œâ”€â”€ ðŸ“„ queryBuilder.js
â”‚   â””â”€â”€ ðŸ“„ revalidate.js
â””â”€â”€ ðŸ“„ package.json
```

# ðŸ“‹ PROJECT METADATA

**Generated**: 2025-10-04T15:31:18.574Z
**Repository Path**: /home/mark/Repos/projects/headlines/packages/data-access
**Total Files**: 30
**Package**: @headlines/data-access@1.0.0
**Description**: Shared, server-only data access logic for the Headlines monorepo.



---


## ðŸ“„ package.json
*Lines: 28, Size: 816 Bytes*

```json
{
  "name": "@headlines/data-access",
  "version": "1.0.0",
  "description": "Shared, server-only data access logic for the Headlines monorepo.",
  "main": "src/index.js",
  "type": "module",
  "license": "ISC",
  "exports": {
    ".": "./src/index.js",
    "./node": "./src/index.js",
    "./next": "./src/next.js",
    "./dbConnect/next": "./src/dbConnect.next.js",
    "./dbConnect/node": "./src/dbConnect.js"
  },
  "dependencies": {
    "@xenova/transformers": "^2.17.2",
    "@headlines/utils-shared": "workspace:*",
    "@headlines/ai-services": "workspace:*",
    "@headlines/config": "workspace:*",
    "@headlines/prompts": "workspace:*",
    "@headlines/models": "workspace:*",
    "@pinecone-database/pinecone": "^2.2.2",
    "bcryptjs": "^2.4.3",
    "mongoose": "^8.4.1",
    "openai": "^4.29.2"
  }
}

```

## ðŸ“„ src/core/admin.js
*Lines: 245, Size: 7.36 KB*

```javascript
// packages/data-access/src/core/admin.js
import {
  Subscriber,
  Country,
  Source,
  WatchlistEntity,
  WatchlistSuggestion,
  SourceSuggestion,
} from '@headlines/models'
import { buildQuery } from '../queryBuilder.js'
// We can no longer import createSubscriberWithPassword as it's environment-specific
// import { createSubscriberWithPassword } from './auth.js'

export async function createSubscriber(userData) {
  // This function is now simplified. Password creation MUST be handled by
  // an environment-specific function that can perform hashing.
  if (userData.password) {
    return {
      success: false,
      error:
        'Password creation must be handled by a specific auth function, not the generic createSubscriber.',
    }
  }

  try {
    const newUser = new Subscriber(userData)
    await newUser.save()
    return { success: true, subscriber: JSON.parse(JSON.stringify(newUser)) }
  } catch (e) {
    if (e.code === 11000)
      return { success: false, error: 'A user with this email already exists.' }
    return { success: false, error: 'Failed to create subscriber.' }
  }
}

export async function updateSubscriber(userId, updateData) {
  try {
    if (updateData.password) {
      delete updateData.password
    }

    const user = await Subscriber.findByIdAndUpdate(
      userId,
      { $set: updateData },
      { new: true, runValidators: true }
    ).lean()
    if (!user) return { success: false, error: 'User not found.' }
    return { success: true, subscriber: JSON.parse(JSON.stringify(user)) }
  } catch (e) {
    console.error('[updateSubscriber Error]', e)
    return { success: false, error: 'Failed to update subscriber.' }
  }
}

export async function deleteSubscriber(userId) {
  try {
    const result = await Subscriber.findByIdAndDelete(userId)
    if (!result) return { success: false, error: 'User not found.' }
    return { success: true }
  } catch (e) {
    console.error('[deleteSubscriber Error]', e)
    return { success: false, error: 'Failed to delete subscriber.' }
  }
}

export async function createCountry(countryData) {
  try {
    const newCountry = new Country(countryData)
    await newCountry.save()
    return { success: true, country: JSON.parse(JSON.stringify(newCountry)) }
  } catch (e) {
    if (e.code === 11000) return { success: false, error: 'Country already exists.' }
    return { success: false, error: 'Failed to create country.' }
  }
}

export async function updateCountry(filter, update, options) {
  try {
    const country = await Country.findOneAndUpdate(filter, update, {
      new: true,
      ...options,
    }).lean()
    return { success: true, country: JSON.parse(JSON.stringify(country)) }
  } catch (e) {
    return { success: false, error: 'Failed to update country.' }
  }
}

export async function createSource(sourceData) {
  try {
    const newSource = new Source(sourceData)
    await newSource.save()
    return { success: true, source: JSON.parse(JSON.stringify(newSource)) }
  } catch (e) {
    if (e.code === 11000)
      return { success: false, error: 'A source with this name already exists.' }
    return { success: false, error: 'Failed to create source.' }
  }
}

export async function updateSource(sourceId, updateData) {
  try {
    const updatedSource = await Source.findByIdAndUpdate(
      sourceId,
      { $set: updateData },
      { new: true }
    ).lean()
    if (!updatedSource) return { success: false, error: 'Source not found.' }
    return { success: true, source: JSON.parse(JSON.stringify(updatedSource)) }
  } catch (e) {
    return { success: false, error: 'Failed to update source.' }
  }
}

export const getAllCountries = async () => {
  try {
    const countries = await Country.aggregate([
      { $match: {} },
      {
        $lookup: {
          from: 'synthesized_events',
          localField: 'name',
          foreignField: 'country',
          as: 'events',
        },
      },
      {
        $lookup: {
          from: 'sources',
          localField: 'name',
          foreignField: 'country',
          as: 'sources',
        },
      },
      {
        $project: {
          name: 1,
          isoCode: 1,
          status: 1,
          eventCount: { $size: '$events' },
          sourceCount: { $size: '$sources' },
          activeSourceCount: {
            $size: {
              $filter: {
                input: '$sources',
                as: 'source',
                cond: { $eq: ['$$source.status', 'active'] },
              },
            },
          },
        },
      },
    ])
    return { success: true, data: JSON.parse(JSON.stringify(countries)) }
  } catch (e) {
    console.error('[getAllCountries Error]', e)
    return { success: false, error: 'Failed to fetch countries.' }
  }
}

export const findSubscribers = async ({ filter = {}, sort = { createdAt: -1 } }) => {
  try {
    const subscribers = await Subscriber.find(filter).sort(sort).lean()
    return { success: true, data: JSON.parse(JSON.stringify(subscribers)) }
  } catch (e) {
    return { success: false, error: 'Failed to find subscribers.' }
  }
}

export const getAllSubscribers = async ({
  page = 1,
  filters = {},
  sort = 'createdAt_desc',
}) => {
  try {
    const { queryFilter, sortOptions } = await buildQuery(Subscriber, { filters, sort })
    const SUBSCRIBERS_PER_PAGE = 50
    const skipAmount = (page - 1) * SUBSCRIBERS_PER_PAGE
    const [subscribers, total] = await Promise.all([
      Subscriber.find(queryFilter)
        .sort(sortOptions)
        .skip(skipAmount)
        .limit(SUBSCRIBERS_PER_PAGE)
        .lean(),
      Subscriber.countDocuments(queryFilter),
    ])
    return { success: true, data: JSON.parse(JSON.stringify(subscribers)), total }
  } catch (e) {
    console.error('[getAllSubscribers Error]', e)
    return { success: false, error: 'Failed to fetch subscribers.' }
  }
}

export const getAllSources = async ({ filter = {}, sort = { name: 1 } }) => {
  try {
    const sources = await Source.find(filter).sort(sort).lean()
    return { success: true, data: JSON.parse(JSON.stringify(sources)) }
  } catch (e) {
    console.error('[getAllSources Error]', e)
    return { success: false, error: 'Failed to fetch sources.' }
  }
}

export const getAllWatchlistEntities = async ({
  page = 1,
  filters = {},
  sort = 'name_asc',
} = {}) => {
  try {
    const { queryFilter, sortOptions } = await buildQuery(WatchlistEntity, {
      filters,
      sort,
    })
    const ITEMS_PER_PAGE = 50
    const skipAmount = (page - 1) * ITEMS_PER_PAGE

    const [entities, total] = await Promise.all([
      WatchlistEntity.find(queryFilter)
        .sort(sortOptions)
        .skip(skipAmount)
        .limit(ITEMS_PER_PAGE)
        .lean(),
      WatchlistEntity.countDocuments(queryFilter),
    ])

    return { success: true, data: JSON.parse(JSON.stringify(entities)), total }
  } catch (e) {
    console.error('[getAllWatchlistEntities Error]', e)
    return { success: false, error: 'Failed to fetch watchlist entities.' }
  }
}

export const getSuggestions = async () => {
  try {
    const [watchlistSuggestions, sourceSuggestions] = await Promise.all([
      WatchlistSuggestion.find({ status: 'candidate' }).sort({ createdAt: -1 }).lean(),
      SourceSuggestion.find({ status: 'pending' }).sort({ createdAt: -1 }).lean(),
    ])
    return { success: true, data: { watchlistSuggestions, sourceSuggestions } }
  } catch (e) {
    console.error('[getSuggestions Error]', e)
    return { success: false, error: 'Failed to fetch suggestions.' }
  }
}

```

## ðŸ“„ src/core/aiSourceDiscovery.js
*Lines: 33, Size: 980 Bytes*

```javascript
// packages/data-access/src/actions/aiSourceDiscovery.js
import { callLanguageModel } from '@headlines/ai-services'
import { instructionSourceDiscovery } from '@headlines/prompts'
import { settings } from '@headlines/config'

const AI_AGENT_MODEL = settings.LLM_MODEL_UTILITY

export async function suggestSections(url) {
  const scrapeResult = {
    success: true,
    content: '<div>Mock Content</div>',
  }

  try {
    const data = await callLanguageModel({
      modelName: AI_AGENT_MODEL,
      systemPrompt: instructionSourceDiscovery,
      userContent: `Analyze the HTML from ${url}:\n\n${scrapeResult.content}`,
      isJson: true,
    })
    return { success: true, data: data.suggestions }
  } catch (e) {
    return { success: false, error: 'AI agent failed to suggest sections.' }
  }
}

export async function suggestSelector(url, targetType) {
  return {
    success: true,
    data: { selector: `div.${targetType}`, confidence: 0.9, sample: 'Sample Text' },
  }
}

```

## ðŸ“„ src/core/articles.js
*Lines: 95, Size: 2.59 KB*

```javascript
// packages/data-access/src/core/articles.js
import { Article } from '@headlines/models'
import { buildQuery } from '../queryBuilder.js'
import mongoose from 'mongoose'

const ARTICLES_PER_PAGE = 50

export async function getArticles({
  page = 1,
  filters = {},
  sort = 'date_desc',
  userId = null,
}) {
  const { queryFilter, sortOptions } = await buildQuery(Article, {
    filters,
    sort,
    userId,
  })

  const [articles, total] = await Promise.all([
    Article.find(queryFilter)
      .sort(sortOptions)
      .skip((page - 1) * ARTICLES_PER_PAGE)
      .limit(ARTICLES_PER_PAGE)
      .lean(),
    Article.countDocuments(queryFilter),
  ])

  return { success: true, data: JSON.parse(JSON.stringify(articles)), total }
}

export async function findArticles({
  filter = {},
  sort = { createdAt: -1 },
  select = '',
  limit = 0,
}) {
  try {
    const query = Article.find(filter).sort(sort).select(select)
    if (limit > 0) {
      query.limit(limit)
    }
    const articles = await query.lean()
    return { success: true, data: JSON.parse(JSON.stringify(articles)) }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function updateArticles(filter, update) {
  try {
    const result = await Article.updateMany(filter, update)
    return {
      success: true,
      matchedCount: result.matchedCount,
      modifiedCount: result.modifiedCount,
    }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function getTotalArticleCount({ filters = {}, userId = null }) {
  const { queryFilter } = await buildQuery(Article, { filters, userId })
  const total = await Article.countDocuments(queryFilter)
  return { success: true, total }
}

export async function updateArticle(articleId, updateData) {
  const article = await Article.findByIdAndUpdate(
    articleId,
    { $set: updateData },
    { new: true }
  ).lean()
  if (!article) return { success: false, error: 'Article not found.' }
  return { success: true, data: JSON.parse(JSON.stringify(article)) }
}

export async function deleteArticle(articleId) {
  const result = await Article.findByIdAndDelete(articleId)
  if (!result) return { success: false, error: 'Article not found.' }
  return { success: true }
}

export async function getArticleDetails(articleId) {
  if (!mongoose.Types.ObjectId.isValid(articleId)) {
    return { success: false, error: 'Invalid ID format.' }
  }
  const article = await Article.findById(articleId).lean()
  if (!article) {
    return { success: false, error: 'Article not found.' }
  }
  return { success: true, data: JSON.parse(JSON.stringify(article)) }
}

```

## ðŸ“„ src/core/auth.js
*Lines: 82, Size: 2.54 KB*

```javascript
// packages/data-access/src/core/auth.js
import { Subscriber } from '@headlines/models'
import bcryptjs from 'bcryptjs'

const SALT_WORK_FACTOR = 10

export async function createSubscriberWithPassword(userData) {
  if (!userData.password) {
    return { success: false, error: 'Password is required to create a user.' }
  }
  try {
    const salt = await bcryptjs.genSalt(SALT_WORK_FACTOR)
    userData.password = await bcryptjs.hash(userData.password, salt)

    // Set trial expiration if applicable
    if (userData.subscriptionTier === 'trial') {
      const trialEndDate = new Date()
      trialEndDate.setDate(trialEndDate.getDate() + 30)
      userData.subscriptionExpiresAt = trialEndDate
    }

    const newUser = new Subscriber(userData)
    await newUser.save()
    const { password, ...userPayload } = newUser.toObject()
    return { success: true, user: userPayload }
  } catch (error) {
    if (error.code === 11000) {
      return { success: false, error: 'A user with this email already exists.' }
    }
    return { success: false, error: 'Failed to create subscriber.' }
  }
}

export async function updateSubscriberPassword(userId, newPassword) {
  if (!newPassword) {
    return { success: false, error: 'New password cannot be empty.' }
  }
  try {
    const salt = await bcryptjs.genSalt(SALT_WORK_FACTOR)
    const hashedPassword = await bcryptjs.hash(newPassword, salt)
    const result = await Subscriber.updateOne(
      { _id: userId },
      { password: hashedPassword }
    )
    if (result.matchedCount === 0) {
      return { success: false, error: 'User not found.' }
    }
    return { success: true }
  } catch (error) {
    return { success: false, error: 'Failed to update password.' }
  }
}

export async function loginUser({ email, password }) {
  if (!email || !password) {
    return { success: false, error: 'Email and password are required.' }
  }

  try {
    const user = await Subscriber.findOne({
      email: email.toLowerCase().trim(),
      isActive: true,
    }).select('+password')

    if (!user) {
      return { success: false, error: 'Invalid credentials or inactive account.' }
    }

    const isPasswordMatch = await bcryptjs.compare(password, user.password)

    if (!isPasswordMatch) {
      return { success: false, error: 'Invalid credentials or inactive account.' }
    }

    const { password: _, ...userPayload } = user.toObject()
    return { success: true, user: userPayload }
  } catch (error) {
    console.error('[loginUser Action Error]', error)
    return { success: false, error: 'An internal server error occurred.' }
  }
}

```

## ðŸ“„ src/core/chat.js
*Lines: 27, Size: 1.08 KB*

```javascript
// packages/data-access/src/core/chat.js
import { callLanguageModel } from '@headlines/ai-services'
import { settings } from '@headlines/config'

const TITLE_GENERATOR_MODEL = settings.LLM_MODEL_UTILITY

const TITLE_GENERATOR_PROMPT = `You are a title generation AI. Your task is to read a conversation and create a concise, 5-word-or-less title that accurately summarizes the main topic. Example Title: "Anders Holch Povlsen's Bestseller"`

export async function generateChatTitle(messages) {
  if (!messages || messages.length < 2) {
    return { success: false, error: 'Not enough messages to generate a title.' }
  }
  try {
    const conversationText = messages.map((m) => `${m.role}: ${m.content}`).join('\n')
    const title = await callLanguageModel({
      modelName: TITLE_GENERATOR_MODEL,
      systemPrompt: TITLE_GENERATOR_PROMPT,
      userContent: conversationText,
      isJson: false,
    })
    const cleanedTitle = title.trim().replace(/"/g, '')
    return { success: true, title: cleanedTitle }
  } catch (error) {
    return { success: false, error: 'Failed to generate title.' }
  }
}

```

## ðŸ“„ src/core/dashboard.js
*Lines: 153, Size: 4.13 KB*

```javascript
// packages/data-access/src/core/dashboard.js (MODIFIED)
import {
  Source,
  Subscriber,
  WatchlistEntity,
  Article,
  SynthesizedEvent,
  Opportunity,
  Country,
} from '@headlines/models'

export async function getDashboardStats() {
  try {
    const [
      sourceStats,
      userStats,
      watchlistStats,
      articleStats,
      eventStats,
      opportunityStats,
    ] = await Promise.all([
      Source.aggregate([
        {
          $group: {
            _id: null,
            total: { $sum: 1 },
            active: { $sum: { $cond: [{ $eq: ['$status', 'active'] }, 1, 0] } },
          },
        },
      ]),
      Subscriber.aggregate([
        {
          $group: {
            _id: null,
            total: { $sum: 1 },
            active: { $sum: { $cond: ['$isActive', 1, 0] } },
          },
        },
      ]),
      WatchlistEntity.aggregate([{ $group: { _id: null, total: { $sum: 1 } } }]),
      Article.aggregate([{ $group: { _id: null, total: { $sum: 1 } } }]),
      SynthesizedEvent.aggregate([{ $group: { _id: null, total: { $sum: 1 } } }]),
      Opportunity.aggregate([{ $group: { _id: null, total: { $sum: 1 } } }]),
    ])

    const stats = {
      sources: sourceStats[0] || { total: 0, active: 0 },
      users: userStats[0] || { total: 0, active: 0 },
      watchlist: watchlistStats[0] || { total: 0 },
      articles: articleStats[0] || { total: 0 },
      events: eventStats[0] || { total: 0 },
      opportunities: opportunityStats[0] || { total: 0 },
    }

    delete stats.sources._id
    delete stats.users._id
    delete stats.watchlist._id
    delete stats.articles._id
    delete stats.events._id
    delete stats.opportunities._id

    return { success: true, data: stats }
  } catch (e) {
    return { success: false, error: 'Failed to fetch dashboard stats.' }
  }
}

// NEW FUNCTION: Fetches all unique country strings used in the main collections.
export async function getDistinctCountries() {
  try {
    const [articleCountries, eventCountries, oppCountries] = await Promise.all([
      Article.distinct('country'),
      SynthesizedEvent.distinct('country'),
      Opportunity.distinct('basedIn'),
    ])

    const allCountries = [...articleCountries, ...eventCountries, ...oppCountries]
      .flat()
      .filter(Boolean) // Flatten arrays and remove any null/undefined values

    const uniqueCountries = [...new Set(allCountries)].sort()
    return { success: true, data: uniqueCountries }
  } catch (e) {
    return { success: false, error: 'Failed to fetch distinct countries.' }
  }
}

export async function getGlobalCountries() {
  try {
    const countries = await Country.aggregate([
      { $match: { status: 'active' } },
      {
        $lookup: {
          from: 'synthesized_events',
          localField: 'name',
          foreignField: 'country',
          as: 'events',
        },
      },
      {
        $project: {
          name: 1,
          isoCode: 1,
          count: { $size: '$events' },
        },
      },
      {
        $match: {
          count: { $gt: 0 },
        },
      },
      { $sort: { name: 1 } },
    ])
    return { success: true, data: JSON.parse(JSON.stringify(countries)) }
  } catch (e) {
    return { success: false, error: 'Failed to fetch global countries.' }
  }
}

export async function getPublicTickerEvents() {
  try {
    const events = await SynthesizedEvent.find({
      highest_relevance_score: { $gte: 85 },
      eventClassification: 'New Wealth',
    })
      .sort({ createdAt: -1 })
      .limit(15)
      .select('country synthesized_headline')
      .lean()

    const formattedEvents = events.map((event) => {
      let headline = event.synthesized_headline
      headline = headline.replace(
        /\b([A-Z][a-z]+(?: [A-Z][a-z]+)+)\b/g,
        'a private investor'
      )
      headline = headline.replace(
        /\b([A-Z][A-Z\s-]+[A-Z])\b/g,
        'a privately-held company'
      )
      return {
        _id: event._id,
        country: event.country,
        headline: headline,
      }
    })

    return { success: true, data: JSON.parse(JSON.stringify(formattedEvents)) }
  } catch (e) {
    return { success: false, error: 'Failed to fetch public ticker events.' }
  }
}

```

## ðŸ“„ src/core/email.js
*Lines: 43, Size: 1.5 KB*

```javascript
// packages/data-access/src/core/email.js
import { SynthesizedEvent, Opportunity, Article } from '@headlines/models'
// This import will need a proper mailer service setup, for now we mock it.
// import { sendSingleItemEmail } from '@/lib/mailer';

async function sendItemByEmail(itemId, itemType, userId) {
  try {
    let item
    const modelMap = {
      event: SynthesizedEvent,
      opportunity: Opportunity,
      article: Article,
    }

    const Model = modelMap[itemType]
    if (!Model) return { success: false, error: 'Invalid item type.' }

    item = await Model.findById(itemId).lean()
    if (!item) return { success: false, error: 'Item not found.' }

    // In a real implementation, you would format this into a nice HTML email.
    const emailContent = `
            <h1>Item Reminder</h1>
            <p><strong>Type:</strong> ${itemType}</p>
            <p><strong>ID:</strong> ${itemId}</p>
            <pre>${JSON.stringify(item, null, 2)}</pre>
        `

    console.log(`--- SIMULATING EMAIL ---`)
    console.log(`TO: User ${userId}`)
    console.log(`SUBJECT: Your Requested Item: ${item.headline || item.reachOutTo}`)
    console.log(emailContent)
    // await sendSingleItemEmail(userId, `Your Requested Item: ${item.headline || item.reachOutTo}`, emailContent);

    return { success: true, message: 'Item has been sent to your email.' }
  } catch (e) {
    console.error('[sendItemByEmail Error]:', e)
    return { success: false, error: 'Failed to send item by email.' }
  }
}

export { sendItemByEmail }

```

## ðŸ“„ src/core/events.js
*Lines: 106, Size: 3.25 KB*

```javascript
// packages/data-access/src/core/events.js
import { SynthesizedEvent, Article, Opportunity } from '@headlines/models'
import { buildQuery } from '../queryBuilder.js'
import mongoose from 'mongoose'

const EVENTS_PER_PAGE = 50

export async function getEvents({
  page = 1,
  filters = {},
  sort = 'createdAt_desc',
  userId = null,
}) {
  const { queryFilter, sortOptions } = await buildQuery(SynthesizedEvent, {
    filters,
    sort,
    userId,
  })
  const skipAmount = (page - 1) * EVENTS_PER_PAGE

  const [events, total] = await Promise.all([
    SynthesizedEvent.find(queryFilter)
      .select('-synthesized_summary')
      .sort(sortOptions)
      .skip(skipAmount)
      .limit(EVENTS_PER_PAGE)
      .lean(),
    SynthesizedEvent.countDocuments(queryFilter),
  ])
  return { success: true, data: JSON.parse(JSON.stringify(events)), total }
}

export async function findEvents({
  filter = {},
  sort = { createdAt: -1 },
  limit = 0,
  populate = '',
}) {
  try {
    const query = SynthesizedEvent.find(filter).sort(sort).populate(populate)
    if (limit > 0) {
      query.limit(limit)
    }
    const events = await query.lean()
    return { success: true, data: JSON.parse(JSON.stringify(events)) }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function updateEvents(filter, update) {
  try {
    const result = await SynthesizedEvent.updateMany(filter, update)
    return {
      success: true,
      matchedCount: result.matchedCount,
      modifiedCount: result.modifiedCount,
    }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function getEventDetails(eventId) {
  if (!mongoose.Types.ObjectId.isValid(eventId))
    return { success: false, error: 'Invalid event ID' }
  const event = await SynthesizedEvent.findById(eventId)
    .populate({ path: 'relatedOpportunities', model: Opportunity, select: 'reachOutTo' })
    .lean()
  if (!event) return { success: false, error: 'Event not found' }
  return { success: true, data: JSON.parse(JSON.stringify(event)) }
}

export async function updateEvent(eventId, updateData) {
  if (!mongoose.Types.ObjectId.isValid(eventId))
    return { success: false, error: 'Invalid event ID' }
  const event = await SynthesizedEvent.findByIdAndUpdate(
    eventId,
    { $set: updateData },
    { new: true, runValidators: true }
  ).lean()
  if (!event) return { success: false, error: 'Event not found.' }
  return { success: true, data: JSON.parse(JSON.stringify(event)) }
}

export async function deleteEvent(eventId) {
  if (!mongoose.Types.ObjectId.isValid(eventId))
    return { success: false, error: 'Invalid event ID' }
  const result = await SynthesizedEvent.findByIdAndDelete(eventId)
  if (!result) return { success: false, error: 'Event not found.' }
  await Promise.all([
    Opportunity.updateMany({ events: eventId }, { $pull: { events: eventId } }),
    Article.updateMany(
      { synthesizedEventId: eventId },
      { $unset: { synthesizedEventId: '' } }
    ),
  ])
  return { success: true }
}

export async function getTotalEventCount({ filters = {}, userId = null }) {
  const { queryFilter } = await buildQuery(SynthesizedEvent, { filters, userId })
  const total = await SynthesizedEvent.countDocuments(queryFilter)
  return { success: true, total }
}

```

## ðŸ“„ src/core/export.js
*Lines: 155, Size: 5.19 KB*

```javascript
// packages/data-access/src/core/export.js
import { Opportunity, Subscriber, SynthesizedEvent, Article } from '@headlines/models'
import { buildQuery } from '../queryBuilder.js'

function escapeXml(str) {
  if (str === null || str === undefined) return ''
  return String(str).replace(/[<>&'"]/g, (c) => {
    switch (c) {
      case '<':
        return '&lt;'
      case '>':
        return '&gt;'
      case '&':
        return '&amp;'
      case "'":
        return '&apos;'
      case '"':
        return '&quot;'
    }
  })
}

function convertToCSV(data, columns) {
  if (!data || data.length === 0) return ''
  const headers = columns.map((c) => c.header)
  const csvRows = [headers.join(',')]
  for (const row of data) {
    const values = headers.map((header) => {
      const column = columns.find((c) => c.header === header)
      let value = column ? row[column.key] : ''
      if (column && column.key.includes('.')) {
        value = column.key.split('.').reduce((o, i) => (o ? o[i] : ''), row)
      }
      if (value === null || value === undefined) value = ''
      if (Array.isArray(value)) value = value.join('; ')
      const stringValue = String(value)
      const escaped = stringValue.replace(/"/g, '""')
      if (escaped.includes(',')) return `"${escaped}"`
      return escaped
    })
    csvRows.push(values.join(','))
  }
  return csvRows.join('\n')
}

function convertToExcelXML(data, columns) {
  let xml = `<?xml version="1.0"?><?mso-application progid="Excel.Sheet"?><Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40"><Worksheet ss:Name="Export"><Table>`
  xml += '<Row>'
  columns.forEach((col) => {
    xml += `<Cell ss:StyleID="s1"><Data ss:Type="String">${escapeXml(col.header)}</Data></Cell>`
  })
  xml += '</Row>'
  data.forEach((row) => {
    xml += '<Row>'
    columns.forEach((col) => {
      let value = col.key.split('.').reduce((o, i) => (o ? o[i] : ''), row)
      if (value === null || value === undefined) value = ''
      if (Array.isArray(value)) value = value.join('; ')
      let type = typeof value === 'number' ? 'Number' : 'String'
      if (value instanceof Date) {
        type = 'DateTime'
        value = value.toISOString()
      }
      xml += `<Cell><Data ss:Type="${type}">${escapeXml(value)}</Data></Cell>`
    })
    xml += '</Row>'
  })
  xml += `</Table><Styles><Style ss:ID="s1"><Font ss:Bold="1"/></Style></Styles></Worksheet></Workbook>`
  return xml
}

const entityConfig = {
  opportunities: {
    model: Opportunity,
    columns: [
      { header: 'Country', key: 'basedIn' },
      { header: 'City', key: 'city' },
      { header: 'Contact', key: 'reachOutTo' },
      { header: 'Wealth ($M)', key: 'likelyMMDollarWealth' },
      { header: 'Email', key: 'contactDetails.email' },
      { header: 'Reason', key: 'whyContact' },
      { header: 'Created', key: 'createdAt' },
    ],
  },
  users: {
    model: Subscriber,
    columns: [
      { header: 'Email', key: 'email' },
      { header: 'FirstName', key: 'firstName' },
      { header: 'LastName', key: 'lastName' },
      { header: 'IsActive', key: 'isActive' },
      { header: 'Role', key: 'role' },
      { header: 'Tier', key: 'subscriptionTier' },
      { header: 'Created', key: 'createdAt' },
    ],
  },
  events: {
    model: SynthesizedEvent,
    columns: [
      { header: 'Headline', key: 'synthesized_headline' },
      { header: 'Summary', key: 'synthesized_summary' },
      { header: 'Score', key: 'highest_relevance_score' },
      { header: 'Country', key: 'country' },
      { header: 'Created', key: 'createdAt' },
    ],
  },
  articles: {
    model: Article,
    columns: [
      { header: 'Headline', key: 'headline' },
      { header: 'Newspaper', key: 'newspaper' },
      { header: 'Country', key: 'country' },
      { header: 'Headline Score', key: 'relevance_headline' },
      { header: 'Article Score', key: 'relevance_article' },
      { header: 'Link', key: 'link' },
      { header: 'Created', key: 'createdAt' },
    ],
  },
}

export async function generateExport({ entity, fileType, filters, sort }) {
  try {
    const config = entityConfig[entity]
    if (!config) {
      return { success: false, error: `Invalid entity type for export: ${entity}` }
    }

    const { model, columns } = config
    const { queryFilter, sortOptions } = await buildQuery(model, {
      filters,
      sort,
      baseQuery: {},
    })
    const dataToExport = await model.find(queryFilter).sort(sortOptions).lean()

    if (fileType === 'csv') {
      const csv = convertToCSV(dataToExport, columns)
      return { success: true, data: csv, contentType: 'text/csv', extension: 'csv' }
    } else if (fileType === 'xlsx') {
      const xml = convertToExcelXML(dataToExport, columns)
      return {
        success: true,
        data: xml,
        contentType: 'application/vnd.ms-excel',
        extension: 'xls',
      }
    }

    return { success: false, error: `Invalid file type: ${fileType}` }
  } catch (e) {
    console.error('[generateExport Error]', e)
    return { success: false, error: `Failed to generate export: ${e.message}` }
  }
}

```

## ðŸ“„ src/core/index.js
*Lines: 22, Size: 653 Bytes*

```javascript
// packages/data-access/src/core/index.js
export * from './admin.js'
export * from './aiSourceDiscovery.js'
export * from './articles.js'
export * from './auth.js'
export * from './chat.js'
export * from './dashboard.js'
export * from './email.js'
export * from './events.js'
export * from './export.js'
export * from './knowledge.js'
export * from './maintenance.js'
export * from './opportunities.js'
export * from './pipeline.js'
export * from './relationships.js'
export * from './settings.js'
export * from './subscriber.js'
export * from './upload.js'
export * from './userSettings.js'
export * from './verdicts.js'
export * from './watchlist.js'

```

## ðŸ“„ src/core/knowledge.js
*Lines: 78, Size: 2.52 KB*

```javascript
// packages/data-access/src/core/knowledge.js
import { Pinecone } from '@pinecone-database/pinecone'
import mongoose from 'mongoose'
import { Article } from '@headlines/models'
import { generateEmbedding } from '@headlines/ai-services'
import { env } from '@headlines/config'

let pineconeIndex
function getPineconeIndex() {
  if (!pineconeIndex) {
    const pc = new Pinecone({ apiKey: env.PINECONE_API_KEY })
    pineconeIndex = pc.index(env.PINECONE_INDEX_NAME)
  }
  return pineconeIndex
}

export async function addKnowledge(data) {
  const { headline, business_summary, source, country, link } = data
  console.log(`[Add Knowledge] Attempting to add new knowledge: "${headline}"`)

  if (!headline || !business_summary || !source || !country || !link) {
    console.error('[Add Knowledge] Validation failed: Missing required fields.')
    return { success: false, message: 'All fields are required.' }
  }

  try {
    const index = getPineconeIndex()

    console.log('[Add Knowledge] Generating embedding...')
    const textToEmbed = `${headline}\n${business_summary}`
    const embedding = await generateEmbedding(textToEmbed)
    console.log('[Add Knowledge] Embedding generated successfully.')

    const newArticle = new Article({
      _id: new mongoose.Types.ObjectId(),
      headline,
      link,
      newspaper: source,
      source: 'Manual Upload',
      country,
      relevance_headline: 100,
      assessment_headline: 'Manually uploaded by user.',
      relevance_article: 100,
      assessment_article: business_summary,
      embedding: embedding,
      key_individuals: [],
    })
    console.log('[Add Knowledge] MongoDB document created.')

    await newArticle.save()
    console.log('[Add Knowledge] Saved to MongoDB.')

    const key_individual_names = (newArticle.key_individuals || []).map((p) => p.name)

    await index.upsert([
      {
        id: newArticle._id.toString(),
        values: embedding,
        metadata: {
          headline: newArticle.headline,
          summary: newArticle.assessment_article,
          newspaper: newArticle.newspaper,
          country: newArticle.country,
          key_individuals: key_individual_names,
        },
      },
    ])
    console.log('[Add Knowledge] Upserted to Pinecone.')

    console.log('[Add Knowledge] Revalidation responsibility moved to API routes.')

    return { success: true, message: 'Knowledge successfully added and embedded.' }
  } catch (error) {
    console.error('[Add Knowledge Error]', error)
    return { success: false, message: 'Failed to add knowledge.' }
  }
}

```

## ðŸ“„ src/core/maintenance.js
*Lines: 79, Size: 2.29 KB*

```javascript
// packages/data-access/src/core/maintenance.js
import {
  Article,
  SynthesizedEvent,
  Opportunity,
  RunVerdict,
  Source,
} from '@headlines/models'

/**
 * Deletes all documents from key collections that were created after a specific cutoff date.
 * @param {Date} cutoffDate - The date after which documents will be deleted.
 * @returns {Promise<object>} An object with counts of deleted documents per model.
 */
export async function deleteAllSince(cutoffDate) {
  const query = { createdAt: { $gte: cutoffDate } }
  const modelsToDelete = {
    Article,
    SynthesizedEvent,
    Opportunity,
    RunVerdict,
  }

  const deletionPromises = Object.entries(modelsToDelete).map(
    async ([modelName, model]) => {
      const { deletedCount } = await model.deleteMany(query)
      return { modelName, deletedCount }
    }
  )

  const results = await Promise.all(deletionPromises)
  const summary = results.reduce((acc, { modelName, deletedCount }) => {
    acc[modelName] = deletedCount
    return acc
  }, {})

  return { success: true, summary }
}

/**
 * Resets all analytics fields for every Source document to their default zero values.
 * @returns {Promise<object>} An object containing the count of modified documents.
 */
export async function resetAllSourceAnalytics() {
  const result = await Source.updateMany(
    {},
    {
      $set: {
        'analytics.totalRuns': 0,
        'analytics.totalSuccesses': 0,
        'analytics.totalFailures': 0,
        'analytics.totalScraped': 0,
        'analytics.totalRelevant': 0,
        'analytics.lastRunHeadlineCount': 0,
        'analytics.lastRunRelevantCount': 0,
        'analytics.lastRunContentSuccess': false,
      },
    }
  )
  return { success: true, modifiedCount: result.modifiedCount }
}

/**
 * Resets the `emailed` status to false for all events created after a specific cutoff date.
 * @param {Date} cutoffDate - The date to filter events from.
 * @returns {Promise<object>} An object containing the count of matched and modified documents.
 */
export async function resetEventsEmailedStatusSince(cutoffDate) {
  const result = await SynthesizedEvent.updateMany(
    { createdAt: { $gte: cutoffDate } },
    { $set: { emailed: false } }
  )
  return {
    success: true,
    matchedCount: result.matchedCount,
    modifiedCount: result.modifiedCount,
  }
}

```

## ðŸ“„ src/core/opportunities.js
*Lines: 97, Size: 3.07 KB*

```javascript
// packages/data-access/src/core/opportunities.js
import { Opportunity } from '@headlines/models'
import { buildQuery } from '../queryBuilder.js'
import mongoose from 'mongoose'

const OPPORTUNITIES_PER_PAGE = 50

export async function getDistinctOpportunityFields(field) {
  try {
    const distinctValues = await Opportunity.distinct(field)
    return { success: true, data: distinctValues }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function updateOpportunities(filter, update) {
  try {
    const result = await Opportunity.updateMany(filter, update)
    return {
      success: true,
      matchedCount: result.matchedCount,
      modifiedCount: result.modifiedCount,
    }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function getTotalOpportunitiesCount({ filters = {}, userId = null }) {
  const { queryFilter } = await buildQuery(Opportunity, { filters, userId })
  const total = await Opportunity.countDocuments(queryFilter)
  return { success: true, total }
}

export async function getOpportunities({
  page = 1,
  filters = {},
  sort = 'date_desc',
  userId = null,
}) {
  let { queryFilter, sortOptions } = await buildQuery(Opportunity, {
    filters,
    sort,
    userId,
  })

  if (sort === 'size_desc') {
    if (queryFilter.$and) {
      queryFilter.$and.push({ likelyMMDollarWealth: { $gt: 0 } })
    } else if (Object.keys(queryFilter).length > 0) {
      queryFilter = { $and: [queryFilter, { likelyMMDollarWealth: { $gt: 0 } }] }
    } else {
      queryFilter = { likelyMMDollarWealth: { $gt: 0 } }
    }
  }

  const skipAmount = (page - 1) * OPPORTUNITIES_PER_PAGE
  const [opportunities, total] = await Promise.all([
    Opportunity.find(queryFilter)
      .populate({ path: 'events', select: 'synthesized_headline', options: { limit: 1 } })
      .sort(sortOptions)
      .skip(skipAmount)
      .limit(OPPORTUNITIES_PER_PAGE)
      .lean(),
    Opportunity.countDocuments(queryFilter),
  ])
  return { success: true, data: JSON.parse(JSON.stringify(opportunities)), total }
}

export async function getOpportunityDetails(opportunityId) {
  if (!mongoose.Types.ObjectId.isValid(opportunityId)) {
    return { success: false, error: 'Invalid ID format.' }
  }
  const opportunity = await Opportunity.findById(opportunityId)
    .populate({ path: 'events', options: { sort: { createdAt: -1 } } })
    .lean()
  if (!opportunity) return { success: false, error: 'Opportunity not found.' }
  return { success: true, data: JSON.parse(JSON.stringify(opportunity)) }
}

export async function updateOpportunity(oppId, updateData) {
  const opp = await Opportunity.findByIdAndUpdate(
    oppId,
    { $set: updateData },
    { new: true, runValidators: true }
  ).lean()
  if (!opp) return { success: false, error: 'Opportunity not found.' }
  return { success: true, data: JSON.parse(JSON.stringify(opp)) }
}

export async function deleteOpportunity(oppId) {
  const result = await Opportunity.findByIdAndDelete(oppId)
  if (!result) return { success: false, error: 'Opportunity not found.' }
  return { success: true }
}

```

## ðŸ“„ src/core/pipeline.js
*Lines: 102, Size: 3.01 KB*

```javascript
// packages/data-access/src/core/pipeline.js
import {
  Source,
  Article,
  SynthesizedEvent,
  Opportunity,
  WatchlistEntity,
  WatchlistSuggestion,
} from '@headlines/models'

export async function updateSourceAnalyticsBatch(bulkOps) {
  if (!bulkOps || bulkOps.length === 0) return { success: true, modifiedCount: 0 }
  try {
    const result = await Source.bulkWrite(bulkOps)
    return { success: true, modifiedCount: result.modifiedCount }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function findSourcesForScraping(queryCriteria) {
  try {
    const sources = await Source.find(queryCriteria).lean()
    return { success: true, data: JSON.parse(JSON.stringify(sources)) }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function performHousekeeping(deletionCriteria) {
  try {
    const result = await Article.deleteMany(deletionCriteria)
    return { success: true, deletedCount: result.deletedCount }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function bulkWriteEvents(eventOps) {
  if (!eventOps || eventOps.length === 0)
    return { success: true, upsertedCount: 0, modifiedCount: 0 }
  try {
    const result = await SynthesizedEvent.bulkWrite(eventOps, { ordered: false })
    return {
      success: true,
      upsertedCount: result.upsertedCount,
      modifiedCount: result.modifiedCount,
    }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function bulkWriteArticles(articleOps) {
  if (!articleOps || articleOps.length === 0) return { success: true, result: null }
  try {
    const result = await Article.bulkWrite(articleOps, { ordered: false })
    return { success: true, result }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function findEventsByKeys(eventKeys) {
  try {
    const events = await SynthesizedEvent.find({ event_key: { $in: eventKeys } }).lean()
    return { success: true, data: JSON.parse(JSON.stringify(events)) }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function findArticlesByLinks(links) {
  try {
    const articles = await Article.find({ link: { $in: links } })
      .select('link _id')
      .lean()
    return { success: true, data: JSON.parse(JSON.stringify(articles)) }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function getActiveWatchlistEntityNames() {
  try {
    const entities = await WatchlistEntity.find({}).select('name').lean()
    return { success: true, data: entities }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function bulkWriteWatchlistSuggestions(bulkOps) {
  if (!bulkOps || bulkOps.length === 0) return { success: true, result: null }
  try {
    const result = await WatchlistSuggestion.bulkWrite(bulkOps)
    return { success: true, result }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

```

## ðŸ“„ src/core/relationships.js
*Lines: 50, Size: 1.65 KB*

```javascript
// packages/data-access/src/core/relationships.js
import { SynthesizedEvent, Opportunity } from '@headlines/models'
import mongoose from 'mongoose'

// --- START DEFINITIVE FIX ---
// This file is now TRULY isomorphic and stateless. It does not import
// or call dbConnect. The caller (API Handler or Server Action) is
// responsible for establishing the connection.
// --- END DEFINITIVE FIX ---

export async function linkOpportunityToEvent(eventId, opportunityId) {
  if (
    !mongoose.Types.ObjectId.isValid(eventId) ||
    !mongoose.Types.ObjectId.isValid(opportunityId)
  ) {
    return { success: false, error: 'Invalid ID format.' }
  }
  try {
    await Promise.all([
      SynthesizedEvent.findByIdAndUpdate(eventId, {
        $addToSet: { relatedOpportunities: opportunityId },
      }),
      Opportunity.findByIdAndUpdate(opportunityId, { $addToSet: { events: eventId } }),
    ])
    return { success: true, message: 'Relationship linked.' }
  } catch (e) {
    return { success: false, error: 'Database operation failed.' }
  }
}

export async function unlinkOpportunityFromEvent(eventId, opportunityId) {
  if (
    !mongoose.Types.ObjectId.isValid(eventId) ||
    !mongoose.Types.ObjectId.isValid(opportunityId)
  ) {
    return { success: false, error: 'Invalid ID format.' }
  }
  try {
    await Promise.all([
      SynthesizedEvent.findByIdAndUpdate(eventId, {
        $pull: { relatedOpportunities: opportunityId },
      }),
      Opportunity.findByIdAndUpdate(opportunityId, { $pull: { events: eventId } }),
    ])
    return { success: true, message: 'Relationship unlinked.' }
  } catch (e) {
    return { success: false, error: 'Database operation failed.' }
  }
}

```

## ðŸ“„ src/core/settings.js
*Lines: 49, Size: 1.49 KB*

```javascript
// packages/data-access/src/core/settings.js
import { Setting } from '@headlines/models'
// The environment-specific import has been removed.
// import { revalidatePath } from '../revalidate.js'

export async function getSettings() {
  try {
    const settings = await Setting.find({}).sort({ key: 1 }).lean()
    return { success: true, data: JSON.parse(JSON.stringify(settings)) }
  } catch (e) {
    console.error('[getSettings Error]', e)
    return { success: false, error: 'Failed to fetch settings.' }
  }
}

export async function updateSettings(settingsData) {
  try {
    const bulkOps = settingsData.map((setting) => {
      let castValue = setting.value
      if (setting.type === 'number') castValue = Number(setting.value)
      if (setting.type === 'boolean') castValue = Boolean(setting.value)
      return {
        updateOne: {
          filter: { key: setting.key },
          update: {
            $set: {
              value: castValue,
              description: setting.description,
              type: setting.type,
            },
          },
          upsert: true,
        },
      }
    })

    if (bulkOps.length > 0) {
      await Setting.bulkWrite(bulkOps)
    }

    // Revalidation is now handled by the environment-specific wrapper.
    // await revalidatePath('/admin/settings')
    return { success: true, message: `${bulkOps.length} settings updated.` }
  } catch (e) {
    console.error('[updateSettings Error]', e)
    return { success: false, error: 'Failed to update settings.' }
  }
}

```

## ðŸ“„ src/core/subscriber.js
*Lines: 109, Size: 3.58 KB*

```javascript
// packages/data-access/src/core/subscriber.js
import { Subscriber, PushSubscription } from '@headlines/models'

export async function upsertSubscriber(filter, userData) {
  try {
    const user = await Subscriber.findOneAndUpdate(filter, userData, {
      new: true,
      upsert: true,
      runValidators: true,
    }).lean()
    return { success: true, user: JSON.parse(JSON.stringify(user)) }
  } catch (error) {
    if (error.code === 11000)
      return { success: false, error: 'A user with this email already exists.' }
    return { success: false, error: 'Failed to upsert subscriber.' }
  }
}

export async function getAllPushSubscriptions() {
  try {
    const subscriptions = await PushSubscription.find().lean()
    return { success: true, data: JSON.parse(JSON.stringify(subscriptions)) }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function deletePushSubscription(filter) {
  try {
    const result = await PushSubscription.deleteOne(filter)
    return { success: true, deletedCount: result.deletedCount }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function getCurrentSubscriber(userId) {
  if (!userId) return { success: false, error: 'User ID is required' }
  try {
    const user = await Subscriber.findById(userId).lean()
    if (!user) return { success: false, error: 'User not found' }
    return { success: true, data: JSON.parse(JSON.stringify(user)) }
  } catch (e) {
    return { success: false, error: 'Database error.' }
  }
}

export async function savePushSubscription(subscription, userId) {
  if (!userId) return { success: false, error: 'Authentication required' }
  if (!subscription || !subscription.endpoint)
    return { success: false, error: 'Invalid subscription object.' }
  try {
    await PushSubscription.updateOne(
      { endpoint: subscription.endpoint },
      { $set: { ...subscription, subscriberId: userId } },
      { upsert: true }
    )
    return { success: true, message: 'Subscription saved.' }
  } catch (e) {
    return { success: false, error: 'Failed to save subscription.' }
  }
}

export async function updateUserProfile({ userId, updateData }) {
  if (!userId) return { success: false, error: 'User ID is required.' }
  if (!updateData) return { success: false, error: 'No update data provided.' }

  try {
    const updatedUser = await Subscriber.findByIdAndUpdate(
      userId,
      { $set: updateData },
      { new: true }
    )
      .select('-password')
      .lean()
    if (!updatedUser) return { success: false, error: 'User not found.' }
    return { success: true, user: JSON.parse(JSON.stringify(updatedUser)) }
  } catch (error) {
    return { success: false, error: 'Failed to update profile.' }
  }
}

export async function updateUserInteraction({ userId, itemId, itemType, action }) {
  const modelName = `${itemType}s` // e.g., 'articles', 'events'
  let updateQuery

  switch (action) {
    case 'favorite':
      updateQuery = { $addToSet: { [`favoritedItems.${modelName}`]: itemId } }
      break
    case 'unfavorite':
      updateQuery = { $pull: { [`favoritedItems.${modelName}`]: itemId } }
      break
    case 'discard':
      updateQuery = { $addToSet: { [`discardedItems.${modelName}`]: itemId } }
      break
    default:
      return { success: false, error: 'Invalid action.' }
  }

  try {
    const result = await Subscriber.updateOne({ _id: userId }, updateQuery)
    if (result.matchedCount === 0) return { success: false, error: 'User not found.' }
    return { success: true }
  } catch (e) {
    return { success: false, error: 'Database interaction failed.' }
  }
}

```

## ðŸ“„ src/core/upload.js
*Lines: 61, Size: 1.83 KB*

```javascript
// packages/data-access/src/core/upload.js
import { revalidatePath } from '../revalidate.js'
import { SynthesizedEvent, Opportunity } from '@headlines/models'
import { synthesizeEvent, generateOpportunitiesFromEvent } from '@headlines/ai-services'

export async function processUploadedArticle(item, userId) {
  if (!userId) {
    return { success: false, error: 'Authentication required' }
  }

  try {
    const enrichedArticle = {
      ...item,
      relevance_article: 100,
      assessment_article: item.article,
      articleContent: { contents: [item.article] },
      newspaper: 'Manual Upload',
      country: 'Denmark',
      key_individuals: [],
    }

    const synthesizedResult = await synthesizeEvent([enrichedArticle], [], '', '')
    if (
      !synthesizedResult ||
      !synthesizedResult.events ||
      synthesizedResult.events.length === 0
    ) {
      throw new Error('AI failed to synthesize an event from the provided text.')
    }
    const eventData = synthesizedResult.events[0]

    const eventToSave = new SynthesizedEvent({
      ...eventData,
      event_key: `manual-${new Date().toISOString()}`,
      highest_relevance_score: 100,
      source_articles: [
        { headline: item.headline, link: '#manual', newspaper: 'Manual Upload' },
      ],
    })

    const opportunitiesToSave = await generateOpportunitiesFromEvent(eventToSave, [
      enrichedArticle,
    ])

    await eventToSave.save()
    if (opportunitiesToSave.length > 0) {
      await Opportunity.insertMany(
        opportunitiesToSave.map((opp) => ({ ...opp, events: [eventToSave._id] }))
      )
    }

    await revalidatePath('/events')
    await revalidatePath('/opportunities')

    return { success: true, event: eventToSave.synthesized_headline }
  } catch (e) {
    console.error('[Upload Action Error]:', e)
    return { success: false, error: e.message }
  }
}

```

## ðŸ“„ src/core/userSettings.js
*Lines: 23, Size: 668 Bytes*

```javascript
// packages/data-access/src/core/userSettings.js
import { Subscriber } from '@headlines/models'

export async function clearDiscardedItems(userId) {
  if (!userId) {
    return { success: false, error: 'User ID is required.' }
  }
  try {
    await Subscriber.findByIdAndUpdate(userId, {
      $set: {
        'discardedItems.articles': [],
        'discardedItems.events': [],
        'discardedItems.opportunities': [],
      },
    })

    return { success: true, message: 'Your discarded items have been cleared.' }
  } catch (e) {
    console.error('[clearDiscardedItems Error]:', e)
    return { success: false, error: 'Failed to clear discarded items.' }
  }
}

```

## ðŸ“„ src/core/verdicts.js
*Lines: 32, Size: 1.1 KB*

```javascript
// packages/data-access/src/core/verdicts.js
import { RunVerdict, SynthesizedEvent, Opportunity } from '@headlines/models'
import mongoose from 'mongoose'

export async function getRecentRunVerdicts() {
  try {
    const verdicts = await RunVerdict.find({})
      .sort({ createdAt: -1 })
      .limit(5)
      .select('runStats createdAt')
      .lean()
    return { success: true, data: JSON.parse(JSON.stringify(verdicts)) }
  } catch (e) {
    console.error('[getRecentRunVerdicts Error]', e)
    return { success: false, error: 'Failed to fetch run verdicts.' }
  }
}

export async function getRunVerdictById(runId) {
  try {
    const verdict = await RunVerdict.findById(runId)
      .populate({ path: 'generatedEvents', model: SynthesizedEvent })
      .populate({ path: 'generatedOpportunities', model: Opportunity })
      .lean()
    if (!verdict) return { success: false, error: 'Verdict not found.' }
    return { success: true, data: JSON.parse(JSON.stringify(verdict)) }
  } catch (e) {
    console.error('[getRunVerdictById Error]', e)
    return { success: false, error: 'Failed to fetch verdict details.' }
  }
}

```

## ðŸ“„ src/core/watchlist.js
*Lines: 129, Size: 4.17 KB*

```javascript
// packages/data-access/src/core/watchlist.js
import { WatchlistEntity, Article, WatchlistSuggestion } from '@headlines/models'

export async function findWatchlistEntities(filter = {}, sort = { name: 1 }) {
  try {
    const entities = await WatchlistEntity.find(filter).sort(sort).lean()
    return { success: true, data: JSON.parse(JSON.stringify(entities)) }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function updateWatchlistEntities(filter, update) {
  try {
    const result = await WatchlistEntity.updateMany(filter, update)
    return {
      success: true,
      matchedCount: result.matchedCount,
      modifiedCount: result.modifiedCount,
    }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export async function createWatchlistEntity(entityData) {
  try {
    const newEntity = new WatchlistEntity(entityData)
    await newEntity.save()
    return { success: true, entity: JSON.parse(JSON.stringify(newEntity)) }
  } catch (e) {
    if (e.code === 11000)
      return { success: false, error: 'An entity with this name already exists.' }
    return { success: false, error: 'Failed to create entity.' }
  }
}

export async function updateWatchlistEntity(entityId, updateData) {
  try {
    if (updateData.searchTerms && Array.isArray(updateData.searchTerms)) {
      updateData.searchTerms = [
        ...new Set(
          updateData.searchTerms.map((t) => t.toLowerCase().trim()).filter(Boolean)
        ),
      ]
      const entity = await WatchlistEntity.findById(entityId).select('name').lean()
      const allTerms = [entity.name, ...updateData.searchTerms]
        .map((t) => t.toLowerCase().trim())
        .filter(Boolean)
      const uniqueTerms = [...new Set(allTerms)]
      if (uniqueTerms.length > 0) {
        const termRegexes = uniqueTerms.map(
          (term) =>
            new RegExp(`\\b${term.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\b`, 'i')
        )
        updateData.hitCount = await Article.countDocuments({
          headline: { $in: termRegexes },
        })
      } else {
        updateData.hitCount = 0
      }
    }
    const entity = await WatchlistEntity.findByIdAndUpdate(
      entityId,
      { $set: updateData },
      { new: true }
    ).lean()
    if (!entity) return { success: false, error: 'Entity not found.' }
    return { success: true, entity: JSON.parse(JSON.stringify(entity)) }
  } catch (e) {
    return { success: false, error: 'Failed to update entity.' }
  }
}

export async function deleteWatchlistEntity(entityId) {
  try {
    const result = await WatchlistEntity.findByIdAndDelete(entityId)
    if (!result) return { success: false, error: 'Entity not found.' }
    return { success: true }
  } catch (e) {
    return { success: false, error: 'Failed to delete entity.' }
  }
}

export async function updateWatchlistSuggestion(suggestionId, updateData) {
  try {
    const suggestion = await WatchlistSuggestion.findByIdAndUpdate(
      suggestionId,
      { $set: updateData },
      { new: true }
    ).lean()
    if (!suggestion) return { success: false, error: 'Suggestion not found.' }
    return { success: true, data: JSON.parse(JSON.stringify(suggestion)) }
  } catch (e) {
    return { success: false, error: 'Failed to update suggestion.' }
  }
}

export async function processWatchlistSuggestion({ suggestionId, action }) {
  try {
    const suggestion = await WatchlistSuggestion.findById(suggestionId)
    if (!suggestion) return { success: false, error: 'Suggestion not found.' }
    suggestion.status = action
    await suggestion.save()
    if (action === 'approved') {
      await WatchlistEntity.updateOne(
        { name: suggestion.name },
        {
          $setOnInsert: {
            name: suggestion.name,
            type: suggestion.type,
            country: suggestion.country,
            context: suggestion.rationale,
            searchTerms: suggestion.searchTerms,
            status: 'active',
          },
        },
        { upsert: true }
      )
    }
    return {
      success: true,
      message: `Watchlist suggestion for "${suggestion.name}" was ${action}.`,
    }
  } catch (e) {
    return { success: false, error: 'Failed to process suggestion.' }
  }
}

```

## ðŸ“„ src/dbConnect.js
*Lines: 11, Size: 421 Bytes*

```javascript
// packages/data-access/src/dbConnect.js
import { env } from '@headlines/config/node'
import dbConnectCore from './dbConnectCore.js'
import { logger } from '@headlines/utils-shared'

// This is the Node.js-specific implementation of dbConnect.
// It uses the core logic but provides the environment variables from the Node.js context.
export default function dbConnect() {
  return dbConnectCore(env.MONGO_URI, logger)
}

```

## ðŸ“„ src/dbConnect.next.js
*Lines: 12, Size: 447 Bytes*

```javascript
// packages/data-access/src/dbConnect.next.js
import 'server-only'
import { env } from '@headlines/config/next'
import dbConnectCore from './dbConnectCore.js'
import { logger } from '@headlines/utils-shared'

// This is the Next.js-specific implementation of dbConnect.
// It uses the core logic but provides the environment variables from the Next.js context.
export default function dbConnect() {
  return dbConnectCore(env.MONGO_URI, logger)
}

```

## ðŸ“„ src/dbConnectCore.js
*Lines: 35, Size: 962 Bytes*

```javascript
// packages/data-access/src/dbConnectCore.js
import mongoose from 'mongoose'

// A weak map to cache the connection promise per URI
const connectionCache = new WeakMap()

// This is the core, environment-agnostic connection logic.
export default async function dbConnectCore(MONGO_URI, logger) {
  if (!MONGO_URI) {
    throw new Error('MONGO_URI must be provided to dbConnectCore.')
  }

  if (mongoose.connection.readyState >= 1) {
    return
  }

  // Use a cache to prevent multiple concurrent connection attempts
  let connPromise = connectionCache.get(mongoose)
  if (!connPromise) {
    connPromise = mongoose.connect(MONGO_URI, { bufferCommands: false })
    connectionCache.set(mongoose, connPromise)
  }

  try {
    await connPromise
  } catch (e) {
    if (logger) {
      logger.error({ err: e }, '[dbConnectCore] MongoDB connection failed.')
    } else {
      console.error('[dbConnectCore] MongoDB connection failed.', e)
    }
    throw e
  }
}

```

## ðŸ“„ src/index.js
*Lines: 97, Size: 5.37 KB*

```javascript
// packages/data-access/src/index.js (DEFINITIVE FIX - No HOC)
import dbConnect from './dbConnect.js'
import * as core from './core/index.js'
import { buildQuery } from './queryBuilder.js'

// --- Explicit Wrappers for Each Core Function ---

// A helper to avoid rewriting the same pattern repeatedly
const wrap =
  (fn) =>
  async (...args) => {
    await dbConnect()
    return fn(...args)
  }

// Wrap and export all core functions for Node.js environment
export const createSubscriber = wrap(core.createSubscriber)
export const updateSubscriber = wrap(core.updateSubscriber)
export const deleteSubscriber = wrap(core.deleteSubscriber)
export const createCountry = wrap(core.createCountry)
export const updateCountry = wrap(core.updateCountry)
export const createSource = wrap(core.createSource)
export const updateSource = wrap(core.updateSource)
export const getAllCountries = wrap(core.getAllCountries)
export const findSubscribers = wrap(core.findSubscribers)
export const getAllSubscribers = wrap(core.getAllSubscribers)
export const getAllSources = wrap(core.getAllSources)
export const getAllWatchlistEntities = wrap(core.getAllWatchlistEntities)
export const getSuggestions = wrap(core.getSuggestions)
export const getArticles = wrap(core.getArticles)
export const findArticles = wrap(core.findArticles)
export const updateArticles = wrap(core.updateArticles)
export const getTotalArticleCount = wrap(core.getTotalArticleCount)
export const updateArticle = wrap(core.updateArticle)
export const deleteArticle = wrap(core.deleteArticle)
export const getArticleDetails = wrap(core.getArticleDetails)
export const createSubscriberWithPassword = wrap(core.createSubscriberWithPassword)
export const updateSubscriberPassword = wrap(core.updateSubscriberPassword)
export const loginUser = wrap(core.loginUser)
export const generateChatTitle = wrap(core.generateChatTitle)
export const getDashboardStats = wrap(core.getDashboardStats)
export const getDistinctCountries = wrap(core.getDistinctCountries)
export const getGlobalCountries = wrap(core.getGlobalCountries)
export const getPublicTickerEvents = wrap(core.getPublicTickerEvents)
export const getEvents = wrap(core.getEvents)
export const findEvents = wrap(core.findEvents)
export const updateEvents = wrap(core.updateEvents)
export const getEventDetails = wrap(core.getEventDetails)
export const updateEvent = wrap(core.updateEvent)
export const deleteEvent = wrap(core.deleteEvent)
export const getTotalEventCount = wrap(core.getTotalEventCount)
export const generateExport = wrap(core.generateExport)
export const getDistinctOpportunityFields = wrap(core.getDistinctOpportunityFields)
export const updateOpportunities = wrap(core.updateOpportunities)
export const getTotalOpportunitiesCount = wrap(core.getTotalOpportunitiesCount)
export const getOpportunities = wrap(core.getOpportunities)
export const getOpportunityDetails = wrap(core.getOpportunityDetails)
export const updateOpportunity = wrap(core.updateOpportunity)
export const deleteOpportunity = wrap(core.deleteOpportunity)
export const updateSourceAnalyticsBatch = wrap(core.updateSourceAnalyticsBatch)
export const findSourcesForScraping = wrap(core.findSourcesForScraping)
export const performHousekeeping = wrap(core.performHousekeeping)
export const bulkWriteEvents = wrap(core.bulkWriteEvents)
export const bulkWriteArticles = wrap(core.bulkWriteArticles)
export const findEventsByKeys = wrap(core.findEventsByKeys)
export const findArticlesByLinks = wrap(core.findArticlesByLinks)
export const getActiveWatchlistEntityNames = wrap(core.getActiveWatchlistEntityNames)
export const bulkWriteWatchlistSuggestions = wrap(core.bulkWriteWatchlistSuggestions)
export const linkOpportunityToEvent = wrap(core.linkOpportunityToEvent)
export const unlinkOpportunityFromEvent = wrap(core.unlinkOpportunityFromEvent)
export const getSettings = wrap(core.getSettings)
export const updateSettings = wrap(core.updateSettings) // No revalidation needed in Node
export const upsertSubscriber = wrap(core.upsertSubscriber)
export const getAllPushSubscriptions = wrap(core.getAllPushSubscriptions)
export const deletePushSubscription = wrap(core.deletePushSubscription)
export const getCurrentSubscriber = wrap(core.getCurrentSubscriber)
export const savePushSubscription = wrap(core.savePushSubscription)
export const updateUserProfile = wrap(core.updateUserProfile)
export const updateUserInteraction = wrap(core.updateUserInteraction)
export const processUploadedArticle = wrap(core.processUploadedArticle)
export const clearDiscardedItems = wrap(core.clearDiscardedItems)
export const getRecentRunVerdicts = wrap(core.getRecentRunVerdicts)
export const getRunVerdictById = wrap(core.getRunVerdictById)
export const findWatchlistEntities = wrap(core.findWatchlistEntities)
export const updateWatchlistEntities = wrap(core.updateWatchlistEntities)
export const createWatchlistEntity = wrap(core.createWatchlistEntity)
export const updateWatchlistEntity = wrap(core.updateWatchlistEntity)
export const deleteWatchlistEntity = wrap(core.deleteWatchlistEntity)
export const updateWatchlistSuggestion = wrap(core.updateWatchlistSuggestion)
export const processWatchlistSuggestion = wrap(core.processWatchlistSuggestion)
export const deleteAllSince = wrap(core.deleteAllSince)
export const resetAllSourceAnalytics = wrap(core.resetAllSourceAnalytics)
export const resetEventsEmailedStatusSince = wrap(core.resetEventsEmailedStatusSince)

// Export non-wrapped utilities
export { buildQuery }

```

## ðŸ“„ src/next.js
*Lines: 108, Size: 5.62 KB*

```javascript
// packages/data-access/src/next.js (DEFINITIVE FIX - No HOC)
import 'server-only'
import dbConnect from './dbConnect.next.js'
import * as core from './core/index.js'
import { revalidatePath } from './revalidate.js'
import { buildQuery } from './queryBuilder.js'

// --- Explicit Wrappers for Each Core Function ---

// A helper to avoid rewriting the same pattern repeatedly
const wrap =
  (fn) =>
  async (...args) => {
    await dbConnect()
    return fn(...args)
  }

// Wrap each function individually
export const createSubscriber = wrap(core.createSubscriber)
export const updateSubscriber = wrap(core.updateSubscriber)
export const deleteSubscriber = wrap(core.deleteSubscriber)
export const createCountry = wrap(core.createCountry)
export const updateCountry = wrap(core.updateCountry)
export const createSource = wrap(core.createSource)
export const updateSource = wrap(core.updateSource)
export const getAllCountries = wrap(core.getAllCountries)
export const findSubscribers = wrap(core.findSubscribers)
export const getAllSubscribers = wrap(core.getAllSubscribers)
export const getAllSources = wrap(core.getAllSources)
export const getAllWatchlistEntities = wrap(core.getAllWatchlistEntities)
export const getSuggestions = wrap(core.getSuggestions)
export const getArticles = wrap(core.getArticles)
export const findArticles = wrap(core.findArticles)
export const updateArticles = wrap(core.updateArticles)
export const getTotalArticleCount = wrap(core.getTotalArticleCount)
export const updateArticle = wrap(core.updateArticle)
export const deleteArticle = wrap(core.deleteArticle)
export const getArticleDetails = wrap(core.getArticleDetails)
export const createSubscriberWithPassword = wrap(core.createSubscriberWithPassword)
export const updateSubscriberPassword = wrap(core.updateSubscriberPassword)
export const loginUser = wrap(core.loginUser)
export const generateChatTitle = wrap(core.generateChatTitle)
export const getDashboardStats = wrap(core.getDashboardStats)
export const getDistinctCountries = wrap(core.getDistinctCountries)
export const getGlobalCountries = wrap(core.getGlobalCountries)
export const getPublicTickerEvents = wrap(core.getPublicTickerEvents)
export const getEvents = wrap(core.getEvents)
export const findEvents = wrap(core.findEvents)
export const updateEvents = wrap(core.updateEvents)
export const getEventDetails = wrap(core.getEventDetails)
export const updateEvent = wrap(core.updateEvent)
export const deleteEvent = wrap(core.deleteEvent)
export const getTotalEventCount = wrap(core.getTotalEventCount)
export const generateExport = wrap(core.generateExport)
export const getDistinctOpportunityFields = wrap(core.getDistinctOpportunityFields)
export const updateOpportunities = wrap(core.updateOpportunities)
export const getTotalOpportunitiesCount = wrap(core.getTotalOpportunitiesCount)
export const getOpportunities = wrap(core.getOpportunities)
export const getOpportunityDetails = wrap(core.getOpportunityDetails)
export const updateOpportunity = wrap(core.updateOpportunity)
export const deleteOpportunity = wrap(core.deleteOpportunity)
export const updateSourceAnalyticsBatch = wrap(core.updateSourceAnalyticsBatch)
export const findSourcesForScraping = wrap(core.findSourcesForScraping)
export const performHousekeeping = wrap(core.performHousekeeping)
export const bulkWriteEvents = wrap(core.bulkWriteEvents)
export const bulkWriteArticles = wrap(core.bulkWriteArticles)
export const findEventsByKeys = wrap(core.findEventsByKeys)
export const findArticlesByLinks = wrap(core.findArticlesByLinks)
export const getActiveWatchlistEntityNames = wrap(core.getActiveWatchlistEntityNames)
export const bulkWriteWatchlistSuggestions = wrap(core.bulkWriteWatchlistSuggestions)
export const linkOpportunityToEvent = wrap(core.linkOpportunityToEvent)
export const unlinkOpportunityFromEvent = wrap(core.unlinkOpportunityFromEvent)
export const getSettings = wrap(core.getSettings)
export const upsertSubscriber = wrap(core.upsertSubscriber)
export const getAllPushSubscriptions = wrap(core.getAllPushSubscriptions)
export const deletePushSubscription = wrap(core.deletePushSubscription)
export const getCurrentSubscriber = wrap(core.getCurrentSubscriber)
export const savePushSubscription = wrap(core.savePushSubscription)
export const updateUserProfile = wrap(core.updateUserProfile)
export const updateUserInteraction = wrap(core.updateUserInteraction)
export const processUploadedArticle = wrap(core.processUploadedArticle)
export const clearDiscardedItems = wrap(core.clearDiscardedItems)
export const getRecentRunVerdicts = wrap(core.getRecentRunVerdicts)
export const getRunVerdictById = wrap(core.getRunVerdictById)
export const findWatchlistEntities = wrap(core.findWatchlistEntities)
export const updateWatchlistEntities = wrap(core.updateWatchlistEntities)
export const createWatchlistEntity = wrap(core.createWatchlistEntity)
export const updateWatchlistEntity = wrap(core.updateWatchlistEntity)
export const deleteWatchlistEntity = wrap(core.deleteWatchlistEntity)
export const updateWatchlistSuggestion = wrap(core.updateWatchlistSuggestion)
export const processWatchlistSuggestion = wrap(core.processWatchlistSuggestion)
export const deleteAllSince = wrap(core.deleteAllSince)
export const resetAllSourceAnalytics = wrap(core.resetAllSourceAnalytics)
export const resetEventsEmailedStatusSince = wrap(core.resetEventsEmailedStatusSince)

// Special wrapper for updateSettings to include revalidation
export const updateSettings = async (...args) => {
  await dbConnect()
  const result = await core.updateSettings(...args)
  if (result.success) {
    await revalidatePath('/admin/settings')
  }
  return result
}

// Export non-wrapped utilities
export { buildQuery, revalidatePath }

```

## ðŸ“„ src/queryBuilder.js
*Lines: 90, Size: 2.76 KB*

```javascript
// packages/data-access/src/queryBuilder.js (version 2.1.0 - Multi-country support)
import { Subscriber } from '@headlines/models'

export async function buildQuery(
  model,
  { filters = {}, sort = 'date_desc', baseQuery = {}, userId = null }
) {
  const andConditions = [{ ...baseQuery }]
  let user = null

  if (userId) {
    user = await Subscriber.findById(userId)
      .select('discardedItems favoritedItems countries role')
      .lean()
  }

  const countryField = model.schema.paths.basedIn ? 'basedIn' : 'country'

  if (user) {
    if (user.role === 'admin') {
      if (filters.country) {
        andConditions.push({ [countryField]: { $in: filters.country.split(',') } })
      }
    } else {
      const subscribedCountries = (user.countries || [])
        .filter((c) => c.active)
        .map((c) => c.name)
      if (subscribedCountries.length > 0) {
        andConditions.push({ [countryField]: { $in: subscribedCountries } })
      } else {
        andConditions.push({ [countryField]: { $in: [] } }) // See nothing
      }
    }

    if (user?.discardedItems) {
      const modelName = model.modelName.toLowerCase()
      const discardedIds = user.discardedItems[`${modelName}s`]
      if (discardedIds && discardedIds.length > 0) {
        andConditions.push({ _id: { $nin: discardedIds } })
      }
    }
  } else if (filters.country) {
    andConditions.push({ [countryField]: { $in: filters.country.split(',') } })
  }

  if (filters.q) {
    const searchRegex = { $regex: filters.q, $options: 'i' }
    const orConditions = [
      { headline: searchRegex },
      { synthesized_headline: searchRegex },
      { reachOutTo: searchRegex },
    ].filter((cond) => model.schema.paths[Object.keys(cond)[0]])

    if (orConditions.length > 0) andConditions.push({ $or: orConditions })
  }

  if (filters.category) andConditions.push({ eventClassification: filters.category })
  if (filters.withEmail)
    andConditions.push({ 'contactDetails.email': { $exists: true, $ne: null, $ne: '' } })

  if (user?.favoritedItems && filters.favoritesOnly) {
    const modelName = model.modelName.toLowerCase()
    const favoritedIds = user.favoritedItems[`${modelName}s`] || []
    andConditions.push({ _id: { $in: favoritedIds } })
  }

  const queryFilter =
    andConditions.length > 1 ? { $and: andConditions } : andConditions[0] || {}

  const sortOptions = {}
  if (sort) {
    let [key, direction] = sort.split('_')
    const sortKeyMap = {
      date: 'createdAt',
      relevance: 'highest_relevance_score',
      size: 'likelyMMDollarWealth',
    }
    key = sortKeyMap[key] || key
    if (key && direction) {
      sortOptions[key] = direction === 'desc' ? -1 : 1
    } else {
      sortOptions.createdAt = -1
    }
  } else {
    sortOptions.createdAt = -1
  }

  return { queryFilter, sortOptions }
}

```

## ðŸ“„ src/revalidate.js
*Lines: 23, Size: 833 Bytes*

```javascript
// packages/data-access/src/revalidate.js
/**
 * An environment-aware revalidation function.
 * This function is now async to handle the dynamic import safely.
 * @param {string} path - The path to revalidate.
 * @param {('layout'|'page')} [type] - The type of revalidation.
 */
export async function revalidatePath(path, type) {
  // In the pipeline environment, this function is a no-op.
  if (process.env.IS_PIPELINE_RUN === 'true') {
    return
  }

  try {
    // This dynamic import will only succeed in a Next.js environment.
    const { revalidatePath: nextRevalidate } = await import('next/cache')
    return nextRevalidate(path, type)
  } catch (e) {
    // This catch block handles cases where it might be run in an unexpected env.
    console.log('[data-access] Failed to import next/cache. Revalidation skipped.')
  }
}

```

## ðŸ“„ src/seed/dev-user.js
*Lines: 62, Size: 1.91 KB*

```javascript
// packages/data-access/src/seed/dev-user.js (version 2.0.0 - Standalone Safe)
import { Subscriber } from '../../../models/src/index.js'
import dbConnect from '@headlines/data-access/dbConnect/node'
import mongoose from 'mongoose'
// We cannot use a logger here as this might be called before initialization
// import { logger } from '../../../utils/src/server.js';

const DEV_USER_ID = '662f831abb28052123530a43'
const DEV_USER_EMAIL = 'dev@headlines.dev'

export async function seedDevUser() {
  console.log(`[Seed] Seeding development user: ${DEV_USER_EMAIL}...`)
  try {
    await dbConnect()

    const devUser = {
      _id: new mongoose.Types.ObjectId(DEV_USER_ID),
      email: DEV_USER_EMAIL,
      password: 'devpassword', // This will be hashed by the pre-save hook
      firstName: 'Dev',
      lastName: 'User',
      role: 'admin',
      isActive: true,
      countries: [],
      subscriptionTier: 'enterprise',
      isLifetimeFree: true,
    }

    const result = await Subscriber.updateOne(
      { _id: devUser._id },
      { $set: devUser },
      { upsert: true }
    )

    if (result.upsertedCount > 0) {
      console.log(`[Seed] âœ… Successfully created development user.`)
    } else {
      console.log(`[Seed] âœ… Development user is already up-to-date.`)
    }
    return { success: true }
  } catch (error) {
    console.error('[Seed] âŒ Failed to seed development user:', error)
    // Close connection on error if it's open and this is a standalone script run
    if (mongoose.connection.readyState === 1 && import.meta.url.startsWith('file:')) {
      await mongoose.disconnect()
    }
    return { success: false, error: error.message }
  }
}

// Allow script to be run directly from the command line
if (
  import.meta.url.startsWith('file://') &&
  process.argv[1] === import.meta.url.substring(7)
) {
  seedDevUser().finally(() => {
    if (mongoose.connection.readyState === 1) {
      mongoose.disconnect()
    }
  })
}

```
